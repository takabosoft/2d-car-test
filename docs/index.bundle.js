/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/planck/dist/planck.js":
/*!********************************************!*\
  !*** ./node_modules/planck/dist/planck.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("(function(global, factory) {\n   true ? factory(exports) : 0;\n})(this, function(exports2) {\n  \"use strict\";/**\n * Planck.js v1.3.0\n * @license The MIT license\n * @copyright Copyright (c) 2024 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n  /*! *****************************************************************************\n      Copyright (c) Microsoft Corporation.\n  \n      Permission to use, copy, modify, and/or distribute this software for any\n      purpose with or without fee is hereby granted.\n  \n      THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n      REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n      AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n      INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n      LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n      OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n      PERFORMANCE OF THIS SOFTWARE.\n      ***************************************************************************** */\n  var extendStatics = function(d2, b2) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n      d3.__proto__ = b3;\n    } || function(d3, b3) {\n      for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d3[p] = b3[p];\n    };\n    return extendStatics(d2, b2);\n  };\n  function __extends(d2, b2) {\n    if (typeof b2 !== \"function\" && b2 !== null)\n      throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n    extendStatics(d2, b2);\n    function __() {\n      this.constructor = d2;\n    }\n    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n  }\n  var __assign = function() {\n    __assign = Object.assign || function __assign2(t) {\n      for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {\n        s2 = arguments[i];\n        for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p)) t[p] = s2[p];\n      }\n      return t;\n    };\n    return __assign.apply(this, arguments);\n  };\n  var options = function(input2, defaults) {\n    if (input2 === null || typeof input2 === \"undefined\") {\n      input2 = {};\n    }\n    var output2 = __assign({}, input2);\n    for (var key in defaults) {\n      if (defaults.hasOwnProperty(key) && typeof input2[key] === \"undefined\") {\n        output2[key] = defaults[key];\n      }\n    }\n    if (typeof Object.getOwnPropertySymbols === \"function\") {\n      var symbols = Object.getOwnPropertySymbols(defaults);\n      for (var i = 0; i < symbols.length; i++) {\n        var symbol = symbols[i];\n        if (defaults.propertyIsEnumerable(symbol) && typeof input2[symbol] === \"undefined\") {\n          output2[symbol] = defaults[symbol];\n        }\n      }\n    }\n    return output2;\n  };\n  var math_random = Math.random;\n  var EPSILON = 1e-9;\n  var isFinite = Number.isFinite;\n  function nextPowerOfTwo(x2) {\n    x2 |= x2 >> 1;\n    x2 |= x2 >> 2;\n    x2 |= x2 >> 4;\n    x2 |= x2 >> 8;\n    x2 |= x2 >> 16;\n    return x2 + 1;\n  }\n  function isPowerOfTwo(x2) {\n    return x2 > 0 && (x2 & x2 - 1) === 0;\n  }\n  function mod(num, min, max) {\n    if (typeof min === \"undefined\") {\n      max = 1;\n      min = 0;\n    } else if (typeof max === \"undefined\") {\n      max = min;\n      min = 0;\n    }\n    if (max > min) {\n      num = (num - min) % (max - min);\n      return num + (num < 0 ? max : min);\n    } else {\n      num = (num - max) % (min - max);\n      return num + (num <= 0 ? min : max);\n    }\n  }\n  function clamp(num, min, max) {\n    if (num < min) {\n      return min;\n    } else if (num > max) {\n      return max;\n    } else {\n      return num;\n    }\n  }\n  function random(min, max) {\n    if (typeof min === \"undefined\") {\n      max = 1;\n      min = 0;\n    } else if (typeof max === \"undefined\") {\n      max = min;\n      min = 0;\n    }\n    return min === max ? min : math_random() * (max - min) + min;\n  }\n  var math = Object.create(Math);\n  math.EPSILON = EPSILON;\n  math.isFinite = isFinite;\n  math.nextPowerOfTwo = nextPowerOfTwo;\n  math.isPowerOfTwo = isPowerOfTwo;\n  math.mod = mod;\n  math.clamp = clamp;\n  math.random = random;\n  var math_abs$9 = Math.abs;\n  var math_sqrt$5 = Math.sqrt;\n  var math_max$8 = Math.max;\n  var math_min$8 = Math.min;\n  var Vec2 = (\n    /** @class */\n    function() {\n      function Vec22(x2, y) {\n        if (!(this instanceof Vec22)) {\n          return new Vec22(x2, y);\n        }\n        if (typeof x2 === \"undefined\") {\n          this.x = 0;\n          this.y = 0;\n        } else if (typeof x2 === \"object\") {\n          this.x = x2.x;\n          this.y = x2.y;\n        } else {\n          this.x = x2;\n          this.y = y;\n        }\n      }\n      Vec22.prototype._serialize = function() {\n        return {\n          x: this.x,\n          y: this.y\n        };\n      };\n      Vec22._deserialize = function(data) {\n        var obj = Object.create(Vec22.prototype);\n        obj.x = data.x;\n        obj.y = data.y;\n        return obj;\n      };\n      Vec22.zero = function() {\n        var obj = Object.create(Vec22.prototype);\n        obj.x = 0;\n        obj.y = 0;\n        return obj;\n      };\n      Vec22.neo = function(x2, y) {\n        var obj = Object.create(Vec22.prototype);\n        obj.x = x2;\n        obj.y = y;\n        return obj;\n      };\n      Vec22.clone = function(v3) {\n        return Vec22.neo(v3.x, v3.y);\n      };\n      Vec22.prototype.toString = function() {\n        return JSON.stringify(this);\n      };\n      Vec22.isValid = function(obj) {\n        if (obj === null || typeof obj === \"undefined\") {\n          return false;\n        }\n        return Number.isFinite(obj.x) && Number.isFinite(obj.y);\n      };\n      Vec22.assert = function(o) {\n      };\n      Vec22.prototype.clone = function() {\n        return Vec22.clone(this);\n      };\n      Vec22.prototype.setZero = function() {\n        this.x = 0;\n        this.y = 0;\n        return this;\n      };\n      Vec22.prototype.set = function(x2, y) {\n        if (typeof x2 === \"object\") {\n          this.x = x2.x;\n          this.y = x2.y;\n        } else {\n          this.x = x2;\n          this.y = y;\n        }\n        return this;\n      };\n      Vec22.prototype.setNum = function(x2, y) {\n        this.x = x2;\n        this.y = y;\n        return this;\n      };\n      Vec22.prototype.setVec2 = function(value) {\n        this.x = value.x;\n        this.y = value.y;\n        return this;\n      };\n      Vec22.prototype.wSet = function(a2, v3, b2, w) {\n        if (typeof b2 !== \"undefined\" || typeof w !== \"undefined\") {\n          return this.setCombine(a2, v3, b2, w);\n        } else {\n          return this.setMul(a2, v3);\n        }\n      };\n      Vec22.prototype.setCombine = function(a2, v3, b2, w) {\n        var x2 = a2 * v3.x + b2 * w.x;\n        var y = a2 * v3.y + b2 * w.y;\n        this.x = x2;\n        this.y = y;\n        return this;\n      };\n      Vec22.prototype.setMul = function(a2, v3) {\n        var x2 = a2 * v3.x;\n        var y = a2 * v3.y;\n        this.x = x2;\n        this.y = y;\n        return this;\n      };\n      Vec22.prototype.add = function(w) {\n        this.x += w.x;\n        this.y += w.y;\n        return this;\n      };\n      Vec22.prototype.wAdd = function(a2, v3, b2, w) {\n        if (typeof b2 !== \"undefined\" || typeof w !== \"undefined\") {\n          return this.addCombine(a2, v3, b2, w);\n        } else {\n          return this.addMul(a2, v3);\n        }\n      };\n      Vec22.prototype.addCombine = function(a2, v3, b2, w) {\n        var x2 = a2 * v3.x + b2 * w.x;\n        var y = a2 * v3.y + b2 * w.y;\n        this.x += x2;\n        this.y += y;\n        return this;\n      };\n      Vec22.prototype.addMul = function(a2, v3) {\n        var x2 = a2 * v3.x;\n        var y = a2 * v3.y;\n        this.x += x2;\n        this.y += y;\n        return this;\n      };\n      Vec22.prototype.wSub = function(a2, v3, b2, w) {\n        if (typeof b2 !== \"undefined\" || typeof w !== \"undefined\") {\n          return this.subCombine(a2, v3, b2, w);\n        } else {\n          return this.subMul(a2, v3);\n        }\n      };\n      Vec22.prototype.subCombine = function(a2, v3, b2, w) {\n        var x2 = a2 * v3.x + b2 * w.x;\n        var y = a2 * v3.y + b2 * w.y;\n        this.x -= x2;\n        this.y -= y;\n        return this;\n      };\n      Vec22.prototype.subMul = function(a2, v3) {\n        var x2 = a2 * v3.x;\n        var y = a2 * v3.y;\n        this.x -= x2;\n        this.y -= y;\n        return this;\n      };\n      Vec22.prototype.sub = function(w) {\n        this.x -= w.x;\n        this.y -= w.y;\n        return this;\n      };\n      Vec22.prototype.mul = function(m) {\n        this.x *= m;\n        this.y *= m;\n        return this;\n      };\n      Vec22.prototype.length = function() {\n        return Vec22.lengthOf(this);\n      };\n      Vec22.prototype.lengthSquared = function() {\n        return Vec22.lengthSquared(this);\n      };\n      Vec22.prototype.normalize = function() {\n        var length = this.length();\n        if (length < EPSILON) {\n          return 0;\n        }\n        var invLength = 1 / length;\n        this.x *= invLength;\n        this.y *= invLength;\n        return length;\n      };\n      Vec22.normalize = function(v3) {\n        var length = Vec22.lengthOf(v3);\n        if (length < EPSILON) {\n          return Vec22.zero();\n        }\n        var invLength = 1 / length;\n        return Vec22.neo(v3.x * invLength, v3.y * invLength);\n      };\n      Vec22.lengthOf = function(v3) {\n        return math_sqrt$5(v3.x * v3.x + v3.y * v3.y);\n      };\n      Vec22.lengthSquared = function(v3) {\n        return v3.x * v3.x + v3.y * v3.y;\n      };\n      Vec22.distance = function(v3, w) {\n        var dx = v3.x - w.x;\n        var dy = v3.y - w.y;\n        return math_sqrt$5(dx * dx + dy * dy);\n      };\n      Vec22.distanceSquared = function(v3, w) {\n        var dx = v3.x - w.x;\n        var dy = v3.y - w.y;\n        return dx * dx + dy * dy;\n      };\n      Vec22.areEqual = function(v3, w) {\n        return v3 === w || typeof w === \"object\" && w !== null && v3.x === w.x && v3.y === w.y;\n      };\n      Vec22.skew = function(v3) {\n        return Vec22.neo(-v3.y, v3.x);\n      };\n      Vec22.dot = function(v3, w) {\n        return v3.x * w.x + v3.y * w.y;\n      };\n      Vec22.cross = function(v3, w) {\n        if (typeof w === \"number\") {\n          return Vec22.neo(w * v3.y, -w * v3.x);\n        } else if (typeof v3 === \"number\") {\n          return Vec22.neo(-v3 * w.y, v3 * w.x);\n        } else {\n          return v3.x * w.y - v3.y * w.x;\n        }\n      };\n      Vec22.crossVec2Vec2 = function(v3, w) {\n        return v3.x * w.y - v3.y * w.x;\n      };\n      Vec22.crossVec2Num = function(v3, w) {\n        return Vec22.neo(w * v3.y, -w * v3.x);\n      };\n      Vec22.crossNumVec2 = function(v3, w) {\n        return Vec22.neo(-v3 * w.y, v3 * w.x);\n      };\n      Vec22.addCross = function(a2, v3, w) {\n        if (typeof w === \"number\") {\n          return Vec22.neo(w * v3.y + a2.x, -w * v3.x + a2.y);\n        } else if (typeof v3 === \"number\") {\n          return Vec22.neo(-v3 * w.y + a2.x, v3 * w.x + a2.y);\n        }\n      };\n      Vec22.addCrossVec2Num = function(a2, v3, w) {\n        return Vec22.neo(w * v3.y + a2.x, -w * v3.x + a2.y);\n      };\n      Vec22.addCrossNumVec2 = function(a2, v3, w) {\n        return Vec22.neo(-v3 * w.y + a2.x, v3 * w.x + a2.y);\n      };\n      Vec22.add = function(v3, w) {\n        return Vec22.neo(v3.x + w.x, v3.y + w.y);\n      };\n      Vec22.wAdd = function(a2, v3, b2, w) {\n        if (typeof b2 !== \"undefined\" || typeof w !== \"undefined\") {\n          return Vec22.combine(a2, v3, b2, w);\n        } else {\n          return Vec22.mulNumVec2(a2, v3);\n        }\n      };\n      Vec22.combine = function(a2, v3, b2, w) {\n        return Vec22.zero().setCombine(a2, v3, b2, w);\n      };\n      Vec22.sub = function(v3, w) {\n        return Vec22.neo(v3.x - w.x, v3.y - w.y);\n      };\n      Vec22.mul = function(a2, b2) {\n        if (typeof a2 === \"object\") {\n          return Vec22.neo(a2.x * b2, a2.y * b2);\n        } else if (typeof b2 === \"object\") {\n          return Vec22.neo(a2 * b2.x, a2 * b2.y);\n        }\n      };\n      Vec22.mulVec2Num = function(a2, b2) {\n        return Vec22.neo(a2.x * b2, a2.y * b2);\n      };\n      Vec22.mulNumVec2 = function(a2, b2) {\n        return Vec22.neo(a2 * b2.x, a2 * b2.y);\n      };\n      Vec22.prototype.neg = function() {\n        this.x = -this.x;\n        this.y = -this.y;\n        return this;\n      };\n      Vec22.neg = function(v3) {\n        return Vec22.neo(-v3.x, -v3.y);\n      };\n      Vec22.abs = function(v3) {\n        return Vec22.neo(math_abs$9(v3.x), math_abs$9(v3.y));\n      };\n      Vec22.mid = function(v3, w) {\n        return Vec22.neo((v3.x + w.x) * 0.5, (v3.y + w.y) * 0.5);\n      };\n      Vec22.upper = function(v3, w) {\n        return Vec22.neo(math_max$8(v3.x, w.x), math_max$8(v3.y, w.y));\n      };\n      Vec22.lower = function(v3, w) {\n        return Vec22.neo(math_min$8(v3.x, w.x), math_min$8(v3.y, w.y));\n      };\n      Vec22.prototype.clamp = function(max) {\n        var lengthSqr = this.x * this.x + this.y * this.y;\n        if (lengthSqr > max * max) {\n          var scale = max / math_sqrt$5(lengthSqr);\n          this.x *= scale;\n          this.y *= scale;\n        }\n        return this;\n      };\n      Vec22.clamp = function(v3, max) {\n        var r = Vec22.neo(v3.x, v3.y);\n        r.clamp(max);\n        return r;\n      };\n      Vec22.clampVec2 = function(v3, min, max) {\n        return {\n          x: clamp(v3.x, min === null || min === void 0 ? void 0 : min.x, max === null || max === void 0 ? void 0 : max.x),\n          y: clamp(v3.y, min === null || min === void 0 ? void 0 : min.y, max === null || max === void 0 ? void 0 : max.y)\n        };\n      };\n      Vec22.scaleFn = function(x2, y) {\n        return function(v3) {\n          return Vec22.neo(v3.x * x2, v3.y * y);\n        };\n      };\n      Vec22.translateFn = function(x2, y) {\n        return function(v3) {\n          return Vec22.neo(v3.x + x2, v3.y + y);\n        };\n      };\n      return Vec22;\n    }()\n  );\n  var math_max$7 = Math.max;\n  var math_min$7 = Math.min;\n  var AABB = (\n    /** @class */\n    function() {\n      function AABB2(lower, upper) {\n        if (!(this instanceof AABB2)) {\n          return new AABB2(lower, upper);\n        }\n        this.lowerBound = Vec2.zero();\n        this.upperBound = Vec2.zero();\n        if (typeof lower === \"object\") {\n          this.lowerBound.setVec2(lower);\n        }\n        if (typeof upper === \"object\") {\n          this.upperBound.setVec2(upper);\n        } else if (typeof lower === \"object\") {\n          this.upperBound.setVec2(lower);\n        }\n      }\n      AABB2.prototype.isValid = function() {\n        return AABB2.isValid(this);\n      };\n      AABB2.isValid = function(obj) {\n        if (obj === null || typeof obj === \"undefined\") {\n          return false;\n        }\n        return Vec2.isValid(obj.lowerBound) && Vec2.isValid(obj.upperBound) && Vec2.sub(obj.upperBound, obj.lowerBound).lengthSquared() >= 0;\n      };\n      AABB2.assert = function(o) {\n      };\n      AABB2.prototype.getCenter = function() {\n        return Vec2.neo((this.lowerBound.x + this.upperBound.x) * 0.5, (this.lowerBound.y + this.upperBound.y) * 0.5);\n      };\n      AABB2.prototype.getExtents = function() {\n        return Vec2.neo((this.upperBound.x - this.lowerBound.x) * 0.5, (this.upperBound.y - this.lowerBound.y) * 0.5);\n      };\n      AABB2.prototype.getPerimeter = function() {\n        return 2 * (this.upperBound.x - this.lowerBound.x + this.upperBound.y - this.lowerBound.y);\n      };\n      AABB2.prototype.combine = function(a2, b2) {\n        b2 = b2 || this;\n        var lowerA = a2.lowerBound;\n        var upperA = a2.upperBound;\n        var lowerB = b2.lowerBound;\n        var upperB = b2.upperBound;\n        var lowerX = math_min$7(lowerA.x, lowerB.x);\n        var lowerY = math_min$7(lowerA.y, lowerB.y);\n        var upperX = math_max$7(upperB.x, upperA.x);\n        var upperY = math_max$7(upperB.y, upperA.y);\n        this.lowerBound.setNum(lowerX, lowerY);\n        this.upperBound.setNum(upperX, upperY);\n      };\n      AABB2.prototype.combinePoints = function(a2, b2) {\n        this.lowerBound.setNum(math_min$7(a2.x, b2.x), math_min$7(a2.y, b2.y));\n        this.upperBound.setNum(math_max$7(a2.x, b2.x), math_max$7(a2.y, b2.y));\n      };\n      AABB2.prototype.set = function(aabb) {\n        this.lowerBound.setNum(aabb.lowerBound.x, aabb.lowerBound.y);\n        this.upperBound.setNum(aabb.upperBound.x, aabb.upperBound.y);\n      };\n      AABB2.prototype.contains = function(aabb) {\n        var result = true;\n        result = result && this.lowerBound.x <= aabb.lowerBound.x;\n        result = result && this.lowerBound.y <= aabb.lowerBound.y;\n        result = result && aabb.upperBound.x <= this.upperBound.x;\n        result = result && aabb.upperBound.y <= this.upperBound.y;\n        return result;\n      };\n      AABB2.prototype.extend = function(value) {\n        AABB2.extend(this, value);\n        return this;\n      };\n      AABB2.extend = function(out, value) {\n        out.lowerBound.x -= value;\n        out.lowerBound.y -= value;\n        out.upperBound.x += value;\n        out.upperBound.y += value;\n        return out;\n      };\n      AABB2.testOverlap = function(a2, b2) {\n        var d1x = b2.lowerBound.x - a2.upperBound.x;\n        var d2x = a2.lowerBound.x - b2.upperBound.x;\n        var d1y = b2.lowerBound.y - a2.upperBound.y;\n        var d2y = a2.lowerBound.y - b2.upperBound.y;\n        if (d1x > 0 || d1y > 0 || d2x > 0 || d2y > 0) {\n          return false;\n        }\n        return true;\n      };\n      AABB2.areEqual = function(a2, b2) {\n        return Vec2.areEqual(a2.lowerBound, b2.lowerBound) && Vec2.areEqual(a2.upperBound, b2.upperBound);\n      };\n      AABB2.diff = function(a2, b2) {\n        var wD = math_max$7(0, math_min$7(a2.upperBound.x, b2.upperBound.x) - math_max$7(b2.lowerBound.x, a2.lowerBound.x));\n        var hD = math_max$7(0, math_min$7(a2.upperBound.y, b2.upperBound.y) - math_max$7(b2.lowerBound.y, a2.lowerBound.y));\n        var wA = a2.upperBound.x - a2.lowerBound.x;\n        var hA = a2.upperBound.y - a2.lowerBound.y;\n        var wB = b2.upperBound.x - b2.lowerBound.x;\n        var hB = b2.upperBound.y - b2.lowerBound.y;\n        return wA * hA + wB * hB - wD * hD;\n      };\n      AABB2.prototype.rayCast = function(output2, input2) {\n        var tmin = -Infinity;\n        var tmax = Infinity;\n        var p = input2.p1;\n        var d2 = Vec2.sub(input2.p2, input2.p1);\n        var absD = Vec2.abs(d2);\n        var normal3 = Vec2.zero();\n        for (var f = \"x\"; f !== null; f = f === \"x\" ? \"y\" : null) {\n          if (absD.x < EPSILON) {\n            if (p[f] < this.lowerBound[f] || this.upperBound[f] < p[f]) {\n              return false;\n            }\n          } else {\n            var inv_d = 1 / d2[f];\n            var t1 = (this.lowerBound[f] - p[f]) * inv_d;\n            var t2 = (this.upperBound[f] - p[f]) * inv_d;\n            var s2 = -1;\n            if (t1 > t2) {\n              var temp3 = t1;\n              t1 = t2;\n              t2 = temp3;\n              s2 = 1;\n            }\n            if (t1 > tmin) {\n              normal3.setZero();\n              normal3[f] = s2;\n              tmin = t1;\n            }\n            tmax = math_min$7(tmax, t2);\n            if (tmin > tmax) {\n              return false;\n            }\n          }\n        }\n        if (tmin < 0 || input2.maxFraction < tmin) {\n          return false;\n        }\n        output2.fraction = tmin;\n        output2.normal = normal3;\n        return true;\n      };\n      AABB2.prototype.toString = function() {\n        return JSON.stringify(this);\n      };\n      AABB2.combinePoints = function(out, a2, b2) {\n        out.lowerBound.x = math_min$7(a2.x, b2.x);\n        out.lowerBound.y = math_min$7(a2.y, b2.y);\n        out.upperBound.x = math_max$7(a2.x, b2.x);\n        out.upperBound.y = math_max$7(a2.y, b2.y);\n        return out;\n      };\n      AABB2.combinedPerimeter = function(a2, b2) {\n        var lx = math_min$7(a2.lowerBound.x, b2.lowerBound.x);\n        var ly = math_min$7(a2.lowerBound.y, b2.lowerBound.y);\n        var ux = math_max$7(a2.upperBound.x, b2.upperBound.x);\n        var uy = math_max$7(a2.upperBound.y, b2.upperBound.y);\n        return 2 * (ux - lx + uy - ly);\n      };\n      return AABB2;\n    }()\n  );\n  var math_PI$6 = Math.PI;\n  var Settings = (\n    /** @class */\n    function() {\n      function Settings2() {\n      }\n      Object.defineProperty(Settings2, \"polygonRadius\", {\n        /**\n         * The radius of the polygon/edge shape skin. This should not be modified.\n         * Making this smaller means polygons will have an insufficient buffer for\n         * continuous collision. Making it larger may create artifacts for vertex\n         * collision.\n         */\n        get: function() {\n          return 2 * Settings2.linearSlop;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Settings2.lengthUnitsPerMeter = 1;\n      Settings2.maxManifoldPoints = 2;\n      Settings2.maxPolygonVertices = 12;\n      Settings2.aabbExtension = 0.1;\n      Settings2.aabbMultiplier = 2;\n      Settings2.linearSlop = 5e-3;\n      Settings2.angularSlop = 2 / 180 * math_PI$6;\n      Settings2.maxSubSteps = 8;\n      Settings2.maxTOIContacts = 32;\n      Settings2.maxTOIIterations = 20;\n      Settings2.maxDistanceIterations = 20;\n      Settings2.velocityThreshold = 1;\n      Settings2.maxLinearCorrection = 0.2;\n      Settings2.maxAngularCorrection = 8 / 180 * math_PI$6;\n      Settings2.maxTranslation = 2;\n      Settings2.maxRotation = 0.5 * math_PI$6;\n      Settings2.baumgarte = 0.2;\n      Settings2.toiBaugarte = 0.75;\n      Settings2.timeToSleep = 0.5;\n      Settings2.linearSleepTolerance = 0.01;\n      Settings2.angularSleepTolerance = 2 / 180 * math_PI$6;\n      return Settings2;\n    }()\n  );\n  var SettingsInternal = (\n    /** @class */\n    function() {\n      function SettingsInternal2() {\n      }\n      Object.defineProperty(SettingsInternal2, \"maxManifoldPoints\", {\n        get: function() {\n          return Settings.maxManifoldPoints;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(SettingsInternal2, \"maxPolygonVertices\", {\n        get: function() {\n          return Settings.maxPolygonVertices;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(SettingsInternal2, \"aabbExtension\", {\n        get: function() {\n          return Settings.aabbExtension * Settings.lengthUnitsPerMeter;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(SettingsInternal2, \"aabbMultiplier\", {\n        get: function() {\n          return Settings.aabbMultiplier;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(SettingsInternal2, \"linearSlop\", {\n        get: function() {\n          return Settings.linearSlop * Settings.lengthUnitsPerMeter;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(SettingsInternal2, \"linearSlopSquared\", {\n        get: function() {\n          return Settings.linearSlop * Settings.lengthUnitsPerMeter * Settings.linearSlop * Settings.lengthUnitsPerMeter;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(SettingsInternal2, \"angularSlop\", {\n        get: function() {\n          return Settings.angularSlop;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(SettingsInternal2, \"polygonRadius\", {\n        get: function() {\n          return 2 * Settings.linearSlop;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(SettingsInternal2, \"maxSubSteps\", {\n        get: function() {\n          return Settings.maxSubSteps;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(SettingsInternal2, \"maxTOIContacts\", {\n        get: function() {\n          return Settings.maxTOIContacts;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(SettingsInternal2, \"maxTOIIterations\", {\n        get: function() {\n          return Settings.maxTOIIterations;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(SettingsInternal2, \"maxDistanceIterations\", {\n        get: function() {\n          return Settings.maxDistanceIterations;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(SettingsInternal2, \"velocityThreshold\", {\n        get: function() {\n          return Settings.velocityThreshold * Settings.lengthUnitsPerMeter;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(SettingsInternal2, \"maxLinearCorrection\", {\n        get: function() {\n          return Settings.maxLinearCorrection * Settings.lengthUnitsPerMeter;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(SettingsInternal2, \"maxAngularCorrection\", {\n        get: function() {\n          return Settings.maxAngularCorrection;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(SettingsInternal2, \"maxTranslation\", {\n        get: function() {\n          return Settings.maxTranslation * Settings.lengthUnitsPerMeter;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(SettingsInternal2, \"maxTranslationSquared\", {\n        get: function() {\n          return Settings.maxTranslation * Settings.lengthUnitsPerMeter * Settings.maxTranslation * Settings.lengthUnitsPerMeter;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(SettingsInternal2, \"maxRotation\", {\n        get: function() {\n          return Settings.maxRotation;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(SettingsInternal2, \"maxRotationSquared\", {\n        get: function() {\n          return Settings.maxRotation * Settings.maxRotation;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(SettingsInternal2, \"baumgarte\", {\n        get: function() {\n          return Settings.baumgarte;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(SettingsInternal2, \"toiBaugarte\", {\n        get: function() {\n          return Settings.toiBaugarte;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(SettingsInternal2, \"timeToSleep\", {\n        get: function() {\n          return Settings.timeToSleep;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(SettingsInternal2, \"linearSleepTolerance\", {\n        get: function() {\n          return Settings.linearSleepTolerance * Settings.lengthUnitsPerMeter;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(SettingsInternal2, \"linearSleepToleranceSqr\", {\n        get: function() {\n          return Settings.linearSleepTolerance * Settings.lengthUnitsPerMeter * Settings.linearSleepTolerance * Settings.lengthUnitsPerMeter;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(SettingsInternal2, \"angularSleepTolerance\", {\n        get: function() {\n          return Settings.angularSleepTolerance;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(SettingsInternal2, \"angularSleepToleranceSqr\", {\n        get: function() {\n          return Settings.angularSleepTolerance * Settings.angularSleepTolerance;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      return SettingsInternal2;\n    }()\n  );\n  var Pool = (\n    /** @class */\n    function() {\n      function Pool2(opts) {\n        this._list = [];\n        this._max = Infinity;\n        this._hasCreateFn = false;\n        this._createCount = 0;\n        this._hasAllocateFn = false;\n        this._allocateCount = 0;\n        this._hasReleaseFn = false;\n        this._releaseCount = 0;\n        this._hasDisposeFn = false;\n        this._disposeCount = 0;\n        this._list = [];\n        this._max = opts.max || this._max;\n        this._createFn = opts.create;\n        this._hasCreateFn = typeof this._createFn === \"function\";\n        this._allocateFn = opts.allocate;\n        this._hasAllocateFn = typeof this._allocateFn === \"function\";\n        this._releaseFn = opts.release;\n        this._hasReleaseFn = typeof this._releaseFn === \"function\";\n        this._disposeFn = opts.dispose;\n        this._hasDisposeFn = typeof this._disposeFn === \"function\";\n      }\n      Pool2.prototype.max = function(n2) {\n        if (typeof n2 === \"number\") {\n          this._max = n2;\n          return this;\n        }\n        return this._max;\n      };\n      Pool2.prototype.size = function() {\n        return this._list.length;\n      };\n      Pool2.prototype.allocate = function() {\n        var item;\n        if (this._list.length > 0) {\n          item = this._list.shift();\n        } else {\n          this._createCount++;\n          if (this._hasCreateFn) {\n            item = this._createFn();\n          } else {\n            item = {};\n          }\n        }\n        this._allocateCount++;\n        if (this._hasAllocateFn) {\n          this._allocateFn(item);\n        }\n        return item;\n      };\n      Pool2.prototype.release = function(item) {\n        if (this._list.length < this._max) {\n          this._releaseCount++;\n          if (this._hasReleaseFn) {\n            this._releaseFn(item);\n          }\n          this._list.push(item);\n        } else {\n          this._disposeCount++;\n          if (this._hasDisposeFn) {\n            item = this._disposeFn(item);\n          }\n        }\n      };\n      Pool2.prototype.toString = function() {\n        return \" +\" + this._createCount + \" >\" + this._allocateCount + \" <\" + this._releaseCount + \" -\" + this._disposeCount + \" =\" + this._list.length + \"/\" + this._max;\n      };\n      return Pool2;\n    }()\n  );\n  var math_abs$8 = Math.abs;\n  var math_max$6 = Math.max;\n  var TreeNode = (\n    /** @class */\n    function() {\n      function TreeNode2(id) {\n        this.aabb = new AABB();\n        this.userData = null;\n        this.parent = null;\n        this.child1 = null;\n        this.child2 = null;\n        this.height = -1;\n        this.id = id;\n      }\n      TreeNode2.prototype.toString = function() {\n        return this.id + \": \" + this.userData;\n      };\n      TreeNode2.prototype.isLeaf = function() {\n        return this.child1 == null;\n      };\n      return TreeNode2;\n    }()\n  );\n  var poolTreeNode = new Pool({\n    create: function() {\n      return new TreeNode();\n    },\n    release: function(node) {\n      node.userData = null;\n      node.parent = null;\n      node.child1 = null;\n      node.child2 = null;\n      node.height = -1;\n      node.id = void 0;\n    }\n  });\n  var DynamicTree = (\n    /** @class */\n    function() {\n      function DynamicTree2() {\n        this.inputPool = new Pool({\n          create: function() {\n            return {};\n          },\n          release: function(stack) {\n          }\n        });\n        this.stackPool = new Pool({\n          create: function() {\n            return [];\n          },\n          release: function(stack) {\n            stack.length = 0;\n          }\n        });\n        this.iteratorPool = new Pool({\n          create: function() {\n            return new Iterator();\n          },\n          release: function(iterator) {\n            iterator.close();\n          }\n        });\n        this.m_root = null;\n        this.m_nodes = {};\n        this.m_lastProxyId = 0;\n      }\n      DynamicTree2.prototype.getUserData = function(id) {\n        var node = this.m_nodes[id];\n        return node.userData;\n      };\n      DynamicTree2.prototype.getFatAABB = function(id) {\n        var node = this.m_nodes[id];\n        return node.aabb;\n      };\n      DynamicTree2.prototype.allocateNode = function() {\n        var node = poolTreeNode.allocate();\n        node.id = ++this.m_lastProxyId;\n        this.m_nodes[node.id] = node;\n        return node;\n      };\n      DynamicTree2.prototype.freeNode = function(node) {\n        delete this.m_nodes[node.id];\n        poolTreeNode.release(node);\n      };\n      DynamicTree2.prototype.createProxy = function(aabb, userData) {\n        var node = this.allocateNode();\n        node.aabb.set(aabb);\n        AABB.extend(node.aabb, SettingsInternal.aabbExtension);\n        node.userData = userData;\n        node.height = 0;\n        this.insertLeaf(node);\n        return node.id;\n      };\n      DynamicTree2.prototype.destroyProxy = function(id) {\n        var node = this.m_nodes[id];\n        this.removeLeaf(node);\n        this.freeNode(node);\n      };\n      DynamicTree2.prototype.moveProxy = function(id, aabb, d2) {\n        var node = this.m_nodes[id];\n        if (node.aabb.contains(aabb)) {\n          return false;\n        }\n        this.removeLeaf(node);\n        node.aabb.set(aabb);\n        aabb = node.aabb;\n        AABB.extend(aabb, SettingsInternal.aabbExtension);\n        if (d2.x < 0) {\n          aabb.lowerBound.x += d2.x * SettingsInternal.aabbMultiplier;\n        } else {\n          aabb.upperBound.x += d2.x * SettingsInternal.aabbMultiplier;\n        }\n        if (d2.y < 0) {\n          aabb.lowerBound.y += d2.y * SettingsInternal.aabbMultiplier;\n        } else {\n          aabb.upperBound.y += d2.y * SettingsInternal.aabbMultiplier;\n        }\n        this.insertLeaf(node);\n        return true;\n      };\n      DynamicTree2.prototype.insertLeaf = function(leaf) {\n        if (this.m_root == null) {\n          this.m_root = leaf;\n          this.m_root.parent = null;\n          return;\n        }\n        var leafAABB = leaf.aabb;\n        var index = this.m_root;\n        while (!index.isLeaf()) {\n          var child1 = index.child1;\n          var child2 = index.child2;\n          var area = index.aabb.getPerimeter();\n          var combinedArea = AABB.combinedPerimeter(index.aabb, leafAABB);\n          var cost = 2 * combinedArea;\n          var inheritanceCost = 2 * (combinedArea - area);\n          var newArea1 = AABB.combinedPerimeter(leafAABB, child1.aabb);\n          var cost1 = newArea1 + inheritanceCost;\n          if (!child1.isLeaf()) {\n            var oldArea = child1.aabb.getPerimeter();\n            cost1 -= oldArea;\n          }\n          var newArea2 = AABB.combinedPerimeter(leafAABB, child2.aabb);\n          var cost2 = newArea2 + inheritanceCost;\n          if (!child2.isLeaf()) {\n            var oldArea = child2.aabb.getPerimeter();\n            cost2 -= oldArea;\n          }\n          if (cost < cost1 && cost < cost2) {\n            break;\n          }\n          if (cost1 < cost2) {\n            index = child1;\n          } else {\n            index = child2;\n          }\n        }\n        var sibling = index;\n        var oldParent = sibling.parent;\n        var newParent = this.allocateNode();\n        newParent.parent = oldParent;\n        newParent.userData = null;\n        newParent.aabb.combine(leafAABB, sibling.aabb);\n        newParent.height = sibling.height + 1;\n        if (oldParent != null) {\n          if (oldParent.child1 === sibling) {\n            oldParent.child1 = newParent;\n          } else {\n            oldParent.child2 = newParent;\n          }\n          newParent.child1 = sibling;\n          newParent.child2 = leaf;\n          sibling.parent = newParent;\n          leaf.parent = newParent;\n        } else {\n          newParent.child1 = sibling;\n          newParent.child2 = leaf;\n          sibling.parent = newParent;\n          leaf.parent = newParent;\n          this.m_root = newParent;\n        }\n        index = leaf.parent;\n        while (index != null) {\n          index = this.balance(index);\n          var child1 = index.child1;\n          var child2 = index.child2;\n          index.height = 1 + math_max$6(child1.height, child2.height);\n          index.aabb.combine(child1.aabb, child2.aabb);\n          index = index.parent;\n        }\n      };\n      DynamicTree2.prototype.removeLeaf = function(leaf) {\n        if (leaf === this.m_root) {\n          this.m_root = null;\n          return;\n        }\n        var parent = leaf.parent;\n        var grandParent = parent.parent;\n        var sibling;\n        if (parent.child1 === leaf) {\n          sibling = parent.child2;\n        } else {\n          sibling = parent.child1;\n        }\n        if (grandParent != null) {\n          if (grandParent.child1 === parent) {\n            grandParent.child1 = sibling;\n          } else {\n            grandParent.child2 = sibling;\n          }\n          sibling.parent = grandParent;\n          this.freeNode(parent);\n          var index = grandParent;\n          while (index != null) {\n            index = this.balance(index);\n            var child1 = index.child1;\n            var child2 = index.child2;\n            index.aabb.combine(child1.aabb, child2.aabb);\n            index.height = 1 + math_max$6(child1.height, child2.height);\n            index = index.parent;\n          }\n        } else {\n          this.m_root = sibling;\n          sibling.parent = null;\n          this.freeNode(parent);\n        }\n      };\n      DynamicTree2.prototype.balance = function(iA) {\n        var A = iA;\n        if (A.isLeaf() || A.height < 2) {\n          return iA;\n        }\n        var B = A.child1;\n        var C = A.child2;\n        var balance = C.height - B.height;\n        if (balance > 1) {\n          var F = C.child1;\n          var G = C.child2;\n          C.child1 = A;\n          C.parent = A.parent;\n          A.parent = C;\n          if (C.parent != null) {\n            if (C.parent.child1 === iA) {\n              C.parent.child1 = C;\n            } else {\n              C.parent.child2 = C;\n            }\n          } else {\n            this.m_root = C;\n          }\n          if (F.height > G.height) {\n            C.child2 = F;\n            A.child2 = G;\n            G.parent = A;\n            A.aabb.combine(B.aabb, G.aabb);\n            C.aabb.combine(A.aabb, F.aabb);\n            A.height = 1 + math_max$6(B.height, G.height);\n            C.height = 1 + math_max$6(A.height, F.height);\n          } else {\n            C.child2 = G;\n            A.child2 = F;\n            F.parent = A;\n            A.aabb.combine(B.aabb, F.aabb);\n            C.aabb.combine(A.aabb, G.aabb);\n            A.height = 1 + math_max$6(B.height, F.height);\n            C.height = 1 + math_max$6(A.height, G.height);\n          }\n          return C;\n        }\n        if (balance < -1) {\n          var D = B.child1;\n          var E = B.child2;\n          B.child1 = A;\n          B.parent = A.parent;\n          A.parent = B;\n          if (B.parent != null) {\n            if (B.parent.child1 === A) {\n              B.parent.child1 = B;\n            } else {\n              B.parent.child2 = B;\n            }\n          } else {\n            this.m_root = B;\n          }\n          if (D.height > E.height) {\n            B.child2 = D;\n            A.child1 = E;\n            E.parent = A;\n            A.aabb.combine(C.aabb, E.aabb);\n            B.aabb.combine(A.aabb, D.aabb);\n            A.height = 1 + math_max$6(C.height, E.height);\n            B.height = 1 + math_max$6(A.height, D.height);\n          } else {\n            B.child2 = E;\n            A.child1 = D;\n            D.parent = A;\n            A.aabb.combine(C.aabb, D.aabb);\n            B.aabb.combine(A.aabb, E.aabb);\n            A.height = 1 + math_max$6(C.height, D.height);\n            B.height = 1 + math_max$6(A.height, E.height);\n          }\n          return B;\n        }\n        return A;\n      };\n      DynamicTree2.prototype.getHeight = function() {\n        if (this.m_root == null) {\n          return 0;\n        }\n        return this.m_root.height;\n      };\n      DynamicTree2.prototype.getAreaRatio = function() {\n        if (this.m_root == null) {\n          return 0;\n        }\n        var root = this.m_root;\n        var rootArea = root.aabb.getPerimeter();\n        var totalArea = 0;\n        var node;\n        var it = this.iteratorPool.allocate().preorder(this.m_root);\n        while (node = it.next()) {\n          if (node.height < 0) {\n            continue;\n          }\n          totalArea += node.aabb.getPerimeter();\n        }\n        this.iteratorPool.release(it);\n        return totalArea / rootArea;\n      };\n      DynamicTree2.prototype.computeHeight = function(id) {\n        var node;\n        if (typeof id !== \"undefined\") {\n          node = this.m_nodes[id];\n        } else {\n          node = this.m_root;\n        }\n        if (node.isLeaf()) {\n          return 0;\n        }\n        var height1 = this.computeHeight(node.child1.id);\n        var height2 = this.computeHeight(node.child2.id);\n        return 1 + math_max$6(height1, height2);\n      };\n      DynamicTree2.prototype.validateStructure = function(node) {\n        if (node == null) {\n          return;\n        }\n        if (node === this.m_root) ;\n        var child1 = node.child1;\n        var child2 = node.child2;\n        if (node.isLeaf()) {\n          return;\n        }\n        this.validateStructure(child1);\n        this.validateStructure(child2);\n      };\n      DynamicTree2.prototype.validateMetrics = function(node) {\n        if (node == null) {\n          return;\n        }\n        var child1 = node.child1;\n        var child2 = node.child2;\n        if (node.isLeaf()) {\n          return;\n        }\n        child1.height;\n        child2.height;\n        var aabb = new AABB();\n        aabb.combine(child1.aabb, child2.aabb);\n        this.validateMetrics(child1);\n        this.validateMetrics(child2);\n      };\n      DynamicTree2.prototype.validate = function() {\n        return;\n      };\n      DynamicTree2.prototype.getMaxBalance = function() {\n        var maxBalance = 0;\n        var node;\n        var it = this.iteratorPool.allocate().preorder(this.m_root);\n        while (node = it.next()) {\n          if (node.height <= 1) {\n            continue;\n          }\n          var balance = math_abs$8(node.child2.height - node.child1.height);\n          maxBalance = math_max$6(maxBalance, balance);\n        }\n        this.iteratorPool.release(it);\n        return maxBalance;\n      };\n      DynamicTree2.prototype.rebuildBottomUp = function() {\n        var nodes = [];\n        var count = 0;\n        var node;\n        var it = this.iteratorPool.allocate().preorder(this.m_root);\n        while (node = it.next()) {\n          if (node.height < 0) {\n            continue;\n          }\n          if (node.isLeaf()) {\n            node.parent = null;\n            nodes[count] = node;\n            ++count;\n          } else {\n            this.freeNode(node);\n          }\n        }\n        this.iteratorPool.release(it);\n        while (count > 1) {\n          var minCost = Infinity;\n          var iMin = -1;\n          var jMin = -1;\n          for (var i = 0; i < count; ++i) {\n            var aabbi = nodes[i].aabb;\n            for (var j = i + 1; j < count; ++j) {\n              var aabbj = nodes[j].aabb;\n              var cost = AABB.combinedPerimeter(aabbi, aabbj);\n              if (cost < minCost) {\n                iMin = i;\n                jMin = j;\n                minCost = cost;\n              }\n            }\n          }\n          var child1 = nodes[iMin];\n          var child2 = nodes[jMin];\n          var parent_1 = this.allocateNode();\n          parent_1.child1 = child1;\n          parent_1.child2 = child2;\n          parent_1.height = 1 + math_max$6(child1.height, child2.height);\n          parent_1.aabb.combine(child1.aabb, child2.aabb);\n          parent_1.parent = null;\n          child1.parent = parent_1;\n          child2.parent = parent_1;\n          nodes[jMin] = nodes[count - 1];\n          nodes[iMin] = parent_1;\n          --count;\n        }\n        this.m_root = nodes[0];\n      };\n      DynamicTree2.prototype.shiftOrigin = function(newOrigin) {\n        var node;\n        var it = this.iteratorPool.allocate().preorder(this.m_root);\n        while (node = it.next()) {\n          var aabb = node.aabb;\n          aabb.lowerBound.x -= newOrigin.x;\n          aabb.lowerBound.y -= newOrigin.y;\n          aabb.upperBound.x -= newOrigin.x;\n          aabb.upperBound.y -= newOrigin.y;\n        }\n        this.iteratorPool.release(it);\n      };\n      DynamicTree2.prototype.query = function(aabb, queryCallback) {\n        var stack = this.stackPool.allocate();\n        stack.push(this.m_root);\n        while (stack.length > 0) {\n          var node = stack.pop();\n          if (node == null) {\n            continue;\n          }\n          if (AABB.testOverlap(node.aabb, aabb)) {\n            if (node.isLeaf()) {\n              var proceed = queryCallback(node.id);\n              if (proceed === false) {\n                return;\n              }\n            } else {\n              stack.push(node.child1);\n              stack.push(node.child2);\n            }\n          }\n        }\n        this.stackPool.release(stack);\n      };\n      DynamicTree2.prototype.rayCast = function(input2, rayCastCallback) {\n        var p1 = input2.p1;\n        var p2 = input2.p2;\n        var r = Vec2.sub(p2, p1);\n        r.normalize();\n        var v3 = Vec2.crossNumVec2(1, r);\n        var abs_v = Vec2.abs(v3);\n        var maxFraction = input2.maxFraction;\n        var segmentAABB = new AABB();\n        var t = Vec2.combine(1 - maxFraction, p1, maxFraction, p2);\n        segmentAABB.combinePoints(p1, t);\n        var stack = this.stackPool.allocate();\n        var subInput = this.inputPool.allocate();\n        stack.push(this.m_root);\n        while (stack.length > 0) {\n          var node = stack.pop();\n          if (node == null) {\n            continue;\n          }\n          if (AABB.testOverlap(node.aabb, segmentAABB) === false) {\n            continue;\n          }\n          var c2 = node.aabb.getCenter();\n          var h = node.aabb.getExtents();\n          var separation = math_abs$8(Vec2.dot(v3, Vec2.sub(p1, c2))) - Vec2.dot(abs_v, h);\n          if (separation > 0) {\n            continue;\n          }\n          if (node.isLeaf()) {\n            subInput.p1 = Vec2.clone(input2.p1);\n            subInput.p2 = Vec2.clone(input2.p2);\n            subInput.maxFraction = maxFraction;\n            var value = rayCastCallback(subInput, node.id);\n            if (value === 0) {\n              break;\n            } else if (value > 0) {\n              maxFraction = value;\n              t = Vec2.combine(1 - maxFraction, p1, maxFraction, p2);\n              segmentAABB.combinePoints(p1, t);\n            }\n          } else {\n            stack.push(node.child1);\n            stack.push(node.child2);\n          }\n        }\n        this.stackPool.release(stack);\n        this.inputPool.release(subInput);\n      };\n      return DynamicTree2;\n    }()\n  );\n  var Iterator = (\n    /** @class */\n    function() {\n      function Iterator2() {\n        this.parents = [];\n        this.states = [];\n      }\n      Iterator2.prototype.preorder = function(root) {\n        this.parents.length = 0;\n        this.parents.push(root);\n        this.states.length = 0;\n        this.states.push(0);\n        return this;\n      };\n      Iterator2.prototype.next = function() {\n        while (this.parents.length > 0) {\n          var i = this.parents.length - 1;\n          var node = this.parents[i];\n          if (this.states[i] === 0) {\n            this.states[i] = 1;\n            return node;\n          }\n          if (this.states[i] === 1) {\n            this.states[i] = 2;\n            if (node.child1) {\n              this.parents.push(node.child1);\n              this.states.push(1);\n              return node.child1;\n            }\n          }\n          if (this.states[i] === 2) {\n            this.states[i] = 3;\n            if (node.child2) {\n              this.parents.push(node.child2);\n              this.states.push(1);\n              return node.child2;\n            }\n          }\n          this.parents.pop();\n          this.states.pop();\n        }\n      };\n      Iterator2.prototype.close = function() {\n        this.parents.length = 0;\n      };\n      return Iterator2;\n    }()\n  );\n  var math_max$5 = Math.max;\n  var math_min$6 = Math.min;\n  var BroadPhase = (\n    /** @class */\n    function() {\n      function BroadPhase2() {\n        var _this = this;\n        this.m_tree = new DynamicTree();\n        this.m_moveBuffer = [];\n        this.query = function(aabb, queryCallback) {\n          _this.m_tree.query(aabb, queryCallback);\n        };\n        this.queryCallback = function(proxyId) {\n          if (proxyId === _this.m_queryProxyId) {\n            return true;\n          }\n          var proxyIdA = math_min$6(proxyId, _this.m_queryProxyId);\n          var proxyIdB = math_max$5(proxyId, _this.m_queryProxyId);\n          var userDataA = _this.m_tree.getUserData(proxyIdA);\n          var userDataB = _this.m_tree.getUserData(proxyIdB);\n          _this.m_callback(userDataA, userDataB);\n          return true;\n        };\n      }\n      BroadPhase2.prototype.getUserData = function(proxyId) {\n        return this.m_tree.getUserData(proxyId);\n      };\n      BroadPhase2.prototype.testOverlap = function(proxyIdA, proxyIdB) {\n        var aabbA = this.m_tree.getFatAABB(proxyIdA);\n        var aabbB = this.m_tree.getFatAABB(proxyIdB);\n        return AABB.testOverlap(aabbA, aabbB);\n      };\n      BroadPhase2.prototype.getFatAABB = function(proxyId) {\n        return this.m_tree.getFatAABB(proxyId);\n      };\n      BroadPhase2.prototype.getProxyCount = function() {\n        return this.m_moveBuffer.length;\n      };\n      BroadPhase2.prototype.getTreeHeight = function() {\n        return this.m_tree.getHeight();\n      };\n      BroadPhase2.prototype.getTreeBalance = function() {\n        return this.m_tree.getMaxBalance();\n      };\n      BroadPhase2.prototype.getTreeQuality = function() {\n        return this.m_tree.getAreaRatio();\n      };\n      BroadPhase2.prototype.rayCast = function(input2, rayCastCallback) {\n        this.m_tree.rayCast(input2, rayCastCallback);\n      };\n      BroadPhase2.prototype.shiftOrigin = function(newOrigin) {\n        this.m_tree.shiftOrigin(newOrigin);\n      };\n      BroadPhase2.prototype.createProxy = function(aabb, userData) {\n        var proxyId = this.m_tree.createProxy(aabb, userData);\n        this.bufferMove(proxyId);\n        return proxyId;\n      };\n      BroadPhase2.prototype.destroyProxy = function(proxyId) {\n        this.unbufferMove(proxyId);\n        this.m_tree.destroyProxy(proxyId);\n      };\n      BroadPhase2.prototype.moveProxy = function(proxyId, aabb, displacement2) {\n        var changed = this.m_tree.moveProxy(proxyId, aabb, displacement2);\n        if (changed) {\n          this.bufferMove(proxyId);\n        }\n      };\n      BroadPhase2.prototype.touchProxy = function(proxyId) {\n        this.bufferMove(proxyId);\n      };\n      BroadPhase2.prototype.bufferMove = function(proxyId) {\n        this.m_moveBuffer.push(proxyId);\n      };\n      BroadPhase2.prototype.unbufferMove = function(proxyId) {\n        for (var i = 0; i < this.m_moveBuffer.length; ++i) {\n          if (this.m_moveBuffer[i] === proxyId) {\n            this.m_moveBuffer[i] = null;\n          }\n        }\n      };\n      BroadPhase2.prototype.updatePairs = function(addPairCallback) {\n        this.m_callback = addPairCallback;\n        while (this.m_moveBuffer.length > 0) {\n          this.m_queryProxyId = this.m_moveBuffer.pop();\n          if (this.m_queryProxyId === null) {\n            continue;\n          }\n          var fatAABB = this.m_tree.getFatAABB(this.m_queryProxyId);\n          this.m_tree.query(fatAABB, this.queryCallback);\n        }\n      };\n      return BroadPhase2;\n    }()\n  );\n  var math_sin$2 = Math.sin;\n  var math_cos$2 = Math.cos;\n  var math_sqrt$4 = Math.sqrt;\n  function vec2(x2, y) {\n    return { x: x2, y };\n  }\n  function rotation(angle) {\n    return { s: math_sin$2(angle), c: math_cos$2(angle) };\n  }\n  function setVec2(out, x2, y) {\n    out.x = x2;\n    out.y = y;\n    return out;\n  }\n  function copyVec2(out, w) {\n    out.x = w.x;\n    out.y = w.y;\n    return out;\n  }\n  function zeroVec2(out) {\n    out.x = 0;\n    out.y = 0;\n    return out;\n  }\n  function negVec2(out) {\n    out.x = -out.x;\n    out.y = -out.y;\n    return out;\n  }\n  function plusVec2(out, w) {\n    out.x += w.x;\n    out.y += w.y;\n    return out;\n  }\n  function addVec2(out, v3, w) {\n    out.x = v3.x + w.x;\n    out.y = v3.x + w.y;\n    return out;\n  }\n  function minusVec2(out, w) {\n    out.x -= w.x;\n    out.y -= w.y;\n    return out;\n  }\n  function subVec2(out, v3, w) {\n    out.x = v3.x - w.x;\n    out.y = v3.y - w.y;\n    return out;\n  }\n  function mulVec2(out, m) {\n    out.x *= m;\n    out.y *= m;\n    return out;\n  }\n  function scaleVec2(out, m, w) {\n    out.x = m * w.x;\n    out.y = m * w.y;\n    return out;\n  }\n  function plusScaleVec2(out, m, w) {\n    out.x += m * w.x;\n    out.y += m * w.y;\n    return out;\n  }\n  function minusScaleVec2(out, m, w) {\n    out.x -= m * w.x;\n    out.y -= m * w.y;\n    return out;\n  }\n  function combine2Vec2(out, am, a2, bm, b2) {\n    out.x = am * a2.x + bm * b2.x;\n    out.y = am * a2.y + bm * b2.y;\n    return out;\n  }\n  function combine3Vec2(out, am, a2, bm, b2, cm, c2) {\n    out.x = am * a2.x + bm * b2.x + cm * c2.x;\n    out.y = am * a2.y + bm * b2.y + cm * c2.y;\n    return out;\n  }\n  function normalizeVec2Length(out) {\n    var length = math_sqrt$4(out.x * out.x + out.y * out.y);\n    if (length !== 0) {\n      var invLength = 1 / length;\n      out.x *= invLength;\n      out.y *= invLength;\n    }\n    return length;\n  }\n  function normalizeVec2(out) {\n    var length = math_sqrt$4(out.x * out.x + out.y * out.y);\n    if (length > 0) {\n      var invLength = 1 / length;\n      out.x *= invLength;\n      out.y *= invLength;\n    }\n    return out;\n  }\n  function crossVec2Num(out, v3, w) {\n    var x2 = w * v3.y;\n    var y = -w * v3.x;\n    out.x = x2;\n    out.y = y;\n    return out;\n  }\n  function crossNumVec2(out, w, v3) {\n    var x2 = -w * v3.y;\n    var y = w * v3.x;\n    out.x = x2;\n    out.y = y;\n    return out;\n  }\n  function crossVec2Vec2(a2, b2) {\n    return a2.x * b2.y - a2.y * b2.x;\n  }\n  function dotVec2(a2, b2) {\n    return a2.x * b2.x + a2.y * b2.y;\n  }\n  function lengthSqrVec2(a2) {\n    return a2.x * a2.x + a2.y * a2.y;\n  }\n  function distVec2(a2, b2) {\n    var dx = a2.x - b2.x;\n    var dy = a2.y - b2.y;\n    return math_sqrt$4(dx * dx + dy * dy);\n  }\n  function distSqrVec2(a2, b2) {\n    var dx = a2.x - b2.x;\n    var dy = a2.y - b2.y;\n    return dx * dx + dy * dy;\n  }\n  function setRotAngle(out, a2) {\n    out.c = math_cos$2(a2);\n    out.s = math_sin$2(a2);\n    return out;\n  }\n  function rotVec2(out, q, v3) {\n    out.x = q.c * v3.x - q.s * v3.y;\n    out.y = q.s * v3.x + q.c * v3.y;\n    return out;\n  }\n  function derotVec2(out, q, v3) {\n    var x2 = q.c * v3.x + q.s * v3.y;\n    var y = -q.s * v3.x + q.c * v3.y;\n    out.x = x2;\n    out.y = y;\n    return out;\n  }\n  function rerotVec2(out, before, after, v3) {\n    var x0 = before.c * v3.x + before.s * v3.y;\n    var y0 = -before.s * v3.x + before.c * v3.y;\n    var x2 = after.c * x0 - after.s * y0;\n    var y = after.s * x0 + after.c * y0;\n    out.x = x2;\n    out.y = y;\n    return out;\n  }\n  function transform(x2, y, a2) {\n    return { p: vec2(x2, y), q: rotation(a2) };\n  }\n  function copyTransform(out, transform2) {\n    out.p.x = transform2.p.x;\n    out.p.y = transform2.p.y;\n    out.q.s = transform2.q.s;\n    out.q.c = transform2.q.c;\n    return out;\n  }\n  function transformVec2(out, xf2, v3) {\n    var x2 = xf2.q.c * v3.x - xf2.q.s * v3.y + xf2.p.x;\n    var y = xf2.q.s * v3.x + xf2.q.c * v3.y + xf2.p.y;\n    out.x = x2;\n    out.y = y;\n    return out;\n  }\n  function detransformVec2(out, xf2, v3) {\n    var px = v3.x - xf2.p.x;\n    var py = v3.y - xf2.p.y;\n    var x2 = xf2.q.c * px + xf2.q.s * py;\n    var y = -xf2.q.s * px + xf2.q.c * py;\n    out.x = x2;\n    out.y = y;\n    return out;\n  }\n  function retransformVec2(out, from, to, v3) {\n    var x0 = from.q.c * v3.x - from.q.s * v3.y + from.p.x;\n    var y0 = from.q.s * v3.x + from.q.c * v3.y + from.p.y;\n    var px = x0 - to.p.x;\n    var py = y0 - to.p.y;\n    var x2 = to.q.c * px + to.q.s * py;\n    var y = -to.q.s * px + to.q.c * py;\n    out.x = x2;\n    out.y = y;\n    return out;\n  }\n  function detransformTransform(out, a2, b2) {\n    var c2 = a2.q.c * b2.q.c + a2.q.s * b2.q.s;\n    var s2 = a2.q.c * b2.q.s - a2.q.s * b2.q.c;\n    var x2 = a2.q.c * (b2.p.x - a2.p.x) + a2.q.s * (b2.p.y - a2.p.y);\n    var y = -a2.q.s * (b2.p.x - a2.p.x) + a2.q.c * (b2.p.y - a2.p.y);\n    out.q.c = c2;\n    out.q.s = s2;\n    out.p.x = x2;\n    out.p.y = y;\n    return out;\n  }\n  var math_sin$1 = Math.sin;\n  var math_cos$1 = Math.cos;\n  var math_atan2$1 = Math.atan2;\n  var Rot = (\n    /** @class */\n    function() {\n      function Rot2(angle) {\n        if (!(this instanceof Rot2)) {\n          return new Rot2(angle);\n        }\n        if (typeof angle === \"number\") {\n          this.setAngle(angle);\n        } else if (typeof angle === \"object\") {\n          this.setRot(angle);\n        } else {\n          this.setIdentity();\n        }\n      }\n      Rot2.neo = function(angle) {\n        var obj = Object.create(Rot2.prototype);\n        obj.setAngle(angle);\n        return obj;\n      };\n      Rot2.clone = function(rot) {\n        var obj = Object.create(Rot2.prototype);\n        obj.s = rot.s;\n        obj.c = rot.c;\n        return obj;\n      };\n      Rot2.identity = function() {\n        var obj = Object.create(Rot2.prototype);\n        obj.s = 0;\n        obj.c = 1;\n        return obj;\n      };\n      Rot2.isValid = function(obj) {\n        if (obj === null || typeof obj === \"undefined\") {\n          return false;\n        }\n        return Number.isFinite(obj.s) && Number.isFinite(obj.c);\n      };\n      Rot2.assert = function(o) {\n      };\n      Rot2.prototype.setIdentity = function() {\n        this.s = 0;\n        this.c = 1;\n      };\n      Rot2.prototype.set = function(angle) {\n        if (typeof angle === \"object\") {\n          this.s = angle.s;\n          this.c = angle.c;\n        } else {\n          this.s = math_sin$1(angle);\n          this.c = math_cos$1(angle);\n        }\n      };\n      Rot2.prototype.setRot = function(angle) {\n        this.s = angle.s;\n        this.c = angle.c;\n      };\n      Rot2.prototype.setAngle = function(angle) {\n        this.s = math_sin$1(angle);\n        this.c = math_cos$1(angle);\n      };\n      Rot2.prototype.getAngle = function() {\n        return math_atan2$1(this.s, this.c);\n      };\n      Rot2.prototype.getXAxis = function() {\n        return Vec2.neo(this.c, this.s);\n      };\n      Rot2.prototype.getYAxis = function() {\n        return Vec2.neo(-this.s, this.c);\n      };\n      Rot2.mul = function(rot, m) {\n        if (\"c\" in m && \"s\" in m) {\n          var qr = Rot2.identity();\n          qr.s = rot.s * m.c + rot.c * m.s;\n          qr.c = rot.c * m.c - rot.s * m.s;\n          return qr;\n        } else if (\"x\" in m && \"y\" in m) {\n          return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);\n        }\n      };\n      Rot2.mulRot = function(rot, m) {\n        var qr = Rot2.identity();\n        qr.s = rot.s * m.c + rot.c * m.s;\n        qr.c = rot.c * m.c - rot.s * m.s;\n        return qr;\n      };\n      Rot2.mulVec2 = function(rot, m) {\n        return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);\n      };\n      Rot2.mulSub = function(rot, v3, w) {\n        var x2 = rot.c * (v3.x - w.x) - rot.s * (v3.y - w.y);\n        var y = rot.s * (v3.x - w.x) + rot.c * (v3.y - w.y);\n        return Vec2.neo(x2, y);\n      };\n      Rot2.mulT = function(rot, m) {\n        if (\"c\" in m && \"s\" in m) {\n          var qr = Rot2.identity();\n          qr.s = rot.c * m.s - rot.s * m.c;\n          qr.c = rot.c * m.c + rot.s * m.s;\n          return qr;\n        } else if (\"x\" in m && \"y\" in m) {\n          return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);\n        }\n      };\n      Rot2.mulTRot = function(rot, m) {\n        var qr = Rot2.identity();\n        qr.s = rot.c * m.s - rot.s * m.c;\n        qr.c = rot.c * m.c + rot.s * m.s;\n        return qr;\n      };\n      Rot2.mulTVec2 = function(rot, m) {\n        return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);\n      };\n      return Rot2;\n    }()\n  );\n  var math_atan2 = Math.atan2;\n  var math_PI$5 = Math.PI;\n  var temp$7 = vec2(0, 0);\n  var Sweep = (\n    /** @class */\n    function() {\n      function Sweep2() {\n        this.localCenter = Vec2.zero();\n        this.c = Vec2.zero();\n        this.a = 0;\n        this.alpha0 = 0;\n        this.c0 = Vec2.zero();\n        this.a0 = 0;\n      }\n      Sweep2.prototype.recycle = function() {\n        zeroVec2(this.localCenter);\n        zeroVec2(this.c);\n        this.a = 0;\n        this.alpha0 = 0;\n        zeroVec2(this.c0);\n        this.a0 = 0;\n      };\n      Sweep2.prototype.setTransform = function(xf2) {\n        transformVec2(temp$7, xf2, this.localCenter);\n        copyVec2(this.c, temp$7);\n        copyVec2(this.c0, temp$7);\n        this.a = this.a0 = math_atan2(xf2.q.s, xf2.q.c);\n      };\n      Sweep2.prototype.setLocalCenter = function(localCenter2, xf2) {\n        copyVec2(this.localCenter, localCenter2);\n        transformVec2(temp$7, xf2, this.localCenter);\n        copyVec2(this.c, temp$7);\n        copyVec2(this.c0, temp$7);\n      };\n      Sweep2.prototype.getTransform = function(xf2, beta) {\n        if (beta === void 0) {\n          beta = 0;\n        }\n        setRotAngle(xf2.q, (1 - beta) * this.a0 + beta * this.a);\n        combine2Vec2(xf2.p, 1 - beta, this.c0, beta, this.c);\n        minusVec2(xf2.p, rotVec2(temp$7, xf2.q, this.localCenter));\n      };\n      Sweep2.prototype.advance = function(alpha) {\n        var beta = (alpha - this.alpha0) / (1 - this.alpha0);\n        combine2Vec2(this.c0, beta, this.c, 1 - beta, this.c0);\n        this.a0 = beta * this.a + (1 - beta) * this.a0;\n        this.alpha0 = alpha;\n      };\n      Sweep2.prototype.forward = function() {\n        this.a0 = this.a;\n        copyVec2(this.c0, this.c);\n      };\n      Sweep2.prototype.normalize = function() {\n        var a0 = mod(this.a0, -math_PI$5, +math_PI$5);\n        this.a -= this.a0 - a0;\n        this.a0 = a0;\n      };\n      Sweep2.prototype.set = function(that) {\n        copyVec2(this.localCenter, that.localCenter);\n        copyVec2(this.c, that.c);\n        this.a = that.a;\n        this.alpha0 = that.alpha0;\n        copyVec2(this.c0, that.c0);\n        this.a0 = that.a0;\n      };\n      return Sweep2;\n    }()\n  );\n  var Transform = (\n    /** @class */\n    function() {\n      function Transform2(position, rotation2) {\n        if (!(this instanceof Transform2)) {\n          return new Transform2(position, rotation2);\n        }\n        this.p = Vec2.zero();\n        this.q = Rot.identity();\n        if (typeof position !== \"undefined\") {\n          this.p.setVec2(position);\n        }\n        if (typeof rotation2 !== \"undefined\") {\n          this.q.setAngle(rotation2);\n        }\n      }\n      Transform2.clone = function(xf2) {\n        var obj = Object.create(Transform2.prototype);\n        obj.p = Vec2.clone(xf2.p);\n        obj.q = Rot.clone(xf2.q);\n        return obj;\n      };\n      Transform2.neo = function(position, rotation2) {\n        var obj = Object.create(Transform2.prototype);\n        obj.p = Vec2.clone(position);\n        obj.q = Rot.clone(rotation2);\n        return obj;\n      };\n      Transform2.identity = function() {\n        var obj = Object.create(Transform2.prototype);\n        obj.p = Vec2.zero();\n        obj.q = Rot.identity();\n        return obj;\n      };\n      Transform2.prototype.setIdentity = function() {\n        this.p.setZero();\n        this.q.setIdentity();\n      };\n      Transform2.prototype.set = function(a2, b2) {\n        if (typeof b2 === \"undefined\") {\n          this.p.set(a2.p);\n          this.q.set(a2.q);\n        } else {\n          this.p.set(a2);\n          this.q.set(b2);\n        }\n      };\n      Transform2.prototype.setNum = function(position, rotation2) {\n        this.p.setVec2(position);\n        this.q.setAngle(rotation2);\n      };\n      Transform2.prototype.setTransform = function(xf2) {\n        this.p.setVec2(xf2.p);\n        this.q.setRot(xf2.q);\n      };\n      Transform2.isValid = function(obj) {\n        if (obj === null || typeof obj === \"undefined\") {\n          return false;\n        }\n        return Vec2.isValid(obj.p) && Rot.isValid(obj.q);\n      };\n      Transform2.assert = function(o) {\n      };\n      Transform2.mul = function(a2, b2) {\n        if (Array.isArray(b2)) {\n          var arr = [];\n          for (var i = 0; i < b2.length; i++) {\n            arr[i] = Transform2.mul(a2, b2[i]);\n          }\n          return arr;\n        } else if (\"x\" in b2 && \"y\" in b2) {\n          return Transform2.mulVec2(a2, b2);\n        } else if (\"p\" in b2 && \"q\" in b2) {\n          return Transform2.mulXf(a2, b2);\n        }\n      };\n      Transform2.mulAll = function(a2, b2) {\n        var arr = [];\n        for (var i = 0; i < b2.length; i++) {\n          arr[i] = Transform2.mul(a2, b2[i]);\n        }\n        return arr;\n      };\n      Transform2.mulFn = function(a2) {\n        return function(b2) {\n          return Transform2.mul(a2, b2);\n        };\n      };\n      Transform2.mulVec2 = function(a2, b2) {\n        var x2 = a2.q.c * b2.x - a2.q.s * b2.y + a2.p.x;\n        var y = a2.q.s * b2.x + a2.q.c * b2.y + a2.p.y;\n        return Vec2.neo(x2, y);\n      };\n      Transform2.mulXf = function(a2, b2) {\n        var xf2 = Transform2.identity();\n        xf2.q = Rot.mulRot(a2.q, b2.q);\n        xf2.p = Vec2.add(Rot.mulVec2(a2.q, b2.p), a2.p);\n        return xf2;\n      };\n      Transform2.mulT = function(a2, b2) {\n        if (\"x\" in b2 && \"y\" in b2) {\n          return Transform2.mulTVec2(a2, b2);\n        } else if (\"p\" in b2 && \"q\" in b2) {\n          return Transform2.mulTXf(a2, b2);\n        }\n      };\n      Transform2.mulTVec2 = function(a2, b2) {\n        var px = b2.x - a2.p.x;\n        var py = b2.y - a2.p.y;\n        var x2 = a2.q.c * px + a2.q.s * py;\n        var y = -a2.q.s * px + a2.q.c * py;\n        return Vec2.neo(x2, y);\n      };\n      Transform2.mulTXf = function(a2, b2) {\n        var xf2 = Transform2.identity();\n        xf2.q.setRot(Rot.mulTRot(a2.q, b2.q));\n        xf2.p.setVec2(Rot.mulTVec2(a2.q, Vec2.sub(b2.p, a2.p)));\n        return xf2;\n      };\n      return Transform2;\n    }()\n  );\n  var Velocity = (\n    /** @class */\n    /* @__PURE__ */ function() {\n      function Velocity2() {\n        this.v = Vec2.zero();\n        this.w = 0;\n      }\n      return Velocity2;\n    }()\n  );\n  var math_sin = Math.sin;\n  var math_cos = Math.cos;\n  var Position = (\n    /** @class */\n    function() {\n      function Position2() {\n        this.c = Vec2.zero();\n        this.a = 0;\n      }\n      Position2.prototype.getTransform = function(xf2, p) {\n        xf2.q.c = math_cos(this.a);\n        xf2.q.s = math_sin(this.a);\n        xf2.p.x = this.c.x - (xf2.q.c * p.x - xf2.q.s * p.y);\n        xf2.p.y = this.c.y - (xf2.q.s * p.x + xf2.q.c * p.y);\n        return xf2;\n      };\n      return Position2;\n    }()\n  );\n  function getTransform(xf2, p, c2, a2) {\n    xf2.q.c = math_cos(a2);\n    xf2.q.s = math_sin(a2);\n    xf2.p.x = c2.x - (xf2.q.c * p.x - xf2.q.s * p.y);\n    xf2.p.y = c2.y - (xf2.q.s * p.x + xf2.q.c * p.y);\n    return xf2;\n  }\n  var Shape = (\n    /** @class */\n    function() {\n      function Shape2() {\n        this.style = {};\n        this.appData = {};\n      }\n      Shape2.isValid = function(obj) {\n        if (obj === null || typeof obj === \"undefined\") {\n          return false;\n        }\n        return typeof obj.m_type === \"string\" && typeof obj.m_radius === \"number\";\n      };\n      return Shape2;\n    }()\n  );\n  var synchronize_aabb1 = new AABB();\n  var synchronize_aabb2 = new AABB();\n  var displacement = vec2(0, 0);\n  var FixtureDefDefault = {\n    userData: null,\n    friction: 0.2,\n    restitution: 0,\n    density: 0,\n    isSensor: false,\n    filterGroupIndex: 0,\n    filterCategoryBits: 1,\n    filterMaskBits: 65535\n  };\n  var FixtureProxy = (\n    /** @class */\n    /* @__PURE__ */ function() {\n      function FixtureProxy2(fixture, childIndex) {\n        this.aabb = new AABB();\n        this.fixture = fixture;\n        this.childIndex = childIndex;\n      }\n      return FixtureProxy2;\n    }()\n  );\n  var Fixture = (\n    /** @class */\n    function() {\n      function Fixture2(body, shape, def) {\n        this.style = {};\n        this.appData = {};\n        if (shape.shape) {\n          def = shape;\n          shape = shape.shape;\n        } else if (typeof def === \"number\") {\n          def = { density: def };\n        }\n        def = options(def, FixtureDefDefault);\n        this.m_body = body;\n        this.m_friction = def.friction;\n        this.m_restitution = def.restitution;\n        this.m_density = def.density;\n        this.m_isSensor = def.isSensor;\n        this.m_filterGroupIndex = def.filterGroupIndex;\n        this.m_filterCategoryBits = def.filterCategoryBits;\n        this.m_filterMaskBits = def.filterMaskBits;\n        this.m_shape = shape;\n        this.m_next = null;\n        this.m_proxies = [];\n        this.m_proxyCount = 0;\n        var childCount = this.m_shape.getChildCount();\n        for (var i = 0; i < childCount; ++i) {\n          this.m_proxies[i] = new FixtureProxy(this, i);\n        }\n        this.m_userData = def.userData;\n        if (typeof def.style === \"object\" && def.style !== null) {\n          this.style = def.style;\n        }\n      }\n      Fixture2.prototype._reset = function() {\n        var body = this.getBody();\n        var broadPhase = body.m_world.m_broadPhase;\n        this.destroyProxies(broadPhase);\n        if (this.m_shape._reset) {\n          this.m_shape._reset();\n        }\n        var childCount = this.m_shape.getChildCount();\n        for (var i = 0; i < childCount; ++i) {\n          this.m_proxies[i] = new FixtureProxy(this, i);\n        }\n        this.createProxies(broadPhase, body.m_xf);\n        body.resetMassData();\n      };\n      Fixture2.prototype._serialize = function() {\n        return {\n          friction: this.m_friction,\n          restitution: this.m_restitution,\n          density: this.m_density,\n          isSensor: this.m_isSensor,\n          filterGroupIndex: this.m_filterGroupIndex,\n          filterCategoryBits: this.m_filterCategoryBits,\n          filterMaskBits: this.m_filterMaskBits,\n          shape: this.m_shape\n        };\n      };\n      Fixture2._deserialize = function(data, body, restore) {\n        var shape = restore(Shape, data.shape);\n        var fixture = shape && new Fixture2(body, shape, data);\n        return fixture;\n      };\n      Fixture2.prototype.getType = function() {\n        return this.m_shape.m_type;\n      };\n      Fixture2.prototype.getShape = function() {\n        return this.m_shape;\n      };\n      Fixture2.prototype.isSensor = function() {\n        return this.m_isSensor;\n      };\n      Fixture2.prototype.setSensor = function(sensor) {\n        if (sensor != this.m_isSensor) {\n          this.m_body.setAwake(true);\n          this.m_isSensor = sensor;\n        }\n      };\n      Fixture2.prototype.getUserData = function() {\n        return this.m_userData;\n      };\n      Fixture2.prototype.setUserData = function(data) {\n        this.m_userData = data;\n      };\n      Fixture2.prototype.getBody = function() {\n        return this.m_body;\n      };\n      Fixture2.prototype.getNext = function() {\n        return this.m_next;\n      };\n      Fixture2.prototype.getDensity = function() {\n        return this.m_density;\n      };\n      Fixture2.prototype.setDensity = function(density) {\n        this.m_density = density;\n      };\n      Fixture2.prototype.getFriction = function() {\n        return this.m_friction;\n      };\n      Fixture2.prototype.setFriction = function(friction) {\n        this.m_friction = friction;\n      };\n      Fixture2.prototype.getRestitution = function() {\n        return this.m_restitution;\n      };\n      Fixture2.prototype.setRestitution = function(restitution) {\n        this.m_restitution = restitution;\n      };\n      Fixture2.prototype.testPoint = function(p) {\n        return this.m_shape.testPoint(this.m_body.getTransform(), p);\n      };\n      Fixture2.prototype.rayCast = function(output2, input2, childIndex) {\n        return this.m_shape.rayCast(output2, input2, this.m_body.getTransform(), childIndex);\n      };\n      Fixture2.prototype.getMassData = function(massData) {\n        this.m_shape.computeMass(massData, this.m_density);\n      };\n      Fixture2.prototype.getAABB = function(childIndex) {\n        return this.m_proxies[childIndex].aabb;\n      };\n      Fixture2.prototype.createProxies = function(broadPhase, xf2) {\n        this.m_proxyCount = this.m_shape.getChildCount();\n        for (var i = 0; i < this.m_proxyCount; ++i) {\n          var proxy = this.m_proxies[i];\n          this.m_shape.computeAABB(proxy.aabb, xf2, i);\n          proxy.proxyId = broadPhase.createProxy(proxy.aabb, proxy);\n        }\n      };\n      Fixture2.prototype.destroyProxies = function(broadPhase) {\n        for (var i = 0; i < this.m_proxyCount; ++i) {\n          var proxy = this.m_proxies[i];\n          broadPhase.destroyProxy(proxy.proxyId);\n          proxy.proxyId = null;\n        }\n        this.m_proxyCount = 0;\n      };\n      Fixture2.prototype.synchronize = function(broadPhase, xf1, xf2) {\n        for (var i = 0; i < this.m_proxyCount; ++i) {\n          var proxy = this.m_proxies[i];\n          this.m_shape.computeAABB(synchronize_aabb1, xf1, proxy.childIndex);\n          this.m_shape.computeAABB(synchronize_aabb2, xf2, proxy.childIndex);\n          proxy.aabb.combine(synchronize_aabb1, synchronize_aabb2);\n          subVec2(displacement, xf2.p, xf1.p);\n          broadPhase.moveProxy(proxy.proxyId, proxy.aabb, displacement);\n        }\n      };\n      Fixture2.prototype.setFilterData = function(filter) {\n        this.m_filterGroupIndex = filter.groupIndex;\n        this.m_filterCategoryBits = filter.categoryBits;\n        this.m_filterMaskBits = filter.maskBits;\n        this.refilter();\n      };\n      Fixture2.prototype.getFilterGroupIndex = function() {\n        return this.m_filterGroupIndex;\n      };\n      Fixture2.prototype.setFilterGroupIndex = function(groupIndex) {\n        this.m_filterGroupIndex = groupIndex;\n        this.refilter();\n      };\n      Fixture2.prototype.getFilterCategoryBits = function() {\n        return this.m_filterCategoryBits;\n      };\n      Fixture2.prototype.setFilterCategoryBits = function(categoryBits) {\n        this.m_filterCategoryBits = categoryBits;\n        this.refilter();\n      };\n      Fixture2.prototype.getFilterMaskBits = function() {\n        return this.m_filterMaskBits;\n      };\n      Fixture2.prototype.setFilterMaskBits = function(maskBits) {\n        this.m_filterMaskBits = maskBits;\n        this.refilter();\n      };\n      Fixture2.prototype.refilter = function() {\n        if (this.m_body == null) {\n          return;\n        }\n        var edge = this.m_body.getContactList();\n        while (edge) {\n          var contact = edge.contact;\n          var fixtureA = contact.getFixtureA();\n          var fixtureB = contact.getFixtureB();\n          if (fixtureA == this || fixtureB == this) {\n            contact.flagForFiltering();\n          }\n          edge = edge.next;\n        }\n        var world = this.m_body.getWorld();\n        if (world == null) {\n          return;\n        }\n        var broadPhase = world.m_broadPhase;\n        for (var i = 0; i < this.m_proxyCount; ++i) {\n          broadPhase.touchProxy(this.m_proxies[i].proxyId);\n        }\n      };\n      Fixture2.prototype.shouldCollide = function(that) {\n        if (that.m_filterGroupIndex === this.m_filterGroupIndex && that.m_filterGroupIndex !== 0) {\n          return that.m_filterGroupIndex > 0;\n        }\n        var collideA = (that.m_filterMaskBits & this.m_filterCategoryBits) !== 0;\n        var collideB = (that.m_filterCategoryBits & this.m_filterMaskBits) !== 0;\n        var collide = collideA && collideB;\n        return collide;\n      };\n      return Fixture2;\n    }()\n  );\n  var STATIC = \"static\";\n  var KINEMATIC = \"kinematic\";\n  var DYNAMIC = \"dynamic\";\n  var oldCenter = vec2(0, 0);\n  var localCenter = vec2(0, 0);\n  var shift = vec2(0, 0);\n  var temp$6 = vec2(0, 0);\n  var xf$2 = transform(0, 0, 0);\n  var BodyDefDefault = {\n    type: STATIC,\n    position: Vec2.zero(),\n    angle: 0,\n    linearVelocity: Vec2.zero(),\n    angularVelocity: 0,\n    linearDamping: 0,\n    angularDamping: 0,\n    fixedRotation: false,\n    bullet: false,\n    gravityScale: 1,\n    allowSleep: true,\n    awake: true,\n    active: true,\n    userData: null\n  };\n  var Body = (\n    /** @class */\n    function() {\n      function Body2(world, def) {\n        this.style = {};\n        this.appData = {};\n        def = options(def, BodyDefDefault);\n        this.m_world = world;\n        this.m_awakeFlag = def.awake;\n        this.m_autoSleepFlag = def.allowSleep;\n        this.m_bulletFlag = def.bullet;\n        this.m_fixedRotationFlag = def.fixedRotation;\n        this.m_activeFlag = def.active;\n        this.m_islandFlag = false;\n        this.m_toiFlag = false;\n        this.m_userData = def.userData;\n        this.m_type = def.type;\n        if (this.m_type == DYNAMIC) {\n          this.m_mass = 1;\n          this.m_invMass = 1;\n        } else {\n          this.m_mass = 0;\n          this.m_invMass = 0;\n        }\n        this.m_I = 0;\n        this.m_invI = 0;\n        this.m_xf = Transform.identity();\n        this.m_xf.p.setVec2(def.position);\n        this.m_xf.q.setAngle(def.angle);\n        this.m_sweep = new Sweep();\n        this.m_sweep.setTransform(this.m_xf);\n        this.c_velocity = new Velocity();\n        this.c_position = new Position();\n        this.m_force = Vec2.zero();\n        this.m_torque = 0;\n        this.m_linearVelocity = Vec2.clone(def.linearVelocity);\n        this.m_angularVelocity = def.angularVelocity;\n        this.m_linearDamping = def.linearDamping;\n        this.m_angularDamping = def.angularDamping;\n        this.m_gravityScale = def.gravityScale;\n        this.m_sleepTime = 0;\n        this.m_jointList = null;\n        this.m_contactList = null;\n        this.m_fixtureList = null;\n        this.m_prev = null;\n        this.m_next = null;\n        this.m_destroyed = false;\n        if (typeof def.style === \"object\" && def.style !== null) {\n          this.style = def.style;\n        }\n      }\n      Body2.prototype._serialize = function() {\n        var fixtures = [];\n        for (var f = this.m_fixtureList; f; f = f.m_next) {\n          fixtures.push(f);\n        }\n        return {\n          type: this.m_type,\n          bullet: this.m_bulletFlag,\n          position: this.m_xf.p,\n          angle: this.m_xf.q.getAngle(),\n          linearVelocity: this.m_linearVelocity,\n          angularVelocity: this.m_angularVelocity,\n          fixtures\n        };\n      };\n      Body2._deserialize = function(data, world, restore) {\n        var body = new Body2(world, data);\n        if (data.fixtures) {\n          for (var i = data.fixtures.length - 1; i >= 0; i--) {\n            var fixture = restore(Fixture, data.fixtures[i], body);\n            body._addFixture(fixture);\n          }\n        }\n        return body;\n      };\n      Body2.prototype.isWorldLocked = function() {\n        return this.m_world && this.m_world.isLocked() ? true : false;\n      };\n      Body2.prototype.getWorld = function() {\n        return this.m_world;\n      };\n      Body2.prototype.getNext = function() {\n        return this.m_next;\n      };\n      Body2.prototype.setUserData = function(data) {\n        this.m_userData = data;\n      };\n      Body2.prototype.getUserData = function() {\n        return this.m_userData;\n      };\n      Body2.prototype.getFixtureList = function() {\n        return this.m_fixtureList;\n      };\n      Body2.prototype.getJointList = function() {\n        return this.m_jointList;\n      };\n      Body2.prototype.getContactList = function() {\n        return this.m_contactList;\n      };\n      Body2.prototype.isStatic = function() {\n        return this.m_type == STATIC;\n      };\n      Body2.prototype.isDynamic = function() {\n        return this.m_type == DYNAMIC;\n      };\n      Body2.prototype.isKinematic = function() {\n        return this.m_type == KINEMATIC;\n      };\n      Body2.prototype.setStatic = function() {\n        this.setType(STATIC);\n        return this;\n      };\n      Body2.prototype.setDynamic = function() {\n        this.setType(DYNAMIC);\n        return this;\n      };\n      Body2.prototype.setKinematic = function() {\n        this.setType(KINEMATIC);\n        return this;\n      };\n      Body2.prototype.getType = function() {\n        return this.m_type;\n      };\n      Body2.prototype.setType = function(type) {\n        if (this.isWorldLocked() == true) {\n          return;\n        }\n        if (this.m_type == type) {\n          return;\n        }\n        this.m_type = type;\n        this.resetMassData();\n        if (this.m_type == STATIC) {\n          this.m_linearVelocity.setZero();\n          this.m_angularVelocity = 0;\n          this.m_sweep.forward();\n          this.synchronizeFixtures();\n        }\n        this.setAwake(true);\n        this.m_force.setZero();\n        this.m_torque = 0;\n        var ce = this.m_contactList;\n        while (ce) {\n          var ce0 = ce;\n          ce = ce.next;\n          this.m_world.destroyContact(ce0.contact);\n        }\n        this.m_contactList = null;\n        var broadPhase = this.m_world.m_broadPhase;\n        for (var f = this.m_fixtureList; f; f = f.m_next) {\n          for (var i = 0; i < f.m_proxyCount; ++i) {\n            broadPhase.touchProxy(f.m_proxies[i].proxyId);\n          }\n        }\n      };\n      Body2.prototype.isBullet = function() {\n        return this.m_bulletFlag;\n      };\n      Body2.prototype.setBullet = function(flag) {\n        this.m_bulletFlag = !!flag;\n      };\n      Body2.prototype.isSleepingAllowed = function() {\n        return this.m_autoSleepFlag;\n      };\n      Body2.prototype.setSleepingAllowed = function(flag) {\n        this.m_autoSleepFlag = !!flag;\n        if (this.m_autoSleepFlag == false) {\n          this.setAwake(true);\n        }\n      };\n      Body2.prototype.isAwake = function() {\n        return this.m_awakeFlag;\n      };\n      Body2.prototype.setAwake = function(flag) {\n        if (flag) {\n          this.m_awakeFlag = true;\n          this.m_sleepTime = 0;\n        } else {\n          this.m_awakeFlag = false;\n          this.m_sleepTime = 0;\n          this.m_linearVelocity.setZero();\n          this.m_angularVelocity = 0;\n          this.m_force.setZero();\n          this.m_torque = 0;\n        }\n      };\n      Body2.prototype.isActive = function() {\n        return this.m_activeFlag;\n      };\n      Body2.prototype.setActive = function(flag) {\n        if (flag == this.m_activeFlag) {\n          return;\n        }\n        this.m_activeFlag = !!flag;\n        if (this.m_activeFlag) {\n          var broadPhase = this.m_world.m_broadPhase;\n          for (var f = this.m_fixtureList; f; f = f.m_next) {\n            f.createProxies(broadPhase, this.m_xf);\n          }\n          this.m_world.m_newFixture = true;\n        } else {\n          var broadPhase = this.m_world.m_broadPhase;\n          for (var f = this.m_fixtureList; f; f = f.m_next) {\n            f.destroyProxies(broadPhase);\n          }\n          var ce = this.m_contactList;\n          while (ce) {\n            var ce0 = ce;\n            ce = ce.next;\n            this.m_world.destroyContact(ce0.contact);\n          }\n          this.m_contactList = null;\n        }\n      };\n      Body2.prototype.isFixedRotation = function() {\n        return this.m_fixedRotationFlag;\n      };\n      Body2.prototype.setFixedRotation = function(flag) {\n        if (this.m_fixedRotationFlag == flag) {\n          return;\n        }\n        this.m_fixedRotationFlag = !!flag;\n        this.m_angularVelocity = 0;\n        this.resetMassData();\n      };\n      Body2.prototype.getTransform = function() {\n        return this.m_xf;\n      };\n      Body2.prototype.setTransform = function(a2, b2) {\n        if (this.isWorldLocked() == true) {\n          return;\n        }\n        if (typeof b2 === \"number\") {\n          this.m_xf.setNum(a2, b2);\n        } else {\n          this.m_xf.setTransform(a2);\n        }\n        this.m_sweep.setTransform(this.m_xf);\n        var broadPhase = this.m_world.m_broadPhase;\n        for (var f = this.m_fixtureList; f; f = f.m_next) {\n          f.synchronize(broadPhase, this.m_xf, this.m_xf);\n        }\n        this.setAwake(true);\n      };\n      Body2.prototype.synchronizeTransform = function() {\n        this.m_sweep.getTransform(this.m_xf, 1);\n      };\n      Body2.prototype.synchronizeFixtures = function() {\n        this.m_sweep.getTransform(xf$2, 0);\n        var broadPhase = this.m_world.m_broadPhase;\n        for (var f = this.m_fixtureList; f; f = f.m_next) {\n          f.synchronize(broadPhase, xf$2, this.m_xf);\n        }\n      };\n      Body2.prototype.advance = function(alpha) {\n        this.m_sweep.advance(alpha);\n        copyVec2(this.m_sweep.c, this.m_sweep.c0);\n        this.m_sweep.a = this.m_sweep.a0;\n        this.m_sweep.getTransform(this.m_xf, 1);\n      };\n      Body2.prototype.getPosition = function() {\n        return this.m_xf.p;\n      };\n      Body2.prototype.setPosition = function(p) {\n        this.setTransform(p, this.m_sweep.a);\n      };\n      Body2.prototype.getAngle = function() {\n        return this.m_sweep.a;\n      };\n      Body2.prototype.setAngle = function(angle) {\n        this.setTransform(this.m_xf.p, angle);\n      };\n      Body2.prototype.getWorldCenter = function() {\n        return this.m_sweep.c;\n      };\n      Body2.prototype.getLocalCenter = function() {\n        return this.m_sweep.localCenter;\n      };\n      Body2.prototype.getLinearVelocity = function() {\n        return this.m_linearVelocity;\n      };\n      Body2.prototype.getLinearVelocityFromWorldPoint = function(worldPoint) {\n        var localCenter2 = Vec2.sub(worldPoint, this.m_sweep.c);\n        return Vec2.add(this.m_linearVelocity, Vec2.crossNumVec2(this.m_angularVelocity, localCenter2));\n      };\n      Body2.prototype.getLinearVelocityFromLocalPoint = function(localPoint) {\n        return this.getLinearVelocityFromWorldPoint(this.getWorldPoint(localPoint));\n      };\n      Body2.prototype.setLinearVelocity = function(v3) {\n        if (this.m_type == STATIC) {\n          return;\n        }\n        if (Vec2.dot(v3, v3) > 0) {\n          this.setAwake(true);\n        }\n        this.m_linearVelocity.setVec2(v3);\n      };\n      Body2.prototype.getAngularVelocity = function() {\n        return this.m_angularVelocity;\n      };\n      Body2.prototype.setAngularVelocity = function(w) {\n        if (this.m_type == STATIC) {\n          return;\n        }\n        if (w * w > 0) {\n          this.setAwake(true);\n        }\n        this.m_angularVelocity = w;\n      };\n      Body2.prototype.getLinearDamping = function() {\n        return this.m_linearDamping;\n      };\n      Body2.prototype.setLinearDamping = function(linearDamping) {\n        this.m_linearDamping = linearDamping;\n      };\n      Body2.prototype.getAngularDamping = function() {\n        return this.m_angularDamping;\n      };\n      Body2.prototype.setAngularDamping = function(angularDamping) {\n        this.m_angularDamping = angularDamping;\n      };\n      Body2.prototype.getGravityScale = function() {\n        return this.m_gravityScale;\n      };\n      Body2.prototype.setGravityScale = function(scale) {\n        this.m_gravityScale = scale;\n      };\n      Body2.prototype.getMass = function() {\n        return this.m_mass;\n      };\n      Body2.prototype.getInertia = function() {\n        return this.m_I + this.m_mass * Vec2.dot(this.m_sweep.localCenter, this.m_sweep.localCenter);\n      };\n      Body2.prototype.getMassData = function(data) {\n        data.mass = this.m_mass;\n        data.I = this.getInertia();\n        copyVec2(data.center, this.m_sweep.localCenter);\n      };\n      Body2.prototype.resetMassData = function() {\n        this.m_mass = 0;\n        this.m_invMass = 0;\n        this.m_I = 0;\n        this.m_invI = 0;\n        zeroVec2(this.m_sweep.localCenter);\n        if (this.isStatic() || this.isKinematic()) {\n          copyVec2(this.m_sweep.c0, this.m_xf.p);\n          copyVec2(this.m_sweep.c, this.m_xf.p);\n          this.m_sweep.a0 = this.m_sweep.a;\n          return;\n        }\n        zeroVec2(localCenter);\n        for (var f = this.m_fixtureList; f; f = f.m_next) {\n          if (f.m_density == 0) {\n            continue;\n          }\n          var massData = {\n            mass: 0,\n            center: vec2(0, 0),\n            I: 0\n          };\n          f.getMassData(massData);\n          this.m_mass += massData.mass;\n          plusScaleVec2(localCenter, massData.mass, massData.center);\n          this.m_I += massData.I;\n        }\n        if (this.m_mass > 0) {\n          this.m_invMass = 1 / this.m_mass;\n          scaleVec2(localCenter, this.m_invMass, localCenter);\n        } else {\n          this.m_mass = 1;\n          this.m_invMass = 1;\n        }\n        if (this.m_I > 0 && this.m_fixedRotationFlag == false) {\n          this.m_I -= this.m_mass * dotVec2(localCenter, localCenter);\n          this.m_invI = 1 / this.m_I;\n        } else {\n          this.m_I = 0;\n          this.m_invI = 0;\n        }\n        copyVec2(oldCenter, this.m_sweep.c);\n        this.m_sweep.setLocalCenter(localCenter, this.m_xf);\n        subVec2(shift, this.m_sweep.c, oldCenter);\n        crossNumVec2(temp$6, this.m_angularVelocity, shift);\n        plusVec2(this.m_linearVelocity, temp$6);\n      };\n      Body2.prototype.setMassData = function(massData) {\n        if (this.isWorldLocked() == true) {\n          return;\n        }\n        if (this.m_type != DYNAMIC) {\n          return;\n        }\n        this.m_invMass = 0;\n        this.m_I = 0;\n        this.m_invI = 0;\n        this.m_mass = massData.mass;\n        if (this.m_mass <= 0) {\n          this.m_mass = 1;\n        }\n        this.m_invMass = 1 / this.m_mass;\n        if (massData.I > 0 && this.m_fixedRotationFlag == false) {\n          this.m_I = massData.I - this.m_mass * dotVec2(massData.center, massData.center);\n          this.m_invI = 1 / this.m_I;\n        }\n        copyVec2(oldCenter, this.m_sweep.c);\n        this.m_sweep.setLocalCenter(massData.center, this.m_xf);\n        subVec2(shift, this.m_sweep.c, oldCenter);\n        crossNumVec2(temp$6, this.m_angularVelocity, shift);\n        plusVec2(this.m_linearVelocity, temp$6);\n      };\n      Body2.prototype.applyForce = function(force, point2, wake) {\n        if (wake === void 0) {\n          wake = true;\n        }\n        if (this.m_type != DYNAMIC) {\n          return;\n        }\n        if (wake && this.m_awakeFlag == false) {\n          this.setAwake(true);\n        }\n        if (this.m_awakeFlag) {\n          this.m_force.add(force);\n          this.m_torque += Vec2.crossVec2Vec2(Vec2.sub(point2, this.m_sweep.c), force);\n        }\n      };\n      Body2.prototype.applyForceToCenter = function(force, wake) {\n        if (wake === void 0) {\n          wake = true;\n        }\n        if (this.m_type != DYNAMIC) {\n          return;\n        }\n        if (wake && this.m_awakeFlag == false) {\n          this.setAwake(true);\n        }\n        if (this.m_awakeFlag) {\n          this.m_force.add(force);\n        }\n      };\n      Body2.prototype.applyTorque = function(torque, wake) {\n        if (wake === void 0) {\n          wake = true;\n        }\n        if (this.m_type != DYNAMIC) {\n          return;\n        }\n        if (wake && this.m_awakeFlag == false) {\n          this.setAwake(true);\n        }\n        if (this.m_awakeFlag) {\n          this.m_torque += torque;\n        }\n      };\n      Body2.prototype.applyLinearImpulse = function(impulse, point2, wake) {\n        if (wake === void 0) {\n          wake = true;\n        }\n        if (this.m_type != DYNAMIC) {\n          return;\n        }\n        if (wake && this.m_awakeFlag == false) {\n          this.setAwake(true);\n        }\n        if (this.m_awakeFlag) {\n          this.m_linearVelocity.addMul(this.m_invMass, impulse);\n          this.m_angularVelocity += this.m_invI * Vec2.crossVec2Vec2(Vec2.sub(point2, this.m_sweep.c), impulse);\n        }\n      };\n      Body2.prototype.applyAngularImpulse = function(impulse, wake) {\n        if (wake === void 0) {\n          wake = true;\n        }\n        if (this.m_type != DYNAMIC) {\n          return;\n        }\n        if (wake && this.m_awakeFlag == false) {\n          this.setAwake(true);\n        }\n        if (this.m_awakeFlag) {\n          this.m_angularVelocity += this.m_invI * impulse;\n        }\n      };\n      Body2.prototype.shouldCollide = function(that) {\n        if (this.m_type != DYNAMIC && that.m_type != DYNAMIC) {\n          return false;\n        }\n        for (var jn = this.m_jointList; jn; jn = jn.next) {\n          if (jn.other == that) {\n            if (jn.joint.m_collideConnected == false) {\n              return false;\n            }\n          }\n        }\n        return true;\n      };\n      Body2.prototype._addFixture = function(fixture) {\n        if (this.isWorldLocked() == true) {\n          return null;\n        }\n        if (this.m_activeFlag) {\n          var broadPhase = this.m_world.m_broadPhase;\n          fixture.createProxies(broadPhase, this.m_xf);\n        }\n        fixture.m_next = this.m_fixtureList;\n        this.m_fixtureList = fixture;\n        if (fixture.m_density > 0) {\n          this.resetMassData();\n        }\n        this.m_world.m_newFixture = true;\n        return fixture;\n      };\n      Body2.prototype.createFixture = function(shape, fixdef) {\n        if (this.isWorldLocked() == true) {\n          return null;\n        }\n        var fixture = new Fixture(this, shape, fixdef);\n        this._addFixture(fixture);\n        return fixture;\n      };\n      Body2.prototype.destroyFixture = function(fixture) {\n        if (this.isWorldLocked() == true) {\n          return;\n        }\n        if (this.m_fixtureList === fixture) {\n          this.m_fixtureList = fixture.m_next;\n        } else {\n          var node = this.m_fixtureList;\n          while (node != null) {\n            if (node.m_next === fixture) {\n              node.m_next = fixture.m_next;\n              break;\n            }\n            node = node.m_next;\n          }\n        }\n        var edge = this.m_contactList;\n        while (edge) {\n          var c2 = edge.contact;\n          edge = edge.next;\n          var fixtureA = c2.getFixtureA();\n          var fixtureB = c2.getFixtureB();\n          if (fixture == fixtureA || fixture == fixtureB) {\n            this.m_world.destroyContact(c2);\n          }\n        }\n        if (this.m_activeFlag) {\n          var broadPhase = this.m_world.m_broadPhase;\n          fixture.destroyProxies(broadPhase);\n        }\n        fixture.m_body = null;\n        fixture.m_next = null;\n        this.m_world.publish(\"remove-fixture\", fixture);\n        this.resetMassData();\n      };\n      Body2.prototype.getWorldPoint = function(localPoint) {\n        return Transform.mulVec2(this.m_xf, localPoint);\n      };\n      Body2.prototype.getWorldVector = function(localVector) {\n        return Rot.mulVec2(this.m_xf.q, localVector);\n      };\n      Body2.prototype.getLocalPoint = function(worldPoint) {\n        return Transform.mulTVec2(this.m_xf, worldPoint);\n      };\n      Body2.prototype.getLocalVector = function(worldVector) {\n        return Rot.mulTVec2(this.m_xf.q, worldVector);\n      };\n      Body2.STATIC = \"static\";\n      Body2.KINEMATIC = \"kinematic\";\n      Body2.DYNAMIC = \"dynamic\";\n      return Body2;\n    }()\n  );\n  var JointEdge = (\n    /** @class */\n    /* @__PURE__ */ function() {\n      function JointEdge2() {\n        this.other = null;\n        this.joint = null;\n        this.prev = null;\n        this.next = null;\n      }\n      return JointEdge2;\n    }()\n  );\n  var Joint = (\n    /** @class */\n    function() {\n      function Joint2(def, bodyA, bodyB) {\n        this.m_type = \"unknown-joint\";\n        this.m_prev = null;\n        this.m_next = null;\n        this.m_edgeA = new JointEdge();\n        this.m_edgeB = new JointEdge();\n        this.m_islandFlag = false;\n        this.style = {};\n        this.appData = {};\n        bodyA = \"bodyA\" in def ? def.bodyA : bodyA;\n        bodyB = \"bodyB\" in def ? def.bodyB : bodyB;\n        this.m_bodyA = bodyA;\n        this.m_bodyB = bodyB;\n        this.m_collideConnected = !!def.collideConnected;\n        this.m_userData = def.userData;\n        if (typeof def.style === \"object\" && def.style !== null) {\n          this.style = def.style;\n        }\n      }\n      Joint2.prototype.isActive = function() {\n        return this.m_bodyA.isActive() && this.m_bodyB.isActive();\n      };\n      Joint2.prototype.getType = function() {\n        return this.m_type;\n      };\n      Joint2.prototype.getBodyA = function() {\n        return this.m_bodyA;\n      };\n      Joint2.prototype.getBodyB = function() {\n        return this.m_bodyB;\n      };\n      Joint2.prototype.getNext = function() {\n        return this.m_next;\n      };\n      Joint2.prototype.getUserData = function() {\n        return this.m_userData;\n      };\n      Joint2.prototype.setUserData = function(data) {\n        this.m_userData = data;\n      };\n      Joint2.prototype.getCollideConnected = function() {\n        return this.m_collideConnected;\n      };\n      Joint2.prototype.shiftOrigin = function(newOrigin) {\n      };\n      Joint2.prototype._resetAnchors = function(def) {\n        return this._reset(def);\n      };\n      return Joint2;\n    }()\n  );\n  var stats = {\n    gjkCalls: 0,\n    gjkIters: 0,\n    gjkMaxIters: 0,\n    toiTime: 0,\n    toiMaxTime: 0,\n    toiCalls: 0,\n    toiIters: 0,\n    toiMaxIters: 0,\n    toiRootIters: 0,\n    toiMaxRootIters: 0,\n    toString: function(newline) {\n      newline = typeof newline === \"string\" ? newline : \"\\n\";\n      var string = \"\";\n      for (var name_1 in this) {\n        if (typeof this[name_1] !== \"function\" && typeof this[name_1] !== \"object\") {\n          string += name_1 + \": \" + this[name_1] + newline;\n        }\n      }\n      return string;\n    }\n  };\n  var now = function() {\n    return Date.now();\n  };\n  var diff = function(time) {\n    return Date.now() - time;\n  };\n  const Timer = {\n    now,\n    diff\n  };\n  var math_max$4 = Math.max;\n  var temp$5 = vec2(0, 0);\n  var normal$4 = vec2(0, 0);\n  var e12 = vec2(0, 0);\n  var e13 = vec2(0, 0);\n  var e23 = vec2(0, 0);\n  var temp1 = vec2(0, 0);\n  var temp2 = vec2(0, 0);\n  stats.gjkCalls = 0;\n  stats.gjkIters = 0;\n  stats.gjkMaxIters = 0;\n  var DistanceInput = (\n    /** @class */\n    function() {\n      function DistanceInput2() {\n        this.proxyA = new DistanceProxy();\n        this.proxyB = new DistanceProxy();\n        this.transformA = Transform.identity();\n        this.transformB = Transform.identity();\n        this.useRadii = false;\n      }\n      DistanceInput2.prototype.recycle = function() {\n        this.proxyA.recycle();\n        this.proxyB.recycle();\n        this.transformA.setIdentity();\n        this.transformB.setIdentity();\n        this.useRadii = false;\n      };\n      return DistanceInput2;\n    }()\n  );\n  var DistanceOutput = (\n    /** @class */\n    function() {\n      function DistanceOutput2() {\n        this.pointA = vec2(0, 0);\n        this.pointB = vec2(0, 0);\n        this.distance = 0;\n        this.iterations = 0;\n      }\n      DistanceOutput2.prototype.recycle = function() {\n        zeroVec2(this.pointA);\n        zeroVec2(this.pointB);\n        this.distance = 0;\n        this.iterations = 0;\n      };\n      return DistanceOutput2;\n    }()\n  );\n  var SimplexCache = (\n    /** @class */\n    function() {\n      function SimplexCache2() {\n        this.metric = 0;\n        this.indexA = [];\n        this.indexB = [];\n        this.count = 0;\n      }\n      SimplexCache2.prototype.recycle = function() {\n        this.metric = 0;\n        this.indexA.length = 0;\n        this.indexB.length = 0;\n        this.count = 0;\n      };\n      return SimplexCache2;\n    }()\n  );\n  var Distance = function(output2, cache2, input2) {\n    ++stats.gjkCalls;\n    var proxyA = input2.proxyA;\n    var proxyB = input2.proxyB;\n    var xfA2 = input2.transformA;\n    var xfB2 = input2.transformB;\n    simplex.recycle();\n    simplex.readCache(cache2, proxyA, xfA2, proxyB, xfB2);\n    var vertices = simplex.m_v;\n    var k_maxIters = SettingsInternal.maxDistanceIterations;\n    var saveA = [];\n    var saveB = [];\n    var saveCount = 0;\n    var iter = 0;\n    while (iter < k_maxIters) {\n      saveCount = simplex.m_count;\n      for (var i = 0; i < saveCount; ++i) {\n        saveA[i] = vertices[i].indexA;\n        saveB[i] = vertices[i].indexB;\n      }\n      simplex.solve();\n      if (simplex.m_count === 3) {\n        break;\n      }\n      var d2 = simplex.getSearchDirection();\n      if (lengthSqrVec2(d2) < EPSILON * EPSILON) {\n        break;\n      }\n      var vertex = vertices[simplex.m_count];\n      vertex.indexA = proxyA.getSupport(derotVec2(temp$5, xfA2.q, scaleVec2(temp$5, -1, d2)));\n      transformVec2(vertex.wA, xfA2, proxyA.getVertex(vertex.indexA));\n      vertex.indexB = proxyB.getSupport(derotVec2(temp$5, xfB2.q, d2));\n      transformVec2(vertex.wB, xfB2, proxyB.getVertex(vertex.indexB));\n      subVec2(vertex.w, vertex.wB, vertex.wA);\n      ++iter;\n      ++stats.gjkIters;\n      var duplicate = false;\n      for (var i = 0; i < saveCount; ++i) {\n        if (vertex.indexA === saveA[i] && vertex.indexB === saveB[i]) {\n          duplicate = true;\n          break;\n        }\n      }\n      if (duplicate) {\n        break;\n      }\n      ++simplex.m_count;\n    }\n    stats.gjkMaxIters = math_max$4(stats.gjkMaxIters, iter);\n    simplex.getWitnessPoints(output2.pointA, output2.pointB);\n    output2.distance = distVec2(output2.pointA, output2.pointB);\n    output2.iterations = iter;\n    simplex.writeCache(cache2);\n    if (input2.useRadii) {\n      var rA2 = proxyA.m_radius;\n      var rB2 = proxyB.m_radius;\n      if (output2.distance > rA2 + rB2 && output2.distance > EPSILON) {\n        output2.distance -= rA2 + rB2;\n        subVec2(normal$4, output2.pointB, output2.pointA);\n        normalizeVec2(normal$4);\n        plusScaleVec2(output2.pointA, rA2, normal$4);\n        minusScaleVec2(output2.pointB, rB2, normal$4);\n      } else {\n        var p = subVec2(temp$5, output2.pointA, output2.pointB);\n        copyVec2(output2.pointA, p);\n        copyVec2(output2.pointB, p);\n        output2.distance = 0;\n      }\n    }\n  };\n  var DistanceProxy = (\n    /** @class */\n    function() {\n      function DistanceProxy2() {\n        this.m_vertices = [];\n        this.m_count = 0;\n        this.m_radius = 0;\n      }\n      DistanceProxy2.prototype.recycle = function() {\n        this.m_vertices.length = 0;\n        this.m_count = 0;\n        this.m_radius = 0;\n      };\n      DistanceProxy2.prototype.getVertexCount = function() {\n        return this.m_count;\n      };\n      DistanceProxy2.prototype.getVertex = function(index) {\n        return this.m_vertices[index];\n      };\n      DistanceProxy2.prototype.getSupport = function(d2) {\n        var bestIndex = -1;\n        var bestValue = -Infinity;\n        for (var i = 0; i < this.m_count; ++i) {\n          var value = dotVec2(this.m_vertices[i], d2);\n          if (value > bestValue) {\n            bestIndex = i;\n            bestValue = value;\n          }\n        }\n        return bestIndex;\n      };\n      DistanceProxy2.prototype.getSupportVertex = function(d2) {\n        return this.m_vertices[this.getSupport(d2)];\n      };\n      DistanceProxy2.prototype.set = function(shape, index) {\n        shape.computeDistanceProxy(this, index);\n      };\n      DistanceProxy2.prototype.setVertices = function(vertices, count, radius) {\n        this.m_vertices = vertices;\n        this.m_count = count;\n        this.m_radius = radius;\n      };\n      return DistanceProxy2;\n    }()\n  );\n  var SimplexVertex = (\n    /** @class */\n    function() {\n      function SimplexVertex2() {\n        this.wA = vec2(0, 0);\n        this.indexA = 0;\n        this.wB = vec2(0, 0);\n        this.indexB = 0;\n        this.w = vec2(0, 0);\n        this.a = 0;\n      }\n      SimplexVertex2.prototype.recycle = function() {\n        this.indexA = 0;\n        this.indexB = 0;\n        zeroVec2(this.wA);\n        zeroVec2(this.wB);\n        zeroVec2(this.w);\n        this.a = 0;\n      };\n      SimplexVertex2.prototype.set = function(v3) {\n        this.indexA = v3.indexA;\n        this.indexB = v3.indexB;\n        copyVec2(this.wA, v3.wA);\n        copyVec2(this.wB, v3.wB);\n        copyVec2(this.w, v3.w);\n        this.a = v3.a;\n      };\n      return SimplexVertex2;\n    }()\n  );\n  var searchDirection_reuse = vec2(0, 0);\n  var closestPoint_reuse = vec2(0, 0);\n  var Simplex = (\n    /** @class */\n    function() {\n      function Simplex2() {\n        this.m_v1 = new SimplexVertex();\n        this.m_v2 = new SimplexVertex();\n        this.m_v3 = new SimplexVertex();\n        this.m_v = [this.m_v1, this.m_v2, this.m_v3];\n      }\n      Simplex2.prototype.recycle = function() {\n        this.m_v1.recycle();\n        this.m_v2.recycle();\n        this.m_v3.recycle();\n        this.m_count = 0;\n      };\n      Simplex2.prototype.toString = function() {\n        if (this.m_count === 3) {\n          return [\n            \"+\" + this.m_count,\n            this.m_v1.a,\n            this.m_v1.wA.x,\n            this.m_v1.wA.y,\n            this.m_v1.wB.x,\n            this.m_v1.wB.y,\n            this.m_v2.a,\n            this.m_v2.wA.x,\n            this.m_v2.wA.y,\n            this.m_v2.wB.x,\n            this.m_v2.wB.y,\n            this.m_v3.a,\n            this.m_v3.wA.x,\n            this.m_v3.wA.y,\n            this.m_v3.wB.x,\n            this.m_v3.wB.y\n          ].toString();\n        } else if (this.m_count === 2) {\n          return [\n            \"+\" + this.m_count,\n            this.m_v1.a,\n            this.m_v1.wA.x,\n            this.m_v1.wA.y,\n            this.m_v1.wB.x,\n            this.m_v1.wB.y,\n            this.m_v2.a,\n            this.m_v2.wA.x,\n            this.m_v2.wA.y,\n            this.m_v2.wB.x,\n            this.m_v2.wB.y\n          ].toString();\n        } else if (this.m_count === 1) {\n          return [\n            \"+\" + this.m_count,\n            this.m_v1.a,\n            this.m_v1.wA.x,\n            this.m_v1.wA.y,\n            this.m_v1.wB.x,\n            this.m_v1.wB.y\n          ].toString();\n        } else {\n          return \"+\" + this.m_count;\n        }\n      };\n      Simplex2.prototype.readCache = function(cache2, proxyA, transformA, proxyB, transformB) {\n        this.m_count = cache2.count;\n        for (var i = 0; i < this.m_count; ++i) {\n          var v3 = this.m_v[i];\n          v3.indexA = cache2.indexA[i];\n          v3.indexB = cache2.indexB[i];\n          var wALocal = proxyA.getVertex(v3.indexA);\n          var wBLocal = proxyB.getVertex(v3.indexB);\n          transformVec2(v3.wA, transformA, wALocal);\n          transformVec2(v3.wB, transformB, wBLocal);\n          subVec2(v3.w, v3.wB, v3.wA);\n          v3.a = 0;\n        }\n        if (this.m_count > 1) {\n          var metric1 = cache2.metric;\n          var metric2 = this.getMetric();\n          if (metric2 < 0.5 * metric1 || 2 * metric1 < metric2 || metric2 < EPSILON) {\n            this.m_count = 0;\n          }\n        }\n        if (this.m_count === 0) {\n          var v3 = this.m_v[0];\n          v3.indexA = 0;\n          v3.indexB = 0;\n          var wALocal = proxyA.getVertex(0);\n          var wBLocal = proxyB.getVertex(0);\n          transformVec2(v3.wA, transformA, wALocal);\n          transformVec2(v3.wB, transformB, wBLocal);\n          subVec2(v3.w, v3.wB, v3.wA);\n          v3.a = 1;\n          this.m_count = 1;\n        }\n      };\n      Simplex2.prototype.writeCache = function(cache2) {\n        cache2.metric = this.getMetric();\n        cache2.count = this.m_count;\n        for (var i = 0; i < this.m_count; ++i) {\n          cache2.indexA[i] = this.m_v[i].indexA;\n          cache2.indexB[i] = this.m_v[i].indexB;\n        }\n      };\n      Simplex2.prototype.getSearchDirection = function() {\n        var v13 = this.m_v1;\n        var v22 = this.m_v2;\n        this.m_v3;\n        switch (this.m_count) {\n          case 1:\n            return setVec2(searchDirection_reuse, -v13.w.x, -v13.w.y);\n          case 2: {\n            subVec2(e12, v22.w, v13.w);\n            var sgn = -crossVec2Vec2(e12, v13.w);\n            if (sgn > 0) {\n              return setVec2(searchDirection_reuse, -e12.y, e12.x);\n            } else {\n              return setVec2(searchDirection_reuse, e12.y, -e12.x);\n            }\n          }\n          default:\n            return zeroVec2(searchDirection_reuse);\n        }\n      };\n      Simplex2.prototype.getClosestPoint = function() {\n        var v13 = this.m_v1;\n        var v22 = this.m_v2;\n        this.m_v3;\n        switch (this.m_count) {\n          case 0:\n            return zeroVec2(closestPoint_reuse);\n          case 1:\n            return copyVec2(closestPoint_reuse, v13.w);\n          case 2:\n            return combine2Vec2(closestPoint_reuse, v13.a, v13.w, v22.a, v22.w);\n          case 3:\n            return zeroVec2(closestPoint_reuse);\n          default:\n            return zeroVec2(closestPoint_reuse);\n        }\n      };\n      Simplex2.prototype.getWitnessPoints = function(pA2, pB2) {\n        var v13 = this.m_v1;\n        var v22 = this.m_v2;\n        var v3 = this.m_v3;\n        switch (this.m_count) {\n          case 0:\n            break;\n          case 1:\n            copyVec2(pA2, v13.wA);\n            copyVec2(pB2, v13.wB);\n            break;\n          case 2:\n            combine2Vec2(pA2, v13.a, v13.wA, v22.a, v22.wA);\n            combine2Vec2(pB2, v13.a, v13.wB, v22.a, v22.wB);\n            break;\n          case 3:\n            combine3Vec2(pA2, v13.a, v13.wA, v22.a, v22.wA, v3.a, v3.wA);\n            copyVec2(pB2, pA2);\n            break;\n        }\n      };\n      Simplex2.prototype.getMetric = function() {\n        switch (this.m_count) {\n          case 0:\n            return 0;\n          case 1:\n            return 0;\n          case 2:\n            return distVec2(this.m_v1.w, this.m_v2.w);\n          case 3:\n            return crossVec2Vec2(subVec2(temp1, this.m_v2.w, this.m_v1.w), subVec2(temp2, this.m_v3.w, this.m_v1.w));\n          default:\n            return 0;\n        }\n      };\n      Simplex2.prototype.solve = function() {\n        switch (this.m_count) {\n          case 1:\n            break;\n          case 2:\n            this.solve2();\n            break;\n          case 3:\n            this.solve3();\n            break;\n        }\n      };\n      Simplex2.prototype.solve2 = function() {\n        var w1 = this.m_v1.w;\n        var w2 = this.m_v2.w;\n        subVec2(e12, w2, w1);\n        var d12_2 = -dotVec2(w1, e12);\n        if (d12_2 <= 0) {\n          this.m_v1.a = 1;\n          this.m_count = 1;\n          return;\n        }\n        var d12_1 = dotVec2(w2, e12);\n        if (d12_1 <= 0) {\n          this.m_v2.a = 1;\n          this.m_count = 1;\n          this.m_v1.set(this.m_v2);\n          return;\n        }\n        var inv_d12 = 1 / (d12_1 + d12_2);\n        this.m_v1.a = d12_1 * inv_d12;\n        this.m_v2.a = d12_2 * inv_d12;\n        this.m_count = 2;\n      };\n      Simplex2.prototype.solve3 = function() {\n        var w1 = this.m_v1.w;\n        var w2 = this.m_v2.w;\n        var w3 = this.m_v3.w;\n        subVec2(e12, w2, w1);\n        var w1e12 = dotVec2(w1, e12);\n        var w2e12 = dotVec2(w2, e12);\n        var d12_1 = w2e12;\n        var d12_2 = -w1e12;\n        subVec2(e13, w3, w1);\n        var w1e13 = dotVec2(w1, e13);\n        var w3e13 = dotVec2(w3, e13);\n        var d13_1 = w3e13;\n        var d13_2 = -w1e13;\n        subVec2(e23, w3, w2);\n        var w2e23 = dotVec2(w2, e23);\n        var w3e23 = dotVec2(w3, e23);\n        var d23_1 = w3e23;\n        var d23_2 = -w2e23;\n        var n123 = crossVec2Vec2(e12, e13);\n        var d123_1 = n123 * crossVec2Vec2(w2, w3);\n        var d123_2 = n123 * crossVec2Vec2(w3, w1);\n        var d123_3 = n123 * crossVec2Vec2(w1, w2);\n        if (d12_2 <= 0 && d13_2 <= 0) {\n          this.m_v1.a = 1;\n          this.m_count = 1;\n          return;\n        }\n        if (d12_1 > 0 && d12_2 > 0 && d123_3 <= 0) {\n          var inv_d12 = 1 / (d12_1 + d12_2);\n          this.m_v1.a = d12_1 * inv_d12;\n          this.m_v2.a = d12_2 * inv_d12;\n          this.m_count = 2;\n          return;\n        }\n        if (d13_1 > 0 && d13_2 > 0 && d123_2 <= 0) {\n          var inv_d13 = 1 / (d13_1 + d13_2);\n          this.m_v1.a = d13_1 * inv_d13;\n          this.m_v3.a = d13_2 * inv_d13;\n          this.m_count = 2;\n          this.m_v2.set(this.m_v3);\n          return;\n        }\n        if (d12_1 <= 0 && d23_2 <= 0) {\n          this.m_v2.a = 1;\n          this.m_count = 1;\n          this.m_v1.set(this.m_v2);\n          return;\n        }\n        if (d13_1 <= 0 && d23_1 <= 0) {\n          this.m_v3.a = 1;\n          this.m_count = 1;\n          this.m_v1.set(this.m_v3);\n          return;\n        }\n        if (d23_1 > 0 && d23_2 > 0 && d123_1 <= 0) {\n          var inv_d23 = 1 / (d23_1 + d23_2);\n          this.m_v2.a = d23_1 * inv_d23;\n          this.m_v3.a = d23_2 * inv_d23;\n          this.m_count = 2;\n          this.m_v1.set(this.m_v3);\n          return;\n        }\n        var inv_d123 = 1 / (d123_1 + d123_2 + d123_3);\n        this.m_v1.a = d123_1 * inv_d123;\n        this.m_v2.a = d123_2 * inv_d123;\n        this.m_v3.a = d123_3 * inv_d123;\n        this.m_count = 3;\n      };\n      return Simplex2;\n    }()\n  );\n  var simplex = new Simplex();\n  var input$1 = new DistanceInput();\n  var cache$1 = new SimplexCache();\n  var output$1 = new DistanceOutput();\n  var testOverlap = function(shapeA, indexA, shapeB, indexB, xfA2, xfB2) {\n    input$1.recycle();\n    input$1.proxyA.set(shapeA, indexA);\n    input$1.proxyB.set(shapeB, indexB);\n    copyTransform(input$1.transformA, xfA2);\n    copyTransform(input$1.transformB, xfB2);\n    input$1.useRadii = true;\n    output$1.recycle();\n    cache$1.recycle();\n    Distance(output$1, cache$1, input$1);\n    return output$1.distance < 10 * EPSILON;\n  };\n  Distance.testOverlap = testOverlap;\n  Distance.Input = DistanceInput;\n  Distance.Output = DistanceOutput;\n  Distance.Proxy = DistanceProxy;\n  Distance.Cache = SimplexCache;\n  var ShapeCastInput = (\n    /** @class */\n    function() {\n      function ShapeCastInput2() {\n        this.proxyA = new DistanceProxy();\n        this.proxyB = new DistanceProxy();\n        this.transformA = Transform.identity();\n        this.transformB = Transform.identity();\n        this.translationB = Vec2.zero();\n      }\n      ShapeCastInput2.prototype.recycle = function() {\n        this.proxyA.recycle();\n        this.proxyB.recycle();\n        this.transformA.setIdentity();\n        this.transformB.setIdentity();\n        zeroVec2(this.translationB);\n      };\n      return ShapeCastInput2;\n    }()\n  );\n  var ShapeCastOutput = (\n    /** @class */\n    /* @__PURE__ */ function() {\n      function ShapeCastOutput2() {\n        this.point = Vec2.zero();\n        this.normal = Vec2.zero();\n        this.lambda = 1;\n        this.iterations = 0;\n      }\n      return ShapeCastOutput2;\n    }()\n  );\n  var ShapeCast = function(output2, input2) {\n    output2.iterations = 0;\n    output2.lambda = 1;\n    output2.normal.setZero();\n    output2.point.setZero();\n    var proxyA = input2.proxyA;\n    var proxyB = input2.proxyB;\n    var radiusA = math_max$4(proxyA.m_radius, SettingsInternal.polygonRadius);\n    var radiusB = math_max$4(proxyB.m_radius, SettingsInternal.polygonRadius);\n    var radius = radiusA + radiusB;\n    var xfA2 = input2.transformA;\n    var xfB2 = input2.transformB;\n    var r = input2.translationB;\n    var n2 = Vec2.zero();\n    var lambda = 0;\n    var simplex2 = new Simplex();\n    simplex2.m_count = 0;\n    var vertices = simplex2.m_v;\n    var indexA = proxyA.getSupport(Rot.mulTVec2(xfA2.q, Vec2.neg(r)));\n    var wA = Transform.mulVec2(xfA2, proxyA.getVertex(indexA));\n    var indexB = proxyB.getSupport(Rot.mulTVec2(xfB2.q, r));\n    var wB = Transform.mulVec2(xfB2, proxyB.getVertex(indexB));\n    var v3 = Vec2.sub(wA, wB);\n    var sigma = math_max$4(SettingsInternal.polygonRadius, radius - SettingsInternal.polygonRadius);\n    var tolerance = 0.5 * SettingsInternal.linearSlop;\n    var k_maxIters = 20;\n    var iter = 0;\n    while (iter < k_maxIters && v3.length() - sigma > tolerance) {\n      output2.iterations += 1;\n      indexA = proxyA.getSupport(Rot.mulTVec2(xfA2.q, Vec2.neg(v3)));\n      wA = Transform.mulVec2(xfA2, proxyA.getVertex(indexA));\n      indexB = proxyB.getSupport(Rot.mulTVec2(xfB2.q, v3));\n      wB = Transform.mulVec2(xfB2, proxyB.getVertex(indexB));\n      var p = Vec2.sub(wA, wB);\n      v3.normalize();\n      var vp = Vec2.dot(v3, p);\n      var vr = Vec2.dot(v3, r);\n      if (vp - sigma > lambda * vr) {\n        if (vr <= 0) {\n          return false;\n        }\n        lambda = (vp - sigma) / vr;\n        if (lambda > 1) {\n          return false;\n        }\n        n2.setMul(-1, v3);\n        simplex2.m_count = 0;\n      }\n      var vertex = vertices[simplex2.m_count];\n      vertex.indexA = indexB;\n      vertex.wA = Vec2.combine(1, wB, lambda, r);\n      vertex.indexB = indexA;\n      vertex.wB = wA;\n      vertex.w = Vec2.sub(vertex.wB, vertex.wA);\n      vertex.a = 1;\n      simplex2.m_count += 1;\n      switch (simplex2.m_count) {\n        case 1:\n          break;\n        case 2:\n          simplex2.solve2();\n          break;\n        case 3:\n          simplex2.solve3();\n          break;\n      }\n      if (simplex2.m_count == 3) {\n        return false;\n      }\n      v3.setVec2(simplex2.getClosestPoint());\n      ++iter;\n    }\n    if (iter == 0) {\n      return false;\n    }\n    var pointA2 = Vec2.zero();\n    var pointB2 = Vec2.zero();\n    simplex2.getWitnessPoints(pointB2, pointA2);\n    if (v3.lengthSquared() > 0) {\n      n2.setMul(-1, v3);\n      n2.normalize();\n    }\n    output2.point = Vec2.combine(1, pointA2, radiusA, n2);\n    output2.normal = n2;\n    output2.lambda = lambda;\n    output2.iterations = iter;\n    return true;\n  };\n  var math_abs$7 = Math.abs;\n  var math_max$3 = Math.max;\n  var TOIInput = (\n    /** @class */\n    function() {\n      function TOIInput2() {\n        this.proxyA = new DistanceProxy();\n        this.proxyB = new DistanceProxy();\n        this.sweepA = new Sweep();\n        this.sweepB = new Sweep();\n      }\n      TOIInput2.prototype.recycle = function() {\n        this.proxyA.recycle();\n        this.proxyB.recycle();\n        this.sweepA.recycle();\n        this.sweepB.recycle();\n        this.tMax = -1;\n      };\n      return TOIInput2;\n    }()\n  );\n  exports2.TOIOutputState = void 0;\n  (function(TOIOutputState2) {\n    TOIOutputState2[TOIOutputState2[\"e_unset\"] = -1] = \"e_unset\";\n    TOIOutputState2[TOIOutputState2[\"e_unknown\"] = 0] = \"e_unknown\";\n    TOIOutputState2[TOIOutputState2[\"e_failed\"] = 1] = \"e_failed\";\n    TOIOutputState2[TOIOutputState2[\"e_overlapped\"] = 2] = \"e_overlapped\";\n    TOIOutputState2[TOIOutputState2[\"e_touching\"] = 3] = \"e_touching\";\n    TOIOutputState2[TOIOutputState2[\"e_separated\"] = 4] = \"e_separated\";\n  })(exports2.TOIOutputState || (exports2.TOIOutputState = {}));\n  var TOIOutput = (\n    /** @class */\n    function() {\n      function TOIOutput2() {\n        this.state = exports2.TOIOutputState.e_unset;\n        this.t = -1;\n      }\n      TOIOutput2.prototype.recycle = function() {\n        this.state = exports2.TOIOutputState.e_unset;\n        this.t = -1;\n      };\n      return TOIOutput2;\n    }()\n  );\n  stats.toiTime = 0;\n  stats.toiMaxTime = 0;\n  stats.toiCalls = 0;\n  stats.toiIters = 0;\n  stats.toiMaxIters = 0;\n  stats.toiRootIters = 0;\n  stats.toiMaxRootIters = 0;\n  var distanceInput = new DistanceInput();\n  var distanceOutput = new DistanceOutput();\n  var cache = new SimplexCache();\n  var xfA$1 = transform(0, 0, 0);\n  var xfB$1 = transform(0, 0, 0);\n  var temp$4 = vec2(0, 0);\n  var pointA$2 = vec2(0, 0);\n  var pointB$2 = vec2(0, 0);\n  var normal$3 = vec2(0, 0);\n  var axisA = vec2(0, 0);\n  var axisB = vec2(0, 0);\n  var localPointA = vec2(0, 0);\n  var localPointB = vec2(0, 0);\n  var TimeOfImpact = function(output2, input2) {\n    var timer = Timer.now();\n    ++stats.toiCalls;\n    output2.state = exports2.TOIOutputState.e_unknown;\n    output2.t = input2.tMax;\n    var proxyA = input2.proxyA;\n    var proxyB = input2.proxyB;\n    var sweepA = input2.sweepA;\n    var sweepB = input2.sweepB;\n    sweepA.normalize();\n    sweepB.normalize();\n    var tMax = input2.tMax;\n    var totalRadius = proxyA.m_radius + proxyB.m_radius;\n    var target = math_max$3(SettingsInternal.linearSlop, totalRadius - 3 * SettingsInternal.linearSlop);\n    var tolerance = 0.25 * SettingsInternal.linearSlop;\n    var t1 = 0;\n    var k_maxIterations = SettingsInternal.maxTOIIterations;\n    var iter = 0;\n    cache.recycle();\n    distanceInput.proxyA.setVertices(proxyA.m_vertices, proxyA.m_count, proxyA.m_radius);\n    distanceInput.proxyB.setVertices(proxyB.m_vertices, proxyB.m_count, proxyB.m_radius);\n    distanceInput.useRadii = false;\n    while (true) {\n      sweepA.getTransform(xfA$1, t1);\n      sweepB.getTransform(xfB$1, t1);\n      copyTransform(distanceInput.transformA, xfA$1);\n      copyTransform(distanceInput.transformB, xfB$1);\n      Distance(distanceOutput, cache, distanceInput);\n      if (distanceOutput.distance <= 0) {\n        output2.state = exports2.TOIOutputState.e_overlapped;\n        output2.t = 0;\n        break;\n      }\n      if (distanceOutput.distance < target + tolerance) {\n        output2.state = exports2.TOIOutputState.e_touching;\n        output2.t = t1;\n        break;\n      }\n      separationFunction.initialize(cache, proxyA, sweepA, proxyB, sweepB, t1);\n      var done = false;\n      var t2 = tMax;\n      var pushBackIter = 0;\n      while (true) {\n        var s2 = separationFunction.findMinSeparation(t2);\n        if (s2 > target + tolerance) {\n          output2.state = exports2.TOIOutputState.e_separated;\n          output2.t = tMax;\n          done = true;\n          break;\n        }\n        if (s2 > target - tolerance) {\n          t1 = t2;\n          break;\n        }\n        var s1 = separationFunction.evaluate(t1);\n        if (s1 < target - tolerance) {\n          output2.state = exports2.TOIOutputState.e_failed;\n          output2.t = t1;\n          done = true;\n          break;\n        }\n        if (s1 <= target + tolerance) {\n          output2.state = exports2.TOIOutputState.e_touching;\n          output2.t = t1;\n          done = true;\n          break;\n        }\n        var rootIterCount = 0;\n        var a1 = t1;\n        var a2 = t2;\n        while (true) {\n          var t = void 0;\n          if (rootIterCount & 1) {\n            t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);\n          } else {\n            t = 0.5 * (a1 + a2);\n          }\n          ++rootIterCount;\n          ++stats.toiRootIters;\n          var s3 = separationFunction.evaluate(t);\n          if (math_abs$7(s3 - target) < tolerance) {\n            t2 = t;\n            break;\n          }\n          if (s3 > target) {\n            a1 = t;\n            s1 = s3;\n          } else {\n            a2 = t;\n            s2 = s3;\n          }\n          if (rootIterCount === 50) {\n            break;\n          }\n        }\n        stats.toiMaxRootIters = math_max$3(stats.toiMaxRootIters, rootIterCount);\n        ++pushBackIter;\n        if (pushBackIter === SettingsInternal.maxPolygonVertices) {\n          break;\n        }\n      }\n      ++iter;\n      ++stats.toiIters;\n      if (done) {\n        break;\n      }\n      if (iter === k_maxIterations) {\n        output2.state = exports2.TOIOutputState.e_failed;\n        output2.t = t1;\n        break;\n      }\n    }\n    stats.toiMaxIters = math_max$3(stats.toiMaxIters, iter);\n    var time = Timer.diff(timer);\n    stats.toiMaxTime = math_max$3(stats.toiMaxTime, time);\n    stats.toiTime += time;\n    separationFunction.recycle();\n  };\n  var SeparationFunctionType;\n  (function(SeparationFunctionType2) {\n    SeparationFunctionType2[SeparationFunctionType2[\"e_unset\"] = -1] = \"e_unset\";\n    SeparationFunctionType2[SeparationFunctionType2[\"e_points\"] = 1] = \"e_points\";\n    SeparationFunctionType2[SeparationFunctionType2[\"e_faceA\"] = 2] = \"e_faceA\";\n    SeparationFunctionType2[SeparationFunctionType2[\"e_faceB\"] = 3] = \"e_faceB\";\n  })(SeparationFunctionType || (SeparationFunctionType = {}));\n  var SeparationFunction = (\n    /** @class */\n    function() {\n      function SeparationFunction2() {\n        this.m_proxyA = null;\n        this.m_proxyB = null;\n        this.m_sweepA = null;\n        this.m_sweepB = null;\n        this.m_type = SeparationFunctionType.e_unset;\n        this.m_localPoint = vec2(0, 0);\n        this.m_axis = vec2(0, 0);\n        this.indexA = -1;\n        this.indexB = -1;\n      }\n      SeparationFunction2.prototype.recycle = function() {\n        this.m_proxyA = null;\n        this.m_proxyB = null;\n        this.m_sweepA = null;\n        this.m_sweepB = null;\n        this.m_type = SeparationFunctionType.e_unset;\n        zeroVec2(this.m_localPoint);\n        zeroVec2(this.m_axis);\n        this.indexA = -1;\n        this.indexB = -1;\n      };\n      SeparationFunction2.prototype.initialize = function(cache2, proxyA, sweepA, proxyB, sweepB, t1) {\n        var count = cache2.count;\n        this.m_proxyA = proxyA;\n        this.m_proxyB = proxyB;\n        this.m_sweepA = sweepA;\n        this.m_sweepB = sweepB;\n        this.m_sweepA.getTransform(xfA$1, t1);\n        this.m_sweepB.getTransform(xfB$1, t1);\n        if (count === 1) {\n          this.m_type = SeparationFunctionType.e_points;\n          var localPointA_1 = this.m_proxyA.getVertex(cache2.indexA[0]);\n          var localPointB_1 = this.m_proxyB.getVertex(cache2.indexB[0]);\n          transformVec2(pointA$2, xfA$1, localPointA_1);\n          transformVec2(pointB$2, xfB$1, localPointB_1);\n          subVec2(this.m_axis, pointB$2, pointA$2);\n          var s2 = normalizeVec2Length(this.m_axis);\n          return s2;\n        } else if (cache2.indexA[0] === cache2.indexA[1]) {\n          this.m_type = SeparationFunctionType.e_faceB;\n          var localPointB1 = proxyB.getVertex(cache2.indexB[0]);\n          var localPointB2 = proxyB.getVertex(cache2.indexB[1]);\n          crossVec2Num(this.m_axis, subVec2(temp$4, localPointB2, localPointB1), 1);\n          normalizeVec2(this.m_axis);\n          rotVec2(normal$3, xfB$1.q, this.m_axis);\n          combine2Vec2(this.m_localPoint, 0.5, localPointB1, 0.5, localPointB2);\n          transformVec2(pointB$2, xfB$1, this.m_localPoint);\n          var localPointA_2 = proxyA.getVertex(cache2.indexA[0]);\n          var pointA_1 = Transform.mulVec2(xfA$1, localPointA_2);\n          var s2 = dotVec2(pointA_1, normal$3) - dotVec2(pointB$2, normal$3);\n          if (s2 < 0) {\n            negVec2(this.m_axis);\n            s2 = -s2;\n          }\n          return s2;\n        } else {\n          this.m_type = SeparationFunctionType.e_faceA;\n          var localPointA1 = this.m_proxyA.getVertex(cache2.indexA[0]);\n          var localPointA2 = this.m_proxyA.getVertex(cache2.indexA[1]);\n          crossVec2Num(this.m_axis, subVec2(temp$4, localPointA2, localPointA1), 1);\n          normalizeVec2(this.m_axis);\n          rotVec2(normal$3, xfA$1.q, this.m_axis);\n          combine2Vec2(this.m_localPoint, 0.5, localPointA1, 0.5, localPointA2);\n          transformVec2(pointA$2, xfA$1, this.m_localPoint);\n          var localPointB_2 = this.m_proxyB.getVertex(cache2.indexB[0]);\n          transformVec2(pointB$2, xfB$1, localPointB_2);\n          var s2 = dotVec2(pointB$2, normal$3) - dotVec2(pointA$2, normal$3);\n          if (s2 < 0) {\n            negVec2(this.m_axis);\n            s2 = -s2;\n          }\n          return s2;\n        }\n      };\n      SeparationFunction2.prototype.compute = function(find, t) {\n        this.m_sweepA.getTransform(xfA$1, t);\n        this.m_sweepB.getTransform(xfB$1, t);\n        switch (this.m_type) {\n          case SeparationFunctionType.e_points: {\n            if (find) {\n              derotVec2(axisA, xfA$1.q, this.m_axis);\n              derotVec2(axisB, xfB$1.q, scaleVec2(temp$4, -1, this.m_axis));\n              this.indexA = this.m_proxyA.getSupport(axisA);\n              this.indexB = this.m_proxyB.getSupport(axisB);\n            }\n            copyVec2(localPointA, this.m_proxyA.getVertex(this.indexA));\n            copyVec2(localPointB, this.m_proxyB.getVertex(this.indexB));\n            transformVec2(pointA$2, xfA$1, localPointA);\n            transformVec2(pointB$2, xfB$1, localPointB);\n            var sep = dotVec2(pointB$2, this.m_axis) - dotVec2(pointA$2, this.m_axis);\n            return sep;\n          }\n          case SeparationFunctionType.e_faceA: {\n            rotVec2(normal$3, xfA$1.q, this.m_axis);\n            transformVec2(pointA$2, xfA$1, this.m_localPoint);\n            if (find) {\n              derotVec2(axisB, xfB$1.q, scaleVec2(temp$4, -1, normal$3));\n              this.indexA = -1;\n              this.indexB = this.m_proxyB.getSupport(axisB);\n            }\n            copyVec2(localPointB, this.m_proxyB.getVertex(this.indexB));\n            transformVec2(pointB$2, xfB$1, localPointB);\n            var sep = dotVec2(pointB$2, normal$3) - dotVec2(pointA$2, normal$3);\n            return sep;\n          }\n          case SeparationFunctionType.e_faceB: {\n            rotVec2(normal$3, xfB$1.q, this.m_axis);\n            transformVec2(pointB$2, xfB$1, this.m_localPoint);\n            if (find) {\n              derotVec2(axisA, xfA$1.q, scaleVec2(temp$4, -1, normal$3));\n              this.indexB = -1;\n              this.indexA = this.m_proxyA.getSupport(axisA);\n            }\n            copyVec2(localPointA, this.m_proxyA.getVertex(this.indexA));\n            transformVec2(pointA$2, xfA$1, localPointA);\n            var sep = dotVec2(pointA$2, normal$3) - dotVec2(pointB$2, normal$3);\n            return sep;\n          }\n          default:\n            if (find) {\n              this.indexA = -1;\n              this.indexB = -1;\n            }\n            return 0;\n        }\n      };\n      SeparationFunction2.prototype.findMinSeparation = function(t) {\n        return this.compute(true, t);\n      };\n      SeparationFunction2.prototype.evaluate = function(t) {\n        return this.compute(false, t);\n      };\n      return SeparationFunction2;\n    }()\n  );\n  var separationFunction = new SeparationFunction();\n  TimeOfImpact.Input = TOIInput;\n  TimeOfImpact.Output = TOIOutput;\n  var math_abs$6 = Math.abs;\n  var math_sqrt$3 = Math.sqrt;\n  var math_min$5 = Math.min;\n  var TimeStep = (\n    /** @class */\n    function() {\n      function TimeStep2() {\n        this.dt = 0;\n        this.inv_dt = 0;\n        this.velocityIterations = 0;\n        this.positionIterations = 0;\n        this.warmStarting = false;\n        this.blockSolve = true;\n        this.inv_dt0 = 0;\n        this.dtRatio = 1;\n      }\n      TimeStep2.prototype.reset = function(dt) {\n        if (this.dt > 0) {\n          this.inv_dt0 = this.inv_dt;\n        }\n        this.dt = dt;\n        this.inv_dt = dt == 0 ? 0 : 1 / dt;\n        this.dtRatio = dt * this.inv_dt0;\n      };\n      return TimeStep2;\n    }()\n  );\n  var s_subStep = new TimeStep();\n  var c = vec2(0, 0);\n  var v = vec2(0, 0);\n  var translation = vec2(0, 0);\n  var input = new TOIInput();\n  var output = new TOIOutput();\n  var backup = new Sweep();\n  var backup1 = new Sweep();\n  var backup2 = new Sweep();\n  var ContactImpulse = (\n    /** @class */\n    function() {\n      function ContactImpulse2(contact) {\n        this.contact = contact;\n        this.normals = [];\n        this.tangents = [];\n      }\n      ContactImpulse2.prototype.recycle = function() {\n        this.normals.length = 0;\n        this.tangents.length = 0;\n      };\n      Object.defineProperty(ContactImpulse2.prototype, \"normalImpulses\", {\n        get: function() {\n          var contact = this.contact;\n          var normals = this.normals;\n          normals.length = 0;\n          for (var p = 0; p < contact.v_points.length; ++p) {\n            normals.push(contact.v_points[p].normalImpulse);\n          }\n          return normals;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(ContactImpulse2.prototype, \"tangentImpulses\", {\n        get: function() {\n          var contact = this.contact;\n          var tangents = this.tangents;\n          tangents.length = 0;\n          for (var p = 0; p < contact.v_points.length; ++p) {\n            tangents.push(contact.v_points[p].tangentImpulse);\n          }\n          return tangents;\n        },\n        enumerable: false,\n        configurable: true\n      });\n      return ContactImpulse2;\n    }()\n  );\n  var Solver = (\n    /** @class */\n    function() {\n      function Solver2(world) {\n        this.m_world = world;\n        this.m_stack = [];\n        this.m_bodies = [];\n        this.m_contacts = [];\n        this.m_joints = [];\n      }\n      Solver2.prototype.clear = function() {\n        this.m_stack.length = 0;\n        this.m_bodies.length = 0;\n        this.m_contacts.length = 0;\n        this.m_joints.length = 0;\n      };\n      Solver2.prototype.addBody = function(body) {\n        this.m_bodies.push(body);\n      };\n      Solver2.prototype.addContact = function(contact) {\n        this.m_contacts.push(contact);\n      };\n      Solver2.prototype.addJoint = function(joint) {\n        this.m_joints.push(joint);\n      };\n      Solver2.prototype.solveWorld = function(step) {\n        var world = this.m_world;\n        for (var b2 = world.m_bodyList; b2; b2 = b2.m_next) {\n          b2.m_islandFlag = false;\n        }\n        for (var c_1 = world.m_contactList; c_1; c_1 = c_1.m_next) {\n          c_1.m_islandFlag = false;\n        }\n        for (var j = world.m_jointList; j; j = j.m_next) {\n          j.m_islandFlag = false;\n        }\n        var stack = this.m_stack;\n        for (var seed = world.m_bodyList; seed; seed = seed.m_next) {\n          if (seed.m_islandFlag) {\n            continue;\n          }\n          if (seed.isAwake() == false || seed.isActive() == false) {\n            continue;\n          }\n          if (seed.isStatic()) {\n            continue;\n          }\n          this.clear();\n          stack.push(seed);\n          seed.m_islandFlag = true;\n          while (stack.length > 0) {\n            var b2 = stack.pop();\n            this.addBody(b2);\n            b2.m_awakeFlag = true;\n            if (b2.isStatic()) {\n              continue;\n            }\n            for (var ce = b2.m_contactList; ce; ce = ce.next) {\n              var contact = ce.contact;\n              if (contact.m_islandFlag) {\n                continue;\n              }\n              if (contact.isEnabled() == false || contact.isTouching() == false) {\n                continue;\n              }\n              var sensorA = contact.m_fixtureA.m_isSensor;\n              var sensorB = contact.m_fixtureB.m_isSensor;\n              if (sensorA || sensorB) {\n                continue;\n              }\n              this.addContact(contact);\n              contact.m_islandFlag = true;\n              var other = ce.other;\n              if (other.m_islandFlag) {\n                continue;\n              }\n              stack.push(other);\n              other.m_islandFlag = true;\n            }\n            for (var je = b2.m_jointList; je; je = je.next) {\n              if (je.joint.m_islandFlag == true) {\n                continue;\n              }\n              var other = je.other;\n              if (other.isActive() == false) {\n                continue;\n              }\n              this.addJoint(je.joint);\n              je.joint.m_islandFlag = true;\n              if (other.m_islandFlag) {\n                continue;\n              }\n              stack.push(other);\n              other.m_islandFlag = true;\n            }\n          }\n          this.solveIsland(step);\n          for (var i = 0; i < this.m_bodies.length; ++i) {\n            var b2 = this.m_bodies[i];\n            if (b2.isStatic()) {\n              b2.m_islandFlag = false;\n            }\n          }\n        }\n      };\n      Solver2.prototype.solveIsland = function(step) {\n        var world = this.m_world;\n        var gravity = world.m_gravity;\n        var allowSleep = world.m_allowSleep;\n        var h = step.dt;\n        for (var i = 0; i < this.m_bodies.length; ++i) {\n          var body = this.m_bodies[i];\n          copyVec2(c, body.m_sweep.c);\n          var a2 = body.m_sweep.a;\n          copyVec2(v, body.m_linearVelocity);\n          var w = body.m_angularVelocity;\n          copyVec2(body.m_sweep.c0, body.m_sweep.c);\n          body.m_sweep.a0 = body.m_sweep.a;\n          if (body.isDynamic()) {\n            plusScaleVec2(v, h * body.m_gravityScale, gravity);\n            plusScaleVec2(v, h * body.m_invMass, body.m_force);\n            w += h * body.m_invI * body.m_torque;\n            scaleVec2(v, 1 / (1 + h * body.m_linearDamping), v);\n            w *= 1 / (1 + h * body.m_angularDamping);\n          }\n          copyVec2(body.c_position.c, c);\n          body.c_position.a = a2;\n          copyVec2(body.c_velocity.v, v);\n          body.c_velocity.w = w;\n        }\n        for (var i = 0; i < this.m_contacts.length; ++i) {\n          var contact = this.m_contacts[i];\n          contact.initConstraint(step);\n        }\n        for (var i = 0; i < this.m_contacts.length; ++i) {\n          var contact = this.m_contacts[i];\n          contact.initVelocityConstraint(step);\n        }\n        if (step.warmStarting) {\n          for (var i = 0; i < this.m_contacts.length; ++i) {\n            var contact = this.m_contacts[i];\n            contact.warmStartConstraint(step);\n          }\n        }\n        for (var i = 0; i < this.m_joints.length; ++i) {\n          var joint = this.m_joints[i];\n          joint.initVelocityConstraints(step);\n        }\n        for (var i = 0; i < step.velocityIterations; ++i) {\n          for (var j = 0; j < this.m_joints.length; ++j) {\n            var joint = this.m_joints[j];\n            joint.solveVelocityConstraints(step);\n          }\n          for (var j = 0; j < this.m_contacts.length; ++j) {\n            var contact = this.m_contacts[j];\n            contact.solveVelocityConstraint(step);\n          }\n        }\n        for (var i = 0; i < this.m_contacts.length; ++i) {\n          var contact = this.m_contacts[i];\n          contact.storeConstraintImpulses(step);\n        }\n        for (var i = 0; i < this.m_bodies.length; ++i) {\n          var body = this.m_bodies[i];\n          copyVec2(c, body.c_position.c);\n          var a2 = body.c_position.a;\n          copyVec2(v, body.c_velocity.v);\n          var w = body.c_velocity.w;\n          scaleVec2(translation, h, v);\n          var translationLengthSqr = lengthSqrVec2(translation);\n          if (translationLengthSqr > SettingsInternal.maxTranslationSquared) {\n            var ratio = SettingsInternal.maxTranslation / math_sqrt$3(translationLengthSqr);\n            mulVec2(v, ratio);\n          }\n          var rotation2 = h * w;\n          if (rotation2 * rotation2 > SettingsInternal.maxRotationSquared) {\n            var ratio = SettingsInternal.maxRotation / math_abs$6(rotation2);\n            w *= ratio;\n          }\n          plusScaleVec2(c, h, v);\n          a2 += h * w;\n          copyVec2(body.c_position.c, c);\n          body.c_position.a = a2;\n          copyVec2(body.c_velocity.v, v);\n          body.c_velocity.w = w;\n        }\n        var positionSolved = false;\n        for (var i = 0; i < step.positionIterations; ++i) {\n          var minSeparation = 0;\n          for (var j = 0; j < this.m_contacts.length; ++j) {\n            var contact = this.m_contacts[j];\n            var separation = contact.solvePositionConstraint(step);\n            minSeparation = math_min$5(minSeparation, separation);\n          }\n          var contactsOkay = minSeparation >= -3 * SettingsInternal.linearSlop;\n          var jointsOkay = true;\n          for (var j = 0; j < this.m_joints.length; ++j) {\n            var joint = this.m_joints[j];\n            var jointOkay = joint.solvePositionConstraints(step);\n            jointsOkay = jointsOkay && jointOkay;\n          }\n          if (contactsOkay && jointsOkay) {\n            positionSolved = true;\n            break;\n          }\n        }\n        for (var i = 0; i < this.m_bodies.length; ++i) {\n          var body = this.m_bodies[i];\n          copyVec2(body.m_sweep.c, body.c_position.c);\n          body.m_sweep.a = body.c_position.a;\n          copyVec2(body.m_linearVelocity, body.c_velocity.v);\n          body.m_angularVelocity = body.c_velocity.w;\n          body.synchronizeTransform();\n        }\n        this.postSolveIsland();\n        if (allowSleep) {\n          var minSleepTime = Infinity;\n          var linTolSqr = SettingsInternal.linearSleepToleranceSqr;\n          var angTolSqr = SettingsInternal.angularSleepToleranceSqr;\n          for (var i = 0; i < this.m_bodies.length; ++i) {\n            var body = this.m_bodies[i];\n            if (body.isStatic()) {\n              continue;\n            }\n            if (body.m_autoSleepFlag == false || body.m_angularVelocity * body.m_angularVelocity > angTolSqr || lengthSqrVec2(body.m_linearVelocity) > linTolSqr) {\n              body.m_sleepTime = 0;\n              minSleepTime = 0;\n            } else {\n              body.m_sleepTime += h;\n              minSleepTime = math_min$5(minSleepTime, body.m_sleepTime);\n            }\n          }\n          if (minSleepTime >= SettingsInternal.timeToSleep && positionSolved) {\n            for (var i = 0; i < this.m_bodies.length; ++i) {\n              var body = this.m_bodies[i];\n              body.setAwake(false);\n            }\n          }\n        }\n      };\n      Solver2.prototype.solveWorldTOI = function(step) {\n        var world = this.m_world;\n        if (world.m_stepComplete) {\n          for (var b2 = world.m_bodyList; b2; b2 = b2.m_next) {\n            b2.m_islandFlag = false;\n            b2.m_sweep.alpha0 = 0;\n          }\n          for (var c_2 = world.m_contactList; c_2; c_2 = c_2.m_next) {\n            c_2.m_toiFlag = false;\n            c_2.m_islandFlag = false;\n            c_2.m_toiCount = 0;\n            c_2.m_toi = 1;\n          }\n        }\n        while (true) {\n          var minContact = null;\n          var minAlpha = 1;\n          for (var c_3 = world.m_contactList; c_3; c_3 = c_3.m_next) {\n            if (c_3.isEnabled() == false) {\n              continue;\n            }\n            if (c_3.m_toiCount > SettingsInternal.maxSubSteps) {\n              continue;\n            }\n            var alpha = 1;\n            if (c_3.m_toiFlag) {\n              alpha = c_3.m_toi;\n            } else {\n              var fA_1 = c_3.getFixtureA();\n              var fB_1 = c_3.getFixtureB();\n              if (fA_1.isSensor() || fB_1.isSensor()) {\n                continue;\n              }\n              var bA_1 = fA_1.getBody();\n              var bB_1 = fB_1.getBody();\n              var activeA = bA_1.isAwake() && !bA_1.isStatic();\n              var activeB = bB_1.isAwake() && !bB_1.isStatic();\n              if (activeA == false && activeB == false) {\n                continue;\n              }\n              var collideA = bA_1.isBullet() || !bA_1.isDynamic();\n              var collideB = bB_1.isBullet() || !bB_1.isDynamic();\n              if (collideA == false && collideB == false) {\n                continue;\n              }\n              var alpha0 = bA_1.m_sweep.alpha0;\n              if (bA_1.m_sweep.alpha0 < bB_1.m_sweep.alpha0) {\n                alpha0 = bB_1.m_sweep.alpha0;\n                bA_1.m_sweep.advance(alpha0);\n              } else if (bB_1.m_sweep.alpha0 < bA_1.m_sweep.alpha0) {\n                alpha0 = bA_1.m_sweep.alpha0;\n                bB_1.m_sweep.advance(alpha0);\n              }\n              var indexA = c_3.getChildIndexA();\n              var indexB = c_3.getChildIndexB();\n              bA_1.m_sweep;\n              bB_1.m_sweep;\n              input.proxyA.set(fA_1.getShape(), indexA);\n              input.proxyB.set(fB_1.getShape(), indexB);\n              input.sweepA.set(bA_1.m_sweep);\n              input.sweepB.set(bB_1.m_sweep);\n              input.tMax = 1;\n              TimeOfImpact(output, input);\n              var beta = output.t;\n              if (output.state == exports2.TOIOutputState.e_touching) {\n                alpha = math_min$5(alpha0 + (1 - alpha0) * beta, 1);\n              } else {\n                alpha = 1;\n              }\n              c_3.m_toi = alpha;\n              c_3.m_toiFlag = true;\n            }\n            if (alpha < minAlpha) {\n              minContact = c_3;\n              minAlpha = alpha;\n            }\n          }\n          if (minContact == null || 1 - 10 * EPSILON < minAlpha) {\n            world.m_stepComplete = true;\n            break;\n          }\n          var fA = minContact.getFixtureA();\n          var fB = minContact.getFixtureB();\n          var bA = fA.getBody();\n          var bB = fB.getBody();\n          backup1.set(bA.m_sweep);\n          backup2.set(bB.m_sweep);\n          bA.advance(minAlpha);\n          bB.advance(minAlpha);\n          minContact.update(world);\n          minContact.m_toiFlag = false;\n          ++minContact.m_toiCount;\n          if (minContact.isEnabled() == false || minContact.isTouching() == false) {\n            minContact.setEnabled(false);\n            bA.m_sweep.set(backup1);\n            bB.m_sweep.set(backup2);\n            bA.synchronizeTransform();\n            bB.synchronizeTransform();\n            continue;\n          }\n          bA.setAwake(true);\n          bB.setAwake(true);\n          this.clear();\n          this.addBody(bA);\n          this.addBody(bB);\n          this.addContact(minContact);\n          bA.m_islandFlag = true;\n          bB.m_islandFlag = true;\n          minContact.m_islandFlag = true;\n          var bodies = [bA, bB];\n          for (var i = 0; i < bodies.length; ++i) {\n            var body = bodies[i];\n            if (body.isDynamic()) {\n              for (var ce = body.m_contactList; ce; ce = ce.next) {\n                var contact = ce.contact;\n                if (contact.m_islandFlag) {\n                  continue;\n                }\n                var other = ce.other;\n                if (other.isDynamic() && !body.isBullet() && !other.isBullet()) {\n                  continue;\n                }\n                var sensorA = contact.m_fixtureA.m_isSensor;\n                var sensorB = contact.m_fixtureB.m_isSensor;\n                if (sensorA || sensorB) {\n                  continue;\n                }\n                backup.set(other.m_sweep);\n                if (other.m_islandFlag == false) {\n                  other.advance(minAlpha);\n                }\n                contact.update(world);\n                if (contact.isEnabled() == false || contact.isTouching() == false) {\n                  other.m_sweep.set(backup);\n                  other.synchronizeTransform();\n                  continue;\n                }\n                contact.m_islandFlag = true;\n                this.addContact(contact);\n                if (other.m_islandFlag) {\n                  continue;\n                }\n                other.m_islandFlag = true;\n                if (!other.isStatic()) {\n                  other.setAwake(true);\n                }\n                this.addBody(other);\n              }\n            }\n          }\n          s_subStep.reset((1 - minAlpha) * step.dt);\n          s_subStep.dtRatio = 1;\n          s_subStep.positionIterations = 20;\n          s_subStep.velocityIterations = step.velocityIterations;\n          s_subStep.warmStarting = false;\n          this.solveIslandTOI(s_subStep, bA, bB);\n          for (var i = 0; i < this.m_bodies.length; ++i) {\n            var body = this.m_bodies[i];\n            body.m_islandFlag = false;\n            if (!body.isDynamic()) {\n              continue;\n            }\n            body.synchronizeFixtures();\n            for (var ce = body.m_contactList; ce; ce = ce.next) {\n              ce.contact.m_toiFlag = false;\n              ce.contact.m_islandFlag = false;\n            }\n          }\n          world.findNewContacts();\n          if (world.m_subStepping) {\n            world.m_stepComplete = false;\n            break;\n          }\n        }\n      };\n      Solver2.prototype.solveIslandTOI = function(subStep, toiA, toiB) {\n        for (var i = 0; i < this.m_bodies.length; ++i) {\n          var body = this.m_bodies[i];\n          copyVec2(body.c_position.c, body.m_sweep.c);\n          body.c_position.a = body.m_sweep.a;\n          copyVec2(body.c_velocity.v, body.m_linearVelocity);\n          body.c_velocity.w = body.m_angularVelocity;\n        }\n        for (var i = 0; i < this.m_contacts.length; ++i) {\n          var contact = this.m_contacts[i];\n          contact.initConstraint(subStep);\n        }\n        for (var i = 0; i < subStep.positionIterations; ++i) {\n          var minSeparation = 0;\n          for (var j = 0; j < this.m_contacts.length; ++j) {\n            var contact = this.m_contacts[j];\n            var separation = contact.solvePositionConstraintTOI(subStep, toiA, toiB);\n            minSeparation = math_min$5(minSeparation, separation);\n          }\n          var contactsOkay = minSeparation >= -1.5 * SettingsInternal.linearSlop;\n          if (contactsOkay) {\n            break;\n          }\n        }\n        var i;\n        copyVec2(toiA.m_sweep.c0, toiA.c_position.c);\n        toiA.m_sweep.a0 = toiA.c_position.a;\n        copyVec2(toiB.m_sweep.c0, toiB.c_position.c);\n        toiB.m_sweep.a0 = toiB.c_position.a;\n        for (var i = 0; i < this.m_contacts.length; ++i) {\n          var contact = this.m_contacts[i];\n          contact.initVelocityConstraint(subStep);\n        }\n        for (var i = 0; i < subStep.velocityIterations; ++i) {\n          for (var j = 0; j < this.m_contacts.length; ++j) {\n            var contact = this.m_contacts[j];\n            contact.solveVelocityConstraint(subStep);\n          }\n        }\n        var h = subStep.dt;\n        for (var i = 0; i < this.m_bodies.length; ++i) {\n          var body = this.m_bodies[i];\n          copyVec2(c, body.c_position.c);\n          var a2 = body.c_position.a;\n          copyVec2(v, body.c_velocity.v);\n          var w = body.c_velocity.w;\n          scaleVec2(translation, h, v);\n          var translationLengthSqr = lengthSqrVec2(translation);\n          if (translationLengthSqr > SettingsInternal.maxTranslationSquared) {\n            var ratio = SettingsInternal.maxTranslation / math_sqrt$3(translationLengthSqr);\n            mulVec2(v, ratio);\n          }\n          var rotation2 = h * w;\n          if (rotation2 * rotation2 > SettingsInternal.maxRotationSquared) {\n            var ratio = SettingsInternal.maxRotation / math_abs$6(rotation2);\n            w *= ratio;\n          }\n          plusScaleVec2(c, h, v);\n          a2 += h * w;\n          copyVec2(body.c_position.c, c);\n          body.c_position.a = a2;\n          copyVec2(body.c_velocity.v, v);\n          body.c_velocity.w = w;\n          copyVec2(body.m_sweep.c, c);\n          body.m_sweep.a = a2;\n          copyVec2(body.m_linearVelocity, v);\n          body.m_angularVelocity = w;\n          body.synchronizeTransform();\n        }\n        this.postSolveIsland();\n      };\n      Solver2.prototype.postSolveIsland = function() {\n        for (var c_5 = 0; c_5 < this.m_contacts.length; ++c_5) {\n          var contact = this.m_contacts[c_5];\n          this.m_world.postSolve(contact, contact.m_impulse);\n        }\n      };\n      return Solver2;\n    }()\n  );\n  Solver.TimeStep = TimeStep;\n  var Mat22 = (\n    /** @class */\n    function() {\n      function Mat222(a2, b2, c2, d2) {\n        if (typeof a2 === \"object\" && a2 !== null) {\n          this.ex = Vec2.clone(a2);\n          this.ey = Vec2.clone(b2);\n        } else if (typeof a2 === \"number\") {\n          this.ex = Vec2.neo(a2, c2);\n          this.ey = Vec2.neo(b2, d2);\n        } else {\n          this.ex = Vec2.zero();\n          this.ey = Vec2.zero();\n        }\n      }\n      Mat222.prototype.toString = function() {\n        return JSON.stringify(this);\n      };\n      Mat222.isValid = function(obj) {\n        if (obj === null || typeof obj === \"undefined\") {\n          return false;\n        }\n        return Vec2.isValid(obj.ex) && Vec2.isValid(obj.ey);\n      };\n      Mat222.assert = function(o) {\n      };\n      Mat222.prototype.set = function(a2, b2, c2, d2) {\n        if (typeof a2 === \"number\" && typeof b2 === \"number\" && typeof c2 === \"number\" && typeof d2 === \"number\") {\n          this.ex.setNum(a2, c2);\n          this.ey.setNum(b2, d2);\n        } else if (typeof a2 === \"object\" && typeof b2 === \"object\") {\n          this.ex.setVec2(a2);\n          this.ey.setVec2(b2);\n        } else if (typeof a2 === \"object\") {\n          this.ex.setVec2(a2.ex);\n          this.ey.setVec2(a2.ey);\n        } else ;\n      };\n      Mat222.prototype.setIdentity = function() {\n        this.ex.x = 1;\n        this.ey.x = 0;\n        this.ex.y = 0;\n        this.ey.y = 1;\n      };\n      Mat222.prototype.setZero = function() {\n        this.ex.x = 0;\n        this.ey.x = 0;\n        this.ex.y = 0;\n        this.ey.y = 0;\n      };\n      Mat222.prototype.getInverse = function() {\n        var a2 = this.ex.x;\n        var b2 = this.ey.x;\n        var c2 = this.ex.y;\n        var d2 = this.ey.y;\n        var det = a2 * d2 - b2 * c2;\n        if (det !== 0) {\n          det = 1 / det;\n        }\n        var imx = new Mat222();\n        imx.ex.x = det * d2;\n        imx.ey.x = -det * b2;\n        imx.ex.y = -det * c2;\n        imx.ey.y = det * a2;\n        return imx;\n      };\n      Mat222.prototype.solve = function(v3) {\n        var a2 = this.ex.x;\n        var b2 = this.ey.x;\n        var c2 = this.ex.y;\n        var d2 = this.ey.y;\n        var det = a2 * d2 - b2 * c2;\n        if (det !== 0) {\n          det = 1 / det;\n        }\n        var w = Vec2.zero();\n        w.x = det * (d2 * v3.x - b2 * v3.y);\n        w.y = det * (a2 * v3.y - c2 * v3.x);\n        return w;\n      };\n      Mat222.mul = function(mx, v3) {\n        if (v3 && \"x\" in v3 && \"y\" in v3) {\n          var x2 = mx.ex.x * v3.x + mx.ey.x * v3.y;\n          var y = mx.ex.y * v3.x + mx.ey.y * v3.y;\n          return Vec2.neo(x2, y);\n        } else if (v3 && \"ex\" in v3 && \"ey\" in v3) {\n          var a2 = mx.ex.x * v3.ex.x + mx.ey.x * v3.ex.y;\n          var b2 = mx.ex.x * v3.ey.x + mx.ey.x * v3.ey.y;\n          var c2 = mx.ex.y * v3.ex.x + mx.ey.y * v3.ex.y;\n          var d2 = mx.ex.y * v3.ey.x + mx.ey.y * v3.ey.y;\n          return new Mat222(a2, b2, c2, d2);\n        }\n      };\n      Mat222.mulVec2 = function(mx, v3) {\n        var x2 = mx.ex.x * v3.x + mx.ey.x * v3.y;\n        var y = mx.ex.y * v3.x + mx.ey.y * v3.y;\n        return Vec2.neo(x2, y);\n      };\n      Mat222.mulMat22 = function(mx, v3) {\n        var a2 = mx.ex.x * v3.ex.x + mx.ey.x * v3.ex.y;\n        var b2 = mx.ex.x * v3.ey.x + mx.ey.x * v3.ey.y;\n        var c2 = mx.ex.y * v3.ex.x + mx.ey.y * v3.ex.y;\n        var d2 = mx.ex.y * v3.ey.x + mx.ey.y * v3.ey.y;\n        return new Mat222(a2, b2, c2, d2);\n      };\n      Mat222.mulT = function(mx, v3) {\n        if (v3 && \"x\" in v3 && \"y\" in v3) {\n          return Vec2.neo(Vec2.dot(v3, mx.ex), Vec2.dot(v3, mx.ey));\n        } else if (v3 && \"ex\" in v3 && \"ey\" in v3) {\n          var c1 = Vec2.neo(Vec2.dot(mx.ex, v3.ex), Vec2.dot(mx.ey, v3.ex));\n          var c2 = Vec2.neo(Vec2.dot(mx.ex, v3.ey), Vec2.dot(mx.ey, v3.ey));\n          return new Mat222(c1, c2);\n        }\n      };\n      Mat222.mulTVec2 = function(mx, v3) {\n        return Vec2.neo(Vec2.dot(v3, mx.ex), Vec2.dot(v3, mx.ey));\n      };\n      Mat222.mulTMat22 = function(mx, v3) {\n        var c1 = Vec2.neo(Vec2.dot(mx.ex, v3.ex), Vec2.dot(mx.ey, v3.ex));\n        var c2 = Vec2.neo(Vec2.dot(mx.ex, v3.ey), Vec2.dot(mx.ey, v3.ey));\n        return new Mat222(c1, c2);\n      };\n      Mat222.abs = function(mx) {\n        return new Mat222(Vec2.abs(mx.ex), Vec2.abs(mx.ey));\n      };\n      Mat222.add = function(mx1, mx2) {\n        return new Mat222(Vec2.add(mx1.ex, mx2.ex), Vec2.add(mx1.ey, mx2.ey));\n      };\n      return Mat222;\n    }()\n  );\n  var math_sqrt$2 = Math.sqrt;\n  var pointA$1 = vec2(0, 0);\n  var pointB$1 = vec2(0, 0);\n  var temp$3 = vec2(0, 0);\n  var cA$1 = vec2(0, 0);\n  var cB$1 = vec2(0, 0);\n  var dist = vec2(0, 0);\n  var planePoint$2 = vec2(0, 0);\n  var clipPoint$1 = vec2(0, 0);\n  exports2.ManifoldType = void 0;\n  (function(ManifoldType2) {\n    ManifoldType2[ManifoldType2[\"e_unset\"] = -1] = \"e_unset\";\n    ManifoldType2[ManifoldType2[\"e_circles\"] = 0] = \"e_circles\";\n    ManifoldType2[ManifoldType2[\"e_faceA\"] = 1] = \"e_faceA\";\n    ManifoldType2[ManifoldType2[\"e_faceB\"] = 2] = \"e_faceB\";\n  })(exports2.ManifoldType || (exports2.ManifoldType = {}));\n  exports2.ContactFeatureType = void 0;\n  (function(ContactFeatureType2) {\n    ContactFeatureType2[ContactFeatureType2[\"e_unset\"] = -1] = \"e_unset\";\n    ContactFeatureType2[ContactFeatureType2[\"e_vertex\"] = 0] = \"e_vertex\";\n    ContactFeatureType2[ContactFeatureType2[\"e_face\"] = 1] = \"e_face\";\n  })(exports2.ContactFeatureType || (exports2.ContactFeatureType = {}));\n  exports2.PointState = void 0;\n  (function(PointState2) {\n    PointState2[PointState2[\"nullState\"] = 0] = \"nullState\";\n    PointState2[PointState2[\"addState\"] = 1] = \"addState\";\n    PointState2[PointState2[\"persistState\"] = 2] = \"persistState\";\n    PointState2[PointState2[\"removeState\"] = 3] = \"removeState\";\n  })(exports2.PointState || (exports2.PointState = {}));\n  var ClipVertex = (\n    /** @class */\n    function() {\n      function ClipVertex2() {\n        this.v = vec2(0, 0);\n        this.id = new ContactID();\n      }\n      ClipVertex2.prototype.set = function(o) {\n        copyVec2(this.v, o.v);\n        this.id.set(o.id);\n      };\n      ClipVertex2.prototype.recycle = function() {\n        zeroVec2(this.v);\n        this.id.recycle();\n      };\n      return ClipVertex2;\n    }()\n  );\n  var Manifold = (\n    /** @class */\n    function() {\n      function Manifold2() {\n        this.localNormal = vec2(0, 0);\n        this.localPoint = vec2(0, 0);\n        this.points = [new ManifoldPoint(), new ManifoldPoint()];\n        this.pointCount = 0;\n      }\n      Manifold2.prototype.set = function(that) {\n        this.type = that.type;\n        copyVec2(this.localNormal, that.localNormal);\n        copyVec2(this.localPoint, that.localPoint);\n        this.pointCount = that.pointCount;\n        this.points[0].set(that.points[0]);\n        this.points[1].set(that.points[1]);\n      };\n      Manifold2.prototype.recycle = function() {\n        this.type = exports2.ManifoldType.e_unset;\n        zeroVec2(this.localNormal);\n        zeroVec2(this.localPoint);\n        this.pointCount = 0;\n        this.points[0].recycle();\n        this.points[1].recycle();\n      };\n      Manifold2.prototype.getWorldManifold = function(wm, xfA2, radiusA, xfB2, radiusB) {\n        if (this.pointCount == 0) {\n          return wm;\n        }\n        wm = wm || new WorldManifold();\n        wm.pointCount = this.pointCount;\n        var normal3 = wm.normal;\n        var points = wm.points;\n        var separations = wm.separations;\n        switch (this.type) {\n          case exports2.ManifoldType.e_circles: {\n            setVec2(normal3, 1, 0);\n            var manifoldPoint = this.points[0];\n            transformVec2(pointA$1, xfA2, this.localPoint);\n            transformVec2(pointB$1, xfB2, manifoldPoint.localPoint);\n            subVec2(dist, pointB$1, pointA$1);\n            var lengthSqr = lengthSqrVec2(dist);\n            if (lengthSqr > EPSILON * EPSILON) {\n              var length_1 = math_sqrt$2(lengthSqr);\n              scaleVec2(normal3, 1 / length_1, dist);\n            }\n            combine2Vec2(cA$1, 1, pointA$1, radiusA, normal3);\n            combine2Vec2(cB$1, 1, pointB$1, -radiusB, normal3);\n            combine2Vec2(points[0], 0.5, cA$1, 0.5, cB$1);\n            separations[0] = dotVec2(subVec2(temp$3, cB$1, cA$1), normal3);\n            break;\n          }\n          case exports2.ManifoldType.e_faceA: {\n            rotVec2(normal3, xfA2.q, this.localNormal);\n            transformVec2(planePoint$2, xfA2, this.localPoint);\n            for (var i = 0; i < this.pointCount; ++i) {\n              var manifoldPoint = this.points[i];\n              transformVec2(clipPoint$1, xfB2, manifoldPoint.localPoint);\n              combine2Vec2(cA$1, 1, clipPoint$1, radiusA - dotVec2(subVec2(temp$3, clipPoint$1, planePoint$2), normal3), normal3);\n              combine2Vec2(cB$1, 1, clipPoint$1, -radiusB, normal3);\n              combine2Vec2(points[i], 0.5, cA$1, 0.5, cB$1);\n              separations[i] = dotVec2(subVec2(temp$3, cB$1, cA$1), normal3);\n            }\n            break;\n          }\n          case exports2.ManifoldType.e_faceB: {\n            rotVec2(normal3, xfB2.q, this.localNormal);\n            transformVec2(planePoint$2, xfB2, this.localPoint);\n            for (var i = 0; i < this.pointCount; ++i) {\n              var manifoldPoint = this.points[i];\n              transformVec2(clipPoint$1, xfA2, manifoldPoint.localPoint);\n              combine2Vec2(cB$1, 1, clipPoint$1, radiusB - dotVec2(subVec2(temp$3, clipPoint$1, planePoint$2), normal3), normal3);\n              combine2Vec2(cA$1, 1, clipPoint$1, -radiusA, normal3);\n              combine2Vec2(points[i], 0.5, cA$1, 0.5, cB$1);\n              separations[i] = dotVec2(subVec2(temp$3, cA$1, cB$1), normal3);\n            }\n            negVec2(normal3);\n            break;\n          }\n        }\n        return wm;\n      };\n      Manifold2.clipSegmentToLine = clipSegmentToLine;\n      Manifold2.ClipVertex = ClipVertex;\n      Manifold2.getPointStates = getPointStates;\n      Manifold2.PointState = exports2.PointState;\n      return Manifold2;\n    }()\n  );\n  var ManifoldPoint = (\n    /** @class */\n    function() {\n      function ManifoldPoint2() {\n        this.localPoint = vec2(0, 0);\n        this.normalImpulse = 0;\n        this.tangentImpulse = 0;\n        this.id = new ContactID();\n      }\n      ManifoldPoint2.prototype.set = function(that) {\n        copyVec2(this.localPoint, that.localPoint);\n        this.normalImpulse = that.normalImpulse;\n        this.tangentImpulse = that.tangentImpulse;\n        this.id.set(that.id);\n      };\n      ManifoldPoint2.prototype.recycle = function() {\n        zeroVec2(this.localPoint);\n        this.normalImpulse = 0;\n        this.tangentImpulse = 0;\n        this.id.recycle();\n      };\n      return ManifoldPoint2;\n    }()\n  );\n  var ContactID = (\n    /** @class */\n    function() {\n      function ContactID2() {\n        this.key = -1;\n        this.indexA = -1;\n        this.indexB = -1;\n        this.typeA = exports2.ContactFeatureType.e_unset;\n        this.typeB = exports2.ContactFeatureType.e_unset;\n      }\n      ContactID2.prototype.setFeatures = function(indexA, typeA, indexB, typeB) {\n        this.indexA = indexA;\n        this.indexB = indexB;\n        this.typeA = typeA;\n        this.typeB = typeB;\n        this.key = this.indexA + this.indexB * 4 + this.typeA * 16 + this.typeB * 64;\n      };\n      ContactID2.prototype.set = function(that) {\n        this.indexA = that.indexA;\n        this.indexB = that.indexB;\n        this.typeA = that.typeA;\n        this.typeB = that.typeB;\n        this.key = this.indexA + this.indexB * 4 + this.typeA * 16 + this.typeB * 64;\n      };\n      ContactID2.prototype.swapFeatures = function() {\n        var indexA = this.indexA;\n        var indexB = this.indexB;\n        var typeA = this.typeA;\n        var typeB = this.typeB;\n        this.indexA = indexB;\n        this.indexB = indexA;\n        this.typeA = typeB;\n        this.typeB = typeA;\n        this.key = this.indexA + this.indexB * 4 + this.typeA * 16 + this.typeB * 64;\n      };\n      ContactID2.prototype.recycle = function() {\n        this.indexA = 0;\n        this.indexB = 0;\n        this.typeA = exports2.ContactFeatureType.e_unset;\n        this.typeB = exports2.ContactFeatureType.e_unset;\n        this.key = -1;\n      };\n      return ContactID2;\n    }()\n  );\n  var WorldManifold = (\n    /** @class */\n    function() {\n      function WorldManifold2() {\n        this.normal = vec2(0, 0);\n        this.points = [vec2(0, 0), vec2(0, 0)];\n        this.separations = [0, 0];\n        this.pointCount = 0;\n      }\n      WorldManifold2.prototype.recycle = function() {\n        zeroVec2(this.normal);\n        zeroVec2(this.points[0]);\n        zeroVec2(this.points[1]);\n        this.separations[0] = 0;\n        this.separations[1] = 0;\n        this.pointCount = 0;\n      };\n      return WorldManifold2;\n    }()\n  );\n  function getPointStates(state1, state2, manifold1, manifold2) {\n    for (var i = 0; i < manifold1.pointCount; ++i) {\n      var id = manifold1.points[i].id;\n      state1[i] = exports2.PointState.removeState;\n      for (var j = 0; j < manifold2.pointCount; ++j) {\n        if (manifold2.points[j].id.key === id.key) {\n          state1[i] = exports2.PointState.persistState;\n          break;\n        }\n      }\n    }\n    for (var i = 0; i < manifold2.pointCount; ++i) {\n      var id = manifold2.points[i].id;\n      state2[i] = exports2.PointState.addState;\n      for (var j = 0; j < manifold1.pointCount; ++j) {\n        if (manifold1.points[j].id.key === id.key) {\n          state2[i] = exports2.PointState.persistState;\n          break;\n        }\n      }\n    }\n  }\n  function clipSegmentToLine(vOut, vIn, normal3, offset, vertexIndexA) {\n    var numOut = 0;\n    var distance0 = dotVec2(normal3, vIn[0].v) - offset;\n    var distance1 = dotVec2(normal3, vIn[1].v) - offset;\n    if (distance0 <= 0)\n      vOut[numOut++].set(vIn[0]);\n    if (distance1 <= 0)\n      vOut[numOut++].set(vIn[1]);\n    if (distance0 * distance1 < 0) {\n      var interp = distance0 / (distance0 - distance1);\n      combine2Vec2(vOut[numOut].v, 1 - interp, vIn[0].v, interp, vIn[1].v);\n      vOut[numOut].id.setFeatures(vertexIndexA, exports2.ContactFeatureType.e_vertex, vIn[0].id.indexB, exports2.ContactFeatureType.e_face);\n      ++numOut;\n    }\n    return numOut;\n  }\n  var math_sqrt$1 = Math.sqrt;\n  var math_max$2 = Math.max;\n  var math_min$4 = Math.min;\n  var contactPool = new Pool({\n    create: function() {\n      return new Contact();\n    },\n    release: function(contact) {\n      contact.recycle();\n    }\n  });\n  var oldManifold = new Manifold();\n  var worldManifold = new WorldManifold();\n  var ContactEdge = (\n    /** @class */\n    function() {\n      function ContactEdge2(contact) {\n        this.prev = null;\n        this.next = null;\n        this.other = null;\n        this.contact = contact;\n      }\n      ContactEdge2.prototype.recycle = function() {\n        this.prev = null;\n        this.next = null;\n        this.other = null;\n      };\n      return ContactEdge2;\n    }()\n  );\n  function mixFriction(friction1, friction2) {\n    return math_sqrt$1(friction1 * friction2);\n  }\n  function mixRestitution(restitution1, restitution2) {\n    return restitution1 > restitution2 ? restitution1 : restitution2;\n  }\n  var s_registers = [];\n  var VelocityConstraintPoint = (\n    /** @class */\n    function() {\n      function VelocityConstraintPoint2() {\n        this.rA = vec2(0, 0);\n        this.rB = vec2(0, 0);\n        this.normalImpulse = 0;\n        this.tangentImpulse = 0;\n        this.normalMass = 0;\n        this.tangentMass = 0;\n        this.velocityBias = 0;\n      }\n      VelocityConstraintPoint2.prototype.recycle = function() {\n        zeroVec2(this.rA);\n        zeroVec2(this.rB);\n        this.normalImpulse = 0;\n        this.tangentImpulse = 0;\n        this.normalMass = 0;\n        this.tangentMass = 0;\n        this.velocityBias = 0;\n      };\n      return VelocityConstraintPoint2;\n    }()\n  );\n  var cA = vec2(0, 0);\n  var vA = vec2(0, 0);\n  var cB = vec2(0, 0);\n  var vB = vec2(0, 0);\n  var tangent$1 = vec2(0, 0);\n  var xfA = transform(0, 0, 0);\n  var xfB = transform(0, 0, 0);\n  var pointA = vec2(0, 0);\n  var pointB = vec2(0, 0);\n  var clipPoint = vec2(0, 0);\n  var planePoint$1 = vec2(0, 0);\n  var rA = vec2(0, 0);\n  var rB = vec2(0, 0);\n  var P$1 = vec2(0, 0);\n  var normal$2 = vec2(0, 0);\n  var point = vec2(0, 0);\n  var dv = vec2(0, 0);\n  var dv1 = vec2(0, 0);\n  var dv2 = vec2(0, 0);\n  var b = vec2(0, 0);\n  var a = vec2(0, 0);\n  var x = vec2(0, 0);\n  var d = vec2(0, 0);\n  var P1 = vec2(0, 0);\n  var P2 = vec2(0, 0);\n  var temp$2 = vec2(0, 0);\n  var Contact = (\n    /** @class */\n    function() {\n      function Contact2() {\n        this.m_nodeA = new ContactEdge(this);\n        this.m_nodeB = new ContactEdge(this);\n        this.m_fixtureA = null;\n        this.m_fixtureB = null;\n        this.m_indexA = -1;\n        this.m_indexB = -1;\n        this.m_evaluateFcn = null;\n        this.m_manifold = new Manifold();\n        this.m_prev = null;\n        this.m_next = null;\n        this.m_toi = 1;\n        this.m_toiCount = 0;\n        this.m_toiFlag = false;\n        this.m_friction = 0;\n        this.m_restitution = 0;\n        this.m_tangentSpeed = 0;\n        this.m_enabledFlag = true;\n        this.m_islandFlag = false;\n        this.m_touchingFlag = false;\n        this.m_filterFlag = false;\n        this.m_bulletHitFlag = false;\n        this.m_impulse = new ContactImpulse(this);\n        this.v_points = [new VelocityConstraintPoint(), new VelocityConstraintPoint()];\n        this.v_normal = vec2(0, 0);\n        this.v_normalMass = new Mat22();\n        this.v_K = new Mat22();\n        this.v_pointCount = 0;\n        this.v_tangentSpeed = 0;\n        this.v_friction = 0;\n        this.v_restitution = 0;\n        this.v_invMassA = 0;\n        this.v_invMassB = 0;\n        this.v_invIA = 0;\n        this.v_invIB = 0;\n        this.p_localPoints = [vec2(0, 0), vec2(0, 0)];\n        this.p_localNormal = vec2(0, 0);\n        this.p_localPoint = vec2(0, 0);\n        this.p_localCenterA = vec2(0, 0);\n        this.p_localCenterB = vec2(0, 0);\n        this.p_type = exports2.ManifoldType.e_unset;\n        this.p_radiusA = 0;\n        this.p_radiusB = 0;\n        this.p_pointCount = 0;\n        this.p_invMassA = 0;\n        this.p_invMassB = 0;\n        this.p_invIA = 0;\n        this.p_invIB = 0;\n      }\n      Contact2.prototype.initialize = function(fA, indexA, fB, indexB, evaluateFcn) {\n        this.m_fixtureA = fA;\n        this.m_fixtureB = fB;\n        this.m_indexA = indexA;\n        this.m_indexB = indexB;\n        this.m_evaluateFcn = evaluateFcn;\n        this.m_friction = mixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);\n        this.m_restitution = mixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);\n      };\n      Contact2.prototype.recycle = function() {\n        this.m_nodeA.recycle();\n        this.m_nodeB.recycle();\n        this.m_fixtureA = null;\n        this.m_fixtureB = null;\n        this.m_indexA = -1;\n        this.m_indexB = -1;\n        this.m_evaluateFcn = null;\n        this.m_manifold.recycle();\n        this.m_prev = null;\n        this.m_next = null;\n        this.m_toi = 1;\n        this.m_toiCount = 0;\n        this.m_toiFlag = false;\n        this.m_friction = 0;\n        this.m_restitution = 0;\n        this.m_tangentSpeed = 0;\n        this.m_enabledFlag = true;\n        this.m_islandFlag = false;\n        this.m_touchingFlag = false;\n        this.m_filterFlag = false;\n        this.m_bulletHitFlag = false;\n        this.m_impulse.recycle();\n        for (var _i = 0, _a2 = this.v_points; _i < _a2.length; _i++) {\n          var point_1 = _a2[_i];\n          point_1.recycle();\n        }\n        zeroVec2(this.v_normal);\n        this.v_normalMass.setZero();\n        this.v_K.setZero();\n        this.v_pointCount = 0;\n        this.v_tangentSpeed = 0;\n        this.v_friction = 0;\n        this.v_restitution = 0;\n        this.v_invMassA = 0;\n        this.v_invMassB = 0;\n        this.v_invIA = 0;\n        this.v_invIB = 0;\n        for (var _b = 0, _c = this.p_localPoints; _b < _c.length; _b++) {\n          var point_2 = _c[_b];\n          zeroVec2(point_2);\n        }\n        zeroVec2(this.p_localNormal);\n        zeroVec2(this.p_localPoint);\n        zeroVec2(this.p_localCenterA);\n        zeroVec2(this.p_localCenterB);\n        this.p_type = exports2.ManifoldType.e_unset;\n        this.p_radiusA = 0;\n        this.p_radiusB = 0;\n        this.p_pointCount = 0;\n        this.p_invMassA = 0;\n        this.p_invMassB = 0;\n        this.p_invIA = 0;\n        this.p_invIB = 0;\n      };\n      Contact2.prototype.initConstraint = function(step) {\n        var fixtureA = this.m_fixtureA;\n        var fixtureB = this.m_fixtureB;\n        if (fixtureA === null || fixtureB === null)\n          return;\n        var bodyA = fixtureA.m_body;\n        var bodyB = fixtureB.m_body;\n        if (bodyA === null || bodyB === null)\n          return;\n        var shapeA = fixtureA.m_shape;\n        var shapeB = fixtureB.m_shape;\n        if (shapeA === null || shapeB === null)\n          return;\n        var manifold = this.m_manifold;\n        var pointCount = manifold.pointCount;\n        this.v_invMassA = bodyA.m_invMass;\n        this.v_invMassB = bodyB.m_invMass;\n        this.v_invIA = bodyA.m_invI;\n        this.v_invIB = bodyB.m_invI;\n        this.v_friction = this.m_friction;\n        this.v_restitution = this.m_restitution;\n        this.v_tangentSpeed = this.m_tangentSpeed;\n        this.v_pointCount = pointCount;\n        this.v_K.setZero();\n        this.v_normalMass.setZero();\n        this.p_invMassA = bodyA.m_invMass;\n        this.p_invMassB = bodyB.m_invMass;\n        this.p_invIA = bodyA.m_invI;\n        this.p_invIB = bodyB.m_invI;\n        copyVec2(this.p_localCenterA, bodyA.m_sweep.localCenter);\n        copyVec2(this.p_localCenterB, bodyB.m_sweep.localCenter);\n        this.p_radiusA = shapeA.m_radius;\n        this.p_radiusB = shapeB.m_radius;\n        this.p_type = manifold.type;\n        copyVec2(this.p_localNormal, manifold.localNormal);\n        copyVec2(this.p_localPoint, manifold.localPoint);\n        this.p_pointCount = pointCount;\n        for (var j = 0; j < SettingsInternal.maxManifoldPoints; ++j) {\n          this.v_points[j].recycle();\n          zeroVec2(this.p_localPoints[j]);\n        }\n        for (var j = 0; j < pointCount; ++j) {\n          var cp = manifold.points[j];\n          var vcp = this.v_points[j];\n          if (step.warmStarting) {\n            vcp.normalImpulse = step.dtRatio * cp.normalImpulse;\n            vcp.tangentImpulse = step.dtRatio * cp.tangentImpulse;\n          }\n          copyVec2(this.p_localPoints[j], cp.localPoint);\n        }\n      };\n      Contact2.prototype.getManifold = function() {\n        return this.m_manifold;\n      };\n      Contact2.prototype.getWorldManifold = function(worldManifold2) {\n        var fixtureA = this.m_fixtureA;\n        var fixtureB = this.m_fixtureB;\n        if (fixtureA === null || fixtureB === null)\n          return;\n        var bodyA = fixtureA.m_body;\n        var bodyB = fixtureB.m_body;\n        if (bodyA === null || bodyB === null)\n          return;\n        var shapeA = fixtureA.m_shape;\n        var shapeB = fixtureB.m_shape;\n        if (shapeA === null || shapeB === null)\n          return;\n        return this.m_manifold.getWorldManifold(worldManifold2, bodyA.getTransform(), shapeA.m_radius, bodyB.getTransform(), shapeB.m_radius);\n      };\n      Contact2.prototype.setEnabled = function(flag) {\n        this.m_enabledFlag = !!flag;\n      };\n      Contact2.prototype.isEnabled = function() {\n        return this.m_enabledFlag;\n      };\n      Contact2.prototype.isTouching = function() {\n        return this.m_touchingFlag;\n      };\n      Contact2.prototype.getNext = function() {\n        return this.m_next;\n      };\n      Contact2.prototype.getFixtureA = function() {\n        return this.m_fixtureA;\n      };\n      Contact2.prototype.getFixtureB = function() {\n        return this.m_fixtureB;\n      };\n      Contact2.prototype.getChildIndexA = function() {\n        return this.m_indexA;\n      };\n      Contact2.prototype.getChildIndexB = function() {\n        return this.m_indexB;\n      };\n      Contact2.prototype.flagForFiltering = function() {\n        this.m_filterFlag = true;\n      };\n      Contact2.prototype.setFriction = function(friction) {\n        this.m_friction = friction;\n      };\n      Contact2.prototype.getFriction = function() {\n        return this.m_friction;\n      };\n      Contact2.prototype.resetFriction = function() {\n        var fixtureA = this.m_fixtureA;\n        var fixtureB = this.m_fixtureB;\n        if (fixtureA === null || fixtureB === null)\n          return;\n        this.m_friction = mixFriction(fixtureA.m_friction, fixtureB.m_friction);\n      };\n      Contact2.prototype.setRestitution = function(restitution) {\n        this.m_restitution = restitution;\n      };\n      Contact2.prototype.getRestitution = function() {\n        return this.m_restitution;\n      };\n      Contact2.prototype.resetRestitution = function() {\n        var fixtureA = this.m_fixtureA;\n        var fixtureB = this.m_fixtureB;\n        if (fixtureA === null || fixtureB === null)\n          return;\n        this.m_restitution = mixRestitution(fixtureA.m_restitution, fixtureB.m_restitution);\n      };\n      Contact2.prototype.setTangentSpeed = function(speed) {\n        this.m_tangentSpeed = speed;\n      };\n      Contact2.prototype.getTangentSpeed = function() {\n        return this.m_tangentSpeed;\n      };\n      Contact2.prototype.evaluate = function(manifold, xfA2, xfB2) {\n        var fixtureA = this.m_fixtureA;\n        var fixtureB = this.m_fixtureB;\n        if (fixtureA === null || fixtureB === null)\n          return;\n        this.m_evaluateFcn(manifold, xfA2, fixtureA, this.m_indexA, xfB2, fixtureB, this.m_indexB);\n      };\n      Contact2.prototype.update = function(listener) {\n        var fixtureA = this.m_fixtureA;\n        var fixtureB = this.m_fixtureB;\n        if (fixtureA === null || fixtureB === null)\n          return;\n        var bodyA = fixtureA.m_body;\n        var bodyB = fixtureB.m_body;\n        if (bodyA === null || bodyB === null)\n          return;\n        var shapeA = fixtureA.m_shape;\n        var shapeB = fixtureB.m_shape;\n        if (shapeA === null || shapeB === null)\n          return;\n        this.m_enabledFlag = true;\n        var touching = false;\n        var wasTouching = this.m_touchingFlag;\n        var sensorA = fixtureA.m_isSensor;\n        var sensorB = fixtureB.m_isSensor;\n        var sensor = sensorA || sensorB;\n        var xfA2 = bodyA.m_xf;\n        var xfB2 = bodyB.m_xf;\n        if (sensor) {\n          touching = testOverlap(shapeA, this.m_indexA, shapeB, this.m_indexB, xfA2, xfB2);\n          this.m_manifold.pointCount = 0;\n        } else {\n          oldManifold.recycle();\n          oldManifold.set(this.m_manifold);\n          this.m_manifold.recycle();\n          this.evaluate(this.m_manifold, xfA2, xfB2);\n          touching = this.m_manifold.pointCount > 0;\n          for (var i = 0; i < this.m_manifold.pointCount; ++i) {\n            var nmp = this.m_manifold.points[i];\n            nmp.normalImpulse = 0;\n            nmp.tangentImpulse = 0;\n            for (var j = 0; j < oldManifold.pointCount; ++j) {\n              var omp = oldManifold.points[j];\n              if (omp.id.key === nmp.id.key) {\n                nmp.normalImpulse = omp.normalImpulse;\n                nmp.tangentImpulse = omp.tangentImpulse;\n                break;\n              }\n            }\n          }\n          if (touching !== wasTouching) {\n            bodyA.setAwake(true);\n            bodyB.setAwake(true);\n          }\n        }\n        this.m_touchingFlag = touching;\n        var hasListener = typeof listener === \"object\" && listener !== null;\n        if (!wasTouching && touching && hasListener) {\n          listener.beginContact(this);\n        }\n        if (wasTouching && !touching && hasListener) {\n          listener.endContact(this);\n        }\n        if (!sensor && touching && hasListener && oldManifold) {\n          listener.preSolve(this, oldManifold);\n        }\n      };\n      Contact2.prototype.solvePositionConstraint = function(step) {\n        return this._solvePositionConstraint(step, null, null);\n      };\n      Contact2.prototype.solvePositionConstraintTOI = function(step, toiA, toiB) {\n        return this._solvePositionConstraint(step, toiA, toiB);\n      };\n      Contact2.prototype._solvePositionConstraint = function(step, toiA, toiB) {\n        var toi = toiA !== null && toiB !== null ? true : false;\n        var minSeparation = 0;\n        var fixtureA = this.m_fixtureA;\n        var fixtureB = this.m_fixtureB;\n        if (fixtureA === null || fixtureB === null)\n          return minSeparation;\n        var bodyA = fixtureA.m_body;\n        var bodyB = fixtureB.m_body;\n        if (bodyA === null || bodyB === null)\n          return minSeparation;\n        bodyA.c_velocity;\n        bodyB.c_velocity;\n        var positionA = bodyA.c_position;\n        var positionB = bodyB.c_position;\n        var localCenterA = this.p_localCenterA;\n        var localCenterB = this.p_localCenterB;\n        var mA = 0;\n        var iA = 0;\n        if (!toi || (bodyA === toiA || bodyA === toiB)) {\n          mA = this.p_invMassA;\n          iA = this.p_invIA;\n        }\n        var mB = 0;\n        var iB = 0;\n        if (!toi || (bodyB === toiA || bodyB === toiB)) {\n          mB = this.p_invMassB;\n          iB = this.p_invIB;\n        }\n        copyVec2(cA, positionA.c);\n        var aA = positionA.a;\n        copyVec2(cB, positionB.c);\n        var aB = positionB.a;\n        for (var j = 0; j < this.p_pointCount; ++j) {\n          getTransform(xfA, localCenterA, cA, aA);\n          getTransform(xfB, localCenterB, cB, aB);\n          var separation = void 0;\n          switch (this.p_type) {\n            case exports2.ManifoldType.e_circles: {\n              transformVec2(pointA, xfA, this.p_localPoint);\n              transformVec2(pointB, xfB, this.p_localPoints[0]);\n              subVec2(normal$2, pointB, pointA);\n              normalizeVec2(normal$2);\n              combine2Vec2(point, 0.5, pointA, 0.5, pointB);\n              separation = dotVec2(pointB, normal$2) - dotVec2(pointA, normal$2) - this.p_radiusA - this.p_radiusB;\n              break;\n            }\n            case exports2.ManifoldType.e_faceA: {\n              rotVec2(normal$2, xfA.q, this.p_localNormal);\n              transformVec2(planePoint$1, xfA, this.p_localPoint);\n              transformVec2(clipPoint, xfB, this.p_localPoints[j]);\n              separation = dotVec2(clipPoint, normal$2) - dotVec2(planePoint$1, normal$2) - this.p_radiusA - this.p_radiusB;\n              copyVec2(point, clipPoint);\n              break;\n            }\n            case exports2.ManifoldType.e_faceB: {\n              rotVec2(normal$2, xfB.q, this.p_localNormal);\n              transformVec2(planePoint$1, xfB, this.p_localPoint);\n              transformVec2(clipPoint, xfA, this.p_localPoints[j]);\n              separation = dotVec2(clipPoint, normal$2) - dotVec2(planePoint$1, normal$2) - this.p_radiusA - this.p_radiusB;\n              copyVec2(point, clipPoint);\n              negVec2(normal$2);\n              break;\n            }\n            default: {\n              return minSeparation;\n            }\n          }\n          subVec2(rA, point, cA);\n          subVec2(rB, point, cB);\n          minSeparation = math_min$4(minSeparation, separation);\n          var baumgarte = toi ? SettingsInternal.toiBaugarte : SettingsInternal.baumgarte;\n          var linearSlop = SettingsInternal.linearSlop;\n          var maxLinearCorrection = SettingsInternal.maxLinearCorrection;\n          var C = clamp(baumgarte * (separation + linearSlop), -maxLinearCorrection, 0);\n          var rnA = crossVec2Vec2(rA, normal$2);\n          var rnB = crossVec2Vec2(rB, normal$2);\n          var K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\n          var impulse = K > 0 ? -C / K : 0;\n          scaleVec2(P$1, impulse, normal$2);\n          minusScaleVec2(cA, mA, P$1);\n          aA -= iA * crossVec2Vec2(rA, P$1);\n          plusScaleVec2(cB, mB, P$1);\n          aB += iB * crossVec2Vec2(rB, P$1);\n        }\n        copyVec2(positionA.c, cA);\n        positionA.a = aA;\n        copyVec2(positionB.c, cB);\n        positionB.a = aB;\n        return minSeparation;\n      };\n      Contact2.prototype.initVelocityConstraint = function(step) {\n        var fixtureA = this.m_fixtureA;\n        var fixtureB = this.m_fixtureB;\n        if (fixtureA === null || fixtureB === null)\n          return;\n        var bodyA = fixtureA.m_body;\n        var bodyB = fixtureB.m_body;\n        if (bodyA === null || bodyB === null)\n          return;\n        var velocityA = bodyA.c_velocity;\n        var velocityB = bodyB.c_velocity;\n        var positionA = bodyA.c_position;\n        var positionB = bodyB.c_position;\n        var radiusA = this.p_radiusA;\n        var radiusB = this.p_radiusB;\n        var manifold = this.m_manifold;\n        var mA = this.v_invMassA;\n        var mB = this.v_invMassB;\n        var iA = this.v_invIA;\n        var iB = this.v_invIB;\n        var localCenterA = this.p_localCenterA;\n        var localCenterB = this.p_localCenterB;\n        copyVec2(cA, positionA.c);\n        var aA = positionA.a;\n        copyVec2(vA, velocityA.v);\n        var wA = velocityA.w;\n        copyVec2(cB, positionB.c);\n        var aB = positionB.a;\n        copyVec2(vB, velocityB.v);\n        var wB = velocityB.w;\n        getTransform(xfA, localCenterA, cA, aA);\n        getTransform(xfB, localCenterB, cB, aB);\n        worldManifold.recycle();\n        manifold.getWorldManifold(worldManifold, xfA, radiusA, xfB, radiusB);\n        copyVec2(this.v_normal, worldManifold.normal);\n        for (var j = 0; j < this.v_pointCount; ++j) {\n          var vcp = this.v_points[j];\n          var wmp = worldManifold.points[j];\n          subVec2(vcp.rA, wmp, cA);\n          subVec2(vcp.rB, wmp, cB);\n          var rnA = crossVec2Vec2(vcp.rA, this.v_normal);\n          var rnB = crossVec2Vec2(vcp.rB, this.v_normal);\n          var kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\n          vcp.normalMass = kNormal > 0 ? 1 / kNormal : 0;\n          crossVec2Num(tangent$1, this.v_normal, 1);\n          var rtA = crossVec2Vec2(vcp.rA, tangent$1);\n          var rtB = crossVec2Vec2(vcp.rB, tangent$1);\n          var kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;\n          vcp.tangentMass = kTangent > 0 ? 1 / kTangent : 0;\n          vcp.velocityBias = 0;\n          var vRel = 0;\n          vRel += dotVec2(this.v_normal, vB);\n          vRel += dotVec2(this.v_normal, crossNumVec2(temp$2, wB, vcp.rB));\n          vRel -= dotVec2(this.v_normal, vA);\n          vRel -= dotVec2(this.v_normal, crossNumVec2(temp$2, wA, vcp.rA));\n          if (vRel < -SettingsInternal.velocityThreshold) {\n            vcp.velocityBias = -this.v_restitution * vRel;\n          }\n        }\n        if (this.v_pointCount == 2 && step.blockSolve) {\n          var vcp1 = this.v_points[0];\n          var vcp2 = this.v_points[1];\n          var rn1A = crossVec2Vec2(vcp1.rA, this.v_normal);\n          var rn1B = crossVec2Vec2(vcp1.rB, this.v_normal);\n          var rn2A = crossVec2Vec2(vcp2.rA, this.v_normal);\n          var rn2B = crossVec2Vec2(vcp2.rB, this.v_normal);\n          var k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;\n          var k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;\n          var k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;\n          var k_maxConditionNumber = 1e3;\n          if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {\n            this.v_K.ex.setNum(k11, k12);\n            this.v_K.ey.setNum(k12, k22);\n            var a_1 = this.v_K.ex.x;\n            var b_1 = this.v_K.ey.x;\n            var c2 = this.v_K.ex.y;\n            var d_1 = this.v_K.ey.y;\n            var det = a_1 * d_1 - b_1 * c2;\n            if (det !== 0) {\n              det = 1 / det;\n            }\n            this.v_normalMass.ex.x = det * d_1;\n            this.v_normalMass.ey.x = -det * b_1;\n            this.v_normalMass.ex.y = -det * c2;\n            this.v_normalMass.ey.y = det * a_1;\n          } else {\n            this.v_pointCount = 1;\n          }\n        }\n        copyVec2(positionA.c, cA);\n        positionA.a = aA;\n        copyVec2(velocityA.v, vA);\n        velocityA.w = wA;\n        copyVec2(positionB.c, cB);\n        positionB.a = aB;\n        copyVec2(velocityB.v, vB);\n        velocityB.w = wB;\n      };\n      Contact2.prototype.warmStartConstraint = function(step) {\n        var fixtureA = this.m_fixtureA;\n        var fixtureB = this.m_fixtureB;\n        if (fixtureA === null || fixtureB === null)\n          return;\n        var bodyA = fixtureA.m_body;\n        var bodyB = fixtureB.m_body;\n        if (bodyA === null || bodyB === null)\n          return;\n        var velocityA = bodyA.c_velocity;\n        var velocityB = bodyB.c_velocity;\n        bodyA.c_position;\n        bodyB.c_position;\n        var mA = this.v_invMassA;\n        var iA = this.v_invIA;\n        var mB = this.v_invMassB;\n        var iB = this.v_invIB;\n        copyVec2(vA, velocityA.v);\n        var wA = velocityA.w;\n        copyVec2(vB, velocityB.v);\n        var wB = velocityB.w;\n        copyVec2(normal$2, this.v_normal);\n        crossVec2Num(tangent$1, normal$2, 1);\n        for (var j = 0; j < this.v_pointCount; ++j) {\n          var vcp = this.v_points[j];\n          combine2Vec2(P$1, vcp.normalImpulse, normal$2, vcp.tangentImpulse, tangent$1);\n          wA -= iA * crossVec2Vec2(vcp.rA, P$1);\n          minusScaleVec2(vA, mA, P$1);\n          wB += iB * crossVec2Vec2(vcp.rB, P$1);\n          plusScaleVec2(vB, mB, P$1);\n        }\n        copyVec2(velocityA.v, vA);\n        velocityA.w = wA;\n        copyVec2(velocityB.v, vB);\n        velocityB.w = wB;\n      };\n      Contact2.prototype.storeConstraintImpulses = function(step) {\n        var manifold = this.m_manifold;\n        for (var j = 0; j < this.v_pointCount; ++j) {\n          manifold.points[j].normalImpulse = this.v_points[j].normalImpulse;\n          manifold.points[j].tangentImpulse = this.v_points[j].tangentImpulse;\n        }\n      };\n      Contact2.prototype.solveVelocityConstraint = function(step) {\n        var fixtureA = this.m_fixtureA;\n        var fixtureB = this.m_fixtureB;\n        if (fixtureA === null || fixtureB === null)\n          return;\n        var bodyA = fixtureA.m_body;\n        var bodyB = fixtureB.m_body;\n        if (bodyA === null || bodyB === null)\n          return;\n        var velocityA = bodyA.c_velocity;\n        bodyA.c_position;\n        var velocityB = bodyB.c_velocity;\n        bodyB.c_position;\n        var mA = this.v_invMassA;\n        var iA = this.v_invIA;\n        var mB = this.v_invMassB;\n        var iB = this.v_invIB;\n        copyVec2(vA, velocityA.v);\n        var wA = velocityA.w;\n        copyVec2(vB, velocityB.v);\n        var wB = velocityB.w;\n        copyVec2(normal$2, this.v_normal);\n        crossVec2Num(tangent$1, normal$2, 1);\n        var friction = this.v_friction;\n        for (var j = 0; j < this.v_pointCount; ++j) {\n          var vcp = this.v_points[j];\n          zeroVec2(dv);\n          plusVec2(dv, vB);\n          plusVec2(dv, crossNumVec2(temp$2, wB, vcp.rB));\n          minusVec2(dv, vA);\n          minusVec2(dv, crossNumVec2(temp$2, wA, vcp.rA));\n          var vt = dotVec2(dv, tangent$1) - this.v_tangentSpeed;\n          var lambda = vcp.tangentMass * -vt;\n          var maxFriction = friction * vcp.normalImpulse;\n          var newImpulse = clamp(vcp.tangentImpulse + lambda, -maxFriction, maxFriction);\n          lambda = newImpulse - vcp.tangentImpulse;\n          vcp.tangentImpulse = newImpulse;\n          scaleVec2(P$1, lambda, tangent$1);\n          minusScaleVec2(vA, mA, P$1);\n          wA -= iA * crossVec2Vec2(vcp.rA, P$1);\n          plusScaleVec2(vB, mB, P$1);\n          wB += iB * crossVec2Vec2(vcp.rB, P$1);\n        }\n        if (this.v_pointCount == 1 || step.blockSolve == false) {\n          for (var i = 0; i < this.v_pointCount; ++i) {\n            var vcp = this.v_points[i];\n            zeroVec2(dv);\n            plusVec2(dv, vB);\n            plusVec2(dv, crossNumVec2(temp$2, wB, vcp.rB));\n            minusVec2(dv, vA);\n            minusVec2(dv, crossNumVec2(temp$2, wA, vcp.rA));\n            var vn = dotVec2(dv, normal$2);\n            var lambda = -vcp.normalMass * (vn - vcp.velocityBias);\n            var newImpulse = math_max$2(vcp.normalImpulse + lambda, 0);\n            lambda = newImpulse - vcp.normalImpulse;\n            vcp.normalImpulse = newImpulse;\n            scaleVec2(P$1, lambda, normal$2);\n            minusScaleVec2(vA, mA, P$1);\n            wA -= iA * crossVec2Vec2(vcp.rA, P$1);\n            plusScaleVec2(vB, mB, P$1);\n            wB += iB * crossVec2Vec2(vcp.rB, P$1);\n          }\n        } else {\n          var vcp1 = this.v_points[0];\n          var vcp2 = this.v_points[1];\n          setVec2(a, vcp1.normalImpulse, vcp2.normalImpulse);\n          zeroVec2(dv1);\n          plusVec2(dv1, vB);\n          plusVec2(dv1, crossNumVec2(temp$2, wB, vcp1.rB));\n          minusVec2(dv1, vA);\n          minusVec2(dv1, crossNumVec2(temp$2, wA, vcp1.rA));\n          zeroVec2(dv2);\n          plusVec2(dv2, vB);\n          plusVec2(dv2, crossNumVec2(temp$2, wB, vcp2.rB));\n          minusVec2(dv2, vA);\n          minusVec2(dv2, crossNumVec2(temp$2, wA, vcp2.rA));\n          var vn1 = dotVec2(dv1, normal$2);\n          var vn2 = dotVec2(dv2, normal$2);\n          setVec2(b, vn1 - vcp1.velocityBias, vn2 - vcp2.velocityBias);\n          b.x -= this.v_K.ex.x * a.x + this.v_K.ey.x * a.y;\n          b.y -= this.v_K.ex.y * a.x + this.v_K.ey.y * a.y;\n          while (true) {\n            zeroVec2(x);\n            x.x = -(this.v_normalMass.ex.x * b.x + this.v_normalMass.ey.x * b.y);\n            x.y = -(this.v_normalMass.ex.y * b.x + this.v_normalMass.ey.y * b.y);\n            if (x.x >= 0 && x.y >= 0) {\n              subVec2(d, x, a);\n              scaleVec2(P1, d.x, normal$2);\n              scaleVec2(P2, d.y, normal$2);\n              combine3Vec2(vA, -mA, P1, -mA, P2, 1, vA);\n              wA -= iA * (crossVec2Vec2(vcp1.rA, P1) + crossVec2Vec2(vcp2.rA, P2));\n              combine3Vec2(vB, mB, P1, mB, P2, 1, vB);\n              wB += iB * (crossVec2Vec2(vcp1.rB, P1) + crossVec2Vec2(vcp2.rB, P2));\n              vcp1.normalImpulse = x.x;\n              vcp2.normalImpulse = x.y;\n              break;\n            }\n            x.x = -vcp1.normalMass * b.x;\n            x.y = 0;\n            vn1 = 0;\n            vn2 = this.v_K.ex.y * x.x + b.y;\n            if (x.x >= 0 && vn2 >= 0) {\n              subVec2(d, x, a);\n              scaleVec2(P1, d.x, normal$2);\n              scaleVec2(P2, d.y, normal$2);\n              combine3Vec2(vA, -mA, P1, -mA, P2, 1, vA);\n              wA -= iA * (crossVec2Vec2(vcp1.rA, P1) + crossVec2Vec2(vcp2.rA, P2));\n              combine3Vec2(vB, mB, P1, mB, P2, 1, vB);\n              wB += iB * (crossVec2Vec2(vcp1.rB, P1) + crossVec2Vec2(vcp2.rB, P2));\n              vcp1.normalImpulse = x.x;\n              vcp2.normalImpulse = x.y;\n              break;\n            }\n            x.x = 0;\n            x.y = -vcp2.normalMass * b.y;\n            vn1 = this.v_K.ey.x * x.y + b.x;\n            vn2 = 0;\n            if (x.y >= 0 && vn1 >= 0) {\n              subVec2(d, x, a);\n              scaleVec2(P1, d.x, normal$2);\n              scaleVec2(P2, d.y, normal$2);\n              combine3Vec2(vA, -mA, P1, -mA, P2, 1, vA);\n              wA -= iA * (crossVec2Vec2(vcp1.rA, P1) + crossVec2Vec2(vcp2.rA, P2));\n              combine3Vec2(vB, mB, P1, mB, P2, 1, vB);\n              wB += iB * (crossVec2Vec2(vcp1.rB, P1) + crossVec2Vec2(vcp2.rB, P2));\n              vcp1.normalImpulse = x.x;\n              vcp2.normalImpulse = x.y;\n              break;\n            }\n            x.x = 0;\n            x.y = 0;\n            vn1 = b.x;\n            vn2 = b.y;\n            if (vn1 >= 0 && vn2 >= 0) {\n              subVec2(d, x, a);\n              scaleVec2(P1, d.x, normal$2);\n              scaleVec2(P2, d.y, normal$2);\n              combine3Vec2(vA, -mA, P1, -mA, P2, 1, vA);\n              wA -= iA * (crossVec2Vec2(vcp1.rA, P1) + crossVec2Vec2(vcp2.rA, P2));\n              combine3Vec2(vB, mB, P1, mB, P2, 1, vB);\n              wB += iB * (crossVec2Vec2(vcp1.rB, P1) + crossVec2Vec2(vcp2.rB, P2));\n              vcp1.normalImpulse = x.x;\n              vcp2.normalImpulse = x.y;\n              break;\n            }\n            break;\n          }\n        }\n        copyVec2(velocityA.v, vA);\n        velocityA.w = wA;\n        copyVec2(velocityB.v, vB);\n        velocityB.w = wB;\n      };\n      Contact2.addType = function(type1, type2, callback) {\n        s_registers[type1] = s_registers[type1] || {};\n        s_registers[type1][type2] = callback;\n      };\n      Contact2.create = function(fixtureA, indexA, fixtureB, indexB) {\n        var typeA = fixtureA.m_shape.m_type;\n        var typeB = fixtureB.m_shape.m_type;\n        var contact = contactPool.allocate();\n        var evaluateFcn;\n        if (evaluateFcn = s_registers[typeA] && s_registers[typeA][typeB]) {\n          contact.initialize(fixtureA, indexA, fixtureB, indexB, evaluateFcn);\n        } else if (evaluateFcn = s_registers[typeB] && s_registers[typeB][typeA]) {\n          contact.initialize(fixtureB, indexB, fixtureA, indexA, evaluateFcn);\n        } else {\n          return null;\n        }\n        fixtureA = contact.m_fixtureA;\n        fixtureB = contact.m_fixtureB;\n        indexA = contact.getChildIndexA();\n        indexB = contact.getChildIndexB();\n        var bodyA = fixtureA.m_body;\n        var bodyB = fixtureB.m_body;\n        contact.m_nodeA.contact = contact;\n        contact.m_nodeA.other = bodyB;\n        contact.m_nodeA.prev = null;\n        contact.m_nodeA.next = bodyA.m_contactList;\n        if (bodyA.m_contactList != null) {\n          bodyA.m_contactList.prev = contact.m_nodeA;\n        }\n        bodyA.m_contactList = contact.m_nodeA;\n        contact.m_nodeB.contact = contact;\n        contact.m_nodeB.other = bodyA;\n        contact.m_nodeB.prev = null;\n        contact.m_nodeB.next = bodyB.m_contactList;\n        if (bodyB.m_contactList != null) {\n          bodyB.m_contactList.prev = contact.m_nodeB;\n        }\n        bodyB.m_contactList = contact.m_nodeB;\n        if (fixtureA.isSensor() == false && fixtureB.isSensor() == false) {\n          bodyA.setAwake(true);\n          bodyB.setAwake(true);\n        }\n        return contact;\n      };\n      Contact2.destroy = function(contact, listener) {\n        var fixtureA = contact.m_fixtureA;\n        var fixtureB = contact.m_fixtureB;\n        if (fixtureA === null || fixtureB === null)\n          return;\n        var bodyA = fixtureA.m_body;\n        var bodyB = fixtureB.m_body;\n        if (bodyA === null || bodyB === null)\n          return;\n        if (contact.isTouching()) {\n          listener.endContact(contact);\n        }\n        if (contact.m_nodeA.prev) {\n          contact.m_nodeA.prev.next = contact.m_nodeA.next;\n        }\n        if (contact.m_nodeA.next) {\n          contact.m_nodeA.next.prev = contact.m_nodeA.prev;\n        }\n        if (contact.m_nodeA == bodyA.m_contactList) {\n          bodyA.m_contactList = contact.m_nodeA.next;\n        }\n        if (contact.m_nodeB.prev) {\n          contact.m_nodeB.prev.next = contact.m_nodeB.next;\n        }\n        if (contact.m_nodeB.next) {\n          contact.m_nodeB.next.prev = contact.m_nodeB.prev;\n        }\n        if (contact.m_nodeB == bodyB.m_contactList) {\n          bodyB.m_contactList = contact.m_nodeB.next;\n        }\n        if (contact.m_manifold.pointCount > 0 && !fixtureA.m_isSensor && !fixtureB.m_isSensor) {\n          bodyA.setAwake(true);\n          bodyB.setAwake(true);\n        }\n        contactPool.release(contact);\n      };\n      return Contact2;\n    }()\n  );\n  var DEFAULTS$b = {\n    gravity: Vec2.zero(),\n    allowSleep: true,\n    warmStarting: true,\n    continuousPhysics: true,\n    subStepping: false,\n    blockSolve: true,\n    velocityIterations: 8,\n    positionIterations: 3\n  };\n  var World = (\n    /** @class */\n    function() {\n      function World2(def) {\n        if (!(this instanceof World2)) {\n          return new World2(def);\n        }\n        this.s_step = new TimeStep();\n        if (!def) {\n          def = {};\n        } else if (Vec2.isValid(def)) {\n          def = { gravity: def };\n        }\n        def = options(def, DEFAULTS$b);\n        this.m_solver = new Solver(this);\n        this.m_broadPhase = new BroadPhase();\n        this.m_contactList = null;\n        this.m_contactCount = 0;\n        this.m_bodyList = null;\n        this.m_bodyCount = 0;\n        this.m_jointList = null;\n        this.m_jointCount = 0;\n        this.m_stepComplete = true;\n        this.m_allowSleep = def.allowSleep;\n        this.m_gravity = Vec2.clone(def.gravity);\n        this.m_clearForces = true;\n        this.m_newFixture = false;\n        this.m_locked = false;\n        this.m_warmStarting = def.warmStarting;\n        this.m_continuousPhysics = def.continuousPhysics;\n        this.m_subStepping = def.subStepping;\n        this.m_blockSolve = def.blockSolve;\n        this.m_velocityIterations = def.velocityIterations;\n        this.m_positionIterations = def.positionIterations;\n        this.m_t = 0;\n        this.m_step_callback = [];\n      }\n      World2.prototype._serialize = function() {\n        var bodies = [];\n        var joints = [];\n        for (var b2 = this.getBodyList(); b2; b2 = b2.getNext()) {\n          bodies.push(b2);\n        }\n        for (var j = this.getJointList(); j; j = j.getNext()) {\n          if (typeof j._serialize === \"function\") {\n            joints.push(j);\n          }\n        }\n        return {\n          gravity: this.m_gravity,\n          bodies,\n          joints\n        };\n      };\n      World2._deserialize = function(data, context, restore) {\n        if (!data) {\n          return new World2();\n        }\n        var world = new World2(data.gravity);\n        if (data.bodies) {\n          for (var i = data.bodies.length - 1; i >= 0; i -= 1) {\n            world._addBody(restore(Body, data.bodies[i], world));\n          }\n        }\n        if (data.joints) {\n          for (var i = data.joints.length - 1; i >= 0; i--) {\n            world.createJoint(restore(Joint, data.joints[i], world));\n          }\n        }\n        return world;\n      };\n      World2.prototype.getBodyList = function() {\n        return this.m_bodyList;\n      };\n      World2.prototype.getJointList = function() {\n        return this.m_jointList;\n      };\n      World2.prototype.getContactList = function() {\n        return this.m_contactList;\n      };\n      World2.prototype.getBodyCount = function() {\n        return this.m_bodyCount;\n      };\n      World2.prototype.getJointCount = function() {\n        return this.m_jointCount;\n      };\n      World2.prototype.getContactCount = function() {\n        return this.m_contactCount;\n      };\n      World2.prototype.setGravity = function(gravity) {\n        this.m_gravity.set(gravity);\n      };\n      World2.prototype.getGravity = function() {\n        return this.m_gravity;\n      };\n      World2.prototype.isLocked = function() {\n        return this.m_locked;\n      };\n      World2.prototype.setAllowSleeping = function(flag) {\n        if (flag == this.m_allowSleep) {\n          return;\n        }\n        this.m_allowSleep = flag;\n        if (this.m_allowSleep == false) {\n          for (var b2 = this.m_bodyList; b2; b2 = b2.m_next) {\n            b2.setAwake(true);\n          }\n        }\n      };\n      World2.prototype.getAllowSleeping = function() {\n        return this.m_allowSleep;\n      };\n      World2.prototype.setWarmStarting = function(flag) {\n        this.m_warmStarting = flag;\n      };\n      World2.prototype.getWarmStarting = function() {\n        return this.m_warmStarting;\n      };\n      World2.prototype.setContinuousPhysics = function(flag) {\n        this.m_continuousPhysics = flag;\n      };\n      World2.prototype.getContinuousPhysics = function() {\n        return this.m_continuousPhysics;\n      };\n      World2.prototype.setSubStepping = function(flag) {\n        this.m_subStepping = flag;\n      };\n      World2.prototype.getSubStepping = function() {\n        return this.m_subStepping;\n      };\n      World2.prototype.setAutoClearForces = function(flag) {\n        this.m_clearForces = flag;\n      };\n      World2.prototype.getAutoClearForces = function() {\n        return this.m_clearForces;\n      };\n      World2.prototype.clearForces = function() {\n        for (var body = this.m_bodyList; body; body = body.getNext()) {\n          body.m_force.setZero();\n          body.m_torque = 0;\n        }\n      };\n      World2.prototype.queryAABB = function(aabb, callback) {\n        var broadPhase = this.m_broadPhase;\n        this.m_broadPhase.query(aabb, function(proxyId) {\n          var proxy = broadPhase.getUserData(proxyId);\n          return callback(proxy.fixture);\n        });\n      };\n      World2.prototype.rayCast = function(point1, point2, callback) {\n        var broadPhase = this.m_broadPhase;\n        this.m_broadPhase.rayCast({\n          maxFraction: 1,\n          p1: point1,\n          p2: point2\n        }, function(input2, proxyId) {\n          var proxy = broadPhase.getUserData(proxyId);\n          var fixture = proxy.fixture;\n          var index = proxy.childIndex;\n          var output2 = {};\n          var hit = fixture.rayCast(output2, input2, index);\n          if (hit) {\n            var fraction = output2.fraction;\n            var point3 = Vec2.add(Vec2.mulNumVec2(1 - fraction, input2.p1), Vec2.mulNumVec2(fraction, input2.p2));\n            return callback(fixture, point3, output2.normal, fraction);\n          }\n          return input2.maxFraction;\n        });\n      };\n      World2.prototype.getProxyCount = function() {\n        return this.m_broadPhase.getProxyCount();\n      };\n      World2.prototype.getTreeHeight = function() {\n        return this.m_broadPhase.getTreeHeight();\n      };\n      World2.prototype.getTreeBalance = function() {\n        return this.m_broadPhase.getTreeBalance();\n      };\n      World2.prototype.getTreeQuality = function() {\n        return this.m_broadPhase.getTreeQuality();\n      };\n      World2.prototype.shiftOrigin = function(newOrigin) {\n        if (this.isLocked()) {\n          return;\n        }\n        for (var b2 = this.m_bodyList; b2; b2 = b2.m_next) {\n          b2.m_xf.p.sub(newOrigin);\n          b2.m_sweep.c0.sub(newOrigin);\n          b2.m_sweep.c.sub(newOrigin);\n        }\n        for (var j = this.m_jointList; j; j = j.m_next) {\n          j.shiftOrigin(newOrigin);\n        }\n        this.m_broadPhase.shiftOrigin(newOrigin);\n      };\n      World2.prototype._addBody = function(body) {\n        if (this.isLocked()) {\n          return;\n        }\n        body.m_prev = null;\n        body.m_next = this.m_bodyList;\n        if (this.m_bodyList) {\n          this.m_bodyList.m_prev = body;\n        }\n        this.m_bodyList = body;\n        ++this.m_bodyCount;\n      };\n      World2.prototype.createBody = function(arg1, arg2) {\n        if (this.isLocked()) {\n          return null;\n        }\n        var def = {};\n        if (!arg1) ;\n        else if (Vec2.isValid(arg1)) {\n          def = { position: arg1, angle: arg2 };\n        } else if (typeof arg1 === \"object\") {\n          def = arg1;\n        }\n        var body = new Body(this, def);\n        this._addBody(body);\n        return body;\n      };\n      World2.prototype.createDynamicBody = function(arg1, arg2) {\n        var def = {};\n        if (!arg1) ;\n        else if (Vec2.isValid(arg1)) {\n          def = { position: arg1, angle: arg2 };\n        } else if (typeof arg1 === \"object\") {\n          def = arg1;\n        }\n        def.type = \"dynamic\";\n        return this.createBody(def);\n      };\n      World2.prototype.createKinematicBody = function(arg1, arg2) {\n        var def = {};\n        if (!arg1) ;\n        else if (Vec2.isValid(arg1)) {\n          def = { position: arg1, angle: arg2 };\n        } else if (typeof arg1 === \"object\") {\n          def = arg1;\n        }\n        def.type = \"kinematic\";\n        return this.createBody(def);\n      };\n      World2.prototype.destroyBody = function(b2) {\n        if (this.isLocked()) {\n          return;\n        }\n        if (b2.m_destroyed) {\n          return false;\n        }\n        var je = b2.m_jointList;\n        while (je) {\n          var je0 = je;\n          je = je.next;\n          this.publish(\"remove-joint\", je0.joint);\n          this.destroyJoint(je0.joint);\n          b2.m_jointList = je;\n        }\n        b2.m_jointList = null;\n        var ce = b2.m_contactList;\n        while (ce) {\n          var ce0 = ce;\n          ce = ce.next;\n          this.destroyContact(ce0.contact);\n          b2.m_contactList = ce;\n        }\n        b2.m_contactList = null;\n        var f = b2.m_fixtureList;\n        while (f) {\n          var f0 = f;\n          f = f.m_next;\n          this.publish(\"remove-fixture\", f0);\n          f0.destroyProxies(this.m_broadPhase);\n          b2.m_fixtureList = f;\n        }\n        b2.m_fixtureList = null;\n        if (b2.m_prev) {\n          b2.m_prev.m_next = b2.m_next;\n        }\n        if (b2.m_next) {\n          b2.m_next.m_prev = b2.m_prev;\n        }\n        if (b2 == this.m_bodyList) {\n          this.m_bodyList = b2.m_next;\n        }\n        b2.m_destroyed = true;\n        --this.m_bodyCount;\n        this.publish(\"remove-body\", b2);\n        return true;\n      };\n      World2.prototype.createJoint = function(joint) {\n        if (this.isLocked()) {\n          return null;\n        }\n        joint.m_prev = null;\n        joint.m_next = this.m_jointList;\n        if (this.m_jointList) {\n          this.m_jointList.m_prev = joint;\n        }\n        this.m_jointList = joint;\n        ++this.m_jointCount;\n        joint.m_edgeA.joint = joint;\n        joint.m_edgeA.other = joint.m_bodyB;\n        joint.m_edgeA.prev = null;\n        joint.m_edgeA.next = joint.m_bodyA.m_jointList;\n        if (joint.m_bodyA.m_jointList)\n          joint.m_bodyA.m_jointList.prev = joint.m_edgeA;\n        joint.m_bodyA.m_jointList = joint.m_edgeA;\n        joint.m_edgeB.joint = joint;\n        joint.m_edgeB.other = joint.m_bodyA;\n        joint.m_edgeB.prev = null;\n        joint.m_edgeB.next = joint.m_bodyB.m_jointList;\n        if (joint.m_bodyB.m_jointList)\n          joint.m_bodyB.m_jointList.prev = joint.m_edgeB;\n        joint.m_bodyB.m_jointList = joint.m_edgeB;\n        if (joint.m_collideConnected == false) {\n          for (var edge = joint.m_bodyB.getContactList(); edge; edge = edge.next) {\n            if (edge.other == joint.m_bodyA) {\n              edge.contact.flagForFiltering();\n            }\n          }\n        }\n        return joint;\n      };\n      World2.prototype.destroyJoint = function(joint) {\n        if (this.isLocked()) {\n          return;\n        }\n        if (joint.m_prev) {\n          joint.m_prev.m_next = joint.m_next;\n        }\n        if (joint.m_next) {\n          joint.m_next.m_prev = joint.m_prev;\n        }\n        if (joint == this.m_jointList) {\n          this.m_jointList = joint.m_next;\n        }\n        var bodyA = joint.m_bodyA;\n        var bodyB = joint.m_bodyB;\n        bodyA.setAwake(true);\n        bodyB.setAwake(true);\n        if (joint.m_edgeA.prev) {\n          joint.m_edgeA.prev.next = joint.m_edgeA.next;\n        }\n        if (joint.m_edgeA.next) {\n          joint.m_edgeA.next.prev = joint.m_edgeA.prev;\n        }\n        if (joint.m_edgeA == bodyA.m_jointList) {\n          bodyA.m_jointList = joint.m_edgeA.next;\n        }\n        joint.m_edgeA.prev = null;\n        joint.m_edgeA.next = null;\n        if (joint.m_edgeB.prev) {\n          joint.m_edgeB.prev.next = joint.m_edgeB.next;\n        }\n        if (joint.m_edgeB.next) {\n          joint.m_edgeB.next.prev = joint.m_edgeB.prev;\n        }\n        if (joint.m_edgeB == bodyB.m_jointList) {\n          bodyB.m_jointList = joint.m_edgeB.next;\n        }\n        joint.m_edgeB.prev = null;\n        joint.m_edgeB.next = null;\n        --this.m_jointCount;\n        if (joint.m_collideConnected == false) {\n          var edge = bodyB.getContactList();\n          while (edge) {\n            if (edge.other == bodyA) {\n              edge.contact.flagForFiltering();\n            }\n            edge = edge.next;\n          }\n        }\n        this.publish(\"remove-joint\", joint);\n      };\n      World2.prototype.step = function(timeStep, velocityIterations, positionIterations) {\n        this.publish(\"pre-step\", timeStep);\n        if ((velocityIterations | 0) !== velocityIterations) {\n          velocityIterations = 0;\n        }\n        velocityIterations = velocityIterations || this.m_velocityIterations;\n        positionIterations = positionIterations || this.m_positionIterations;\n        if (this.m_newFixture) {\n          this.findNewContacts();\n          this.m_newFixture = false;\n        }\n        this.m_locked = true;\n        this.s_step.reset(timeStep);\n        this.s_step.velocityIterations = velocityIterations;\n        this.s_step.positionIterations = positionIterations;\n        this.s_step.warmStarting = this.m_warmStarting;\n        this.s_step.blockSolve = this.m_blockSolve;\n        this.updateContacts();\n        if (this.m_stepComplete && timeStep > 0) {\n          this.m_solver.solveWorld(this.s_step);\n          for (var b2 = this.m_bodyList; b2; b2 = b2.getNext()) {\n            if (b2.m_islandFlag == false) {\n              continue;\n            }\n            if (b2.isStatic()) {\n              continue;\n            }\n            b2.synchronizeFixtures();\n          }\n          this.findNewContacts();\n        }\n        if (this.m_continuousPhysics && timeStep > 0) {\n          this.m_solver.solveWorldTOI(this.s_step);\n        }\n        if (this.m_clearForces) {\n          this.clearForces();\n        }\n        this.m_locked = false;\n        var callback;\n        while (callback = this.m_step_callback.shift()) {\n          callback(this);\n        }\n        this.publish(\"post-step\", timeStep);\n      };\n      World2.prototype.queueUpdate = function(callback) {\n        if (!this.isLocked()) {\n          callback(this);\n        } else {\n          this.m_step_callback.push(callback);\n        }\n      };\n      World2.prototype.findNewContacts = function() {\n        var _this = this;\n        this.m_broadPhase.updatePairs(function(proxyA, proxyB) {\n          return _this.createContact(proxyA, proxyB);\n        });\n      };\n      World2.prototype.createContact = function(proxyA, proxyB) {\n        var fixtureA = proxyA.fixture;\n        var fixtureB = proxyB.fixture;\n        var indexA = proxyA.childIndex;\n        var indexB = proxyB.childIndex;\n        var bodyA = fixtureA.getBody();\n        var bodyB = fixtureB.getBody();\n        if (bodyA == bodyB) {\n          return;\n        }\n        var edge = bodyB.getContactList();\n        while (edge) {\n          if (edge.other == bodyA) {\n            var fA = edge.contact.getFixtureA();\n            var fB = edge.contact.getFixtureB();\n            var iA = edge.contact.getChildIndexA();\n            var iB = edge.contact.getChildIndexB();\n            if (fA == fixtureA && fB == fixtureB && iA == indexA && iB == indexB) {\n              return;\n            }\n            if (fA == fixtureB && fB == fixtureA && iA == indexB && iB == indexA) {\n              return;\n            }\n          }\n          edge = edge.next;\n        }\n        if (bodyB.shouldCollide(bodyA) == false) {\n          return;\n        }\n        if (fixtureB.shouldCollide(fixtureA) == false) {\n          return;\n        }\n        var contact = Contact.create(fixtureA, indexA, fixtureB, indexB);\n        if (contact == null) {\n          return;\n        }\n        contact.m_prev = null;\n        if (this.m_contactList != null) {\n          contact.m_next = this.m_contactList;\n          this.m_contactList.m_prev = contact;\n        }\n        this.m_contactList = contact;\n        ++this.m_contactCount;\n      };\n      World2.prototype.updateContacts = function() {\n        var c2;\n        var next_c = this.m_contactList;\n        while (c2 = next_c) {\n          next_c = c2.getNext();\n          var fixtureA = c2.getFixtureA();\n          var fixtureB = c2.getFixtureB();\n          var indexA = c2.getChildIndexA();\n          var indexB = c2.getChildIndexB();\n          var bodyA = fixtureA.getBody();\n          var bodyB = fixtureB.getBody();\n          if (c2.m_filterFlag) {\n            if (bodyB.shouldCollide(bodyA) == false) {\n              this.destroyContact(c2);\n              continue;\n            }\n            if (fixtureB.shouldCollide(fixtureA) == false) {\n              this.destroyContact(c2);\n              continue;\n            }\n            c2.m_filterFlag = false;\n          }\n          var activeA = bodyA.isAwake() && !bodyA.isStatic();\n          var activeB = bodyB.isAwake() && !bodyB.isStatic();\n          if (activeA == false && activeB == false) {\n            continue;\n          }\n          var proxyIdA = fixtureA.m_proxies[indexA].proxyId;\n          var proxyIdB = fixtureB.m_proxies[indexB].proxyId;\n          var overlap = this.m_broadPhase.testOverlap(proxyIdA, proxyIdB);\n          if (overlap == false) {\n            this.destroyContact(c2);\n            continue;\n          }\n          c2.update(this);\n        }\n      };\n      World2.prototype.destroyContact = function(contact) {\n        if (contact.m_prev) {\n          contact.m_prev.m_next = contact.m_next;\n        }\n        if (contact.m_next) {\n          contact.m_next.m_prev = contact.m_prev;\n        }\n        if (contact == this.m_contactList) {\n          this.m_contactList = contact.m_next;\n        }\n        Contact.destroy(contact, this);\n        --this.m_contactCount;\n      };\n      World2.prototype.on = function(name, listener) {\n        if (typeof name !== \"string\" || typeof listener !== \"function\") {\n          return this;\n        }\n        if (!this._listeners) {\n          this._listeners = {};\n        }\n        if (!this._listeners[name]) {\n          this._listeners[name] = [];\n        }\n        this._listeners[name].push(listener);\n        return this;\n      };\n      World2.prototype.off = function(name, listener) {\n        if (typeof name !== \"string\" || typeof listener !== \"function\") {\n          return this;\n        }\n        var listeners = this._listeners && this._listeners[name];\n        if (!listeners || !listeners.length) {\n          return this;\n        }\n        var index = listeners.indexOf(listener);\n        if (index >= 0) {\n          listeners.splice(index, 1);\n        }\n        return this;\n      };\n      World2.prototype.publish = function(name, arg1, arg2, arg3) {\n        var listeners = this._listeners && this._listeners[name];\n        if (!listeners || !listeners.length) {\n          return 0;\n        }\n        for (var l = 0; l < listeners.length; l++) {\n          listeners[l].call(this, arg1, arg2, arg3);\n        }\n        return listeners.length;\n      };\n      World2.prototype.beginContact = function(contact) {\n        this.publish(\"begin-contact\", contact);\n      };\n      World2.prototype.endContact = function(contact) {\n        this.publish(\"end-contact\", contact);\n      };\n      World2.prototype.preSolve = function(contact, oldManifold2) {\n        this.publish(\"pre-solve\", contact, oldManifold2);\n      };\n      World2.prototype.postSolve = function(contact, impulse) {\n        this.publish(\"post-solve\", contact, impulse);\n      };\n      return World2;\n    }()\n  );\n  var Vec3 = (\n    /** @class */\n    function() {\n      function Vec32(x2, y, z) {\n        if (!(this instanceof Vec32)) {\n          return new Vec32(x2, y, z);\n        }\n        if (typeof x2 === \"undefined\") {\n          this.x = 0;\n          this.y = 0;\n          this.z = 0;\n        } else if (typeof x2 === \"object\") {\n          this.x = x2.x;\n          this.y = x2.y;\n          this.z = x2.z;\n        } else {\n          this.x = x2;\n          this.y = y;\n          this.z = z;\n        }\n      }\n      Vec32.prototype._serialize = function() {\n        return {\n          x: this.x,\n          y: this.y,\n          z: this.z\n        };\n      };\n      Vec32._deserialize = function(data) {\n        var obj = Object.create(Vec32.prototype);\n        obj.x = data.x;\n        obj.y = data.y;\n        obj.z = data.z;\n        return obj;\n      };\n      Vec32.neo = function(x2, y, z) {\n        var obj = Object.create(Vec32.prototype);\n        obj.x = x2;\n        obj.y = y;\n        obj.z = z;\n        return obj;\n      };\n      Vec32.zero = function() {\n        var obj = Object.create(Vec32.prototype);\n        obj.x = 0;\n        obj.y = 0;\n        obj.z = 0;\n        return obj;\n      };\n      Vec32.clone = function(v3) {\n        return Vec32.neo(v3.x, v3.y, v3.z);\n      };\n      Vec32.prototype.toString = function() {\n        return JSON.stringify(this);\n      };\n      Vec32.isValid = function(obj) {\n        if (obj === null || typeof obj === \"undefined\") {\n          return false;\n        }\n        return Number.isFinite(obj.x) && Number.isFinite(obj.y) && Number.isFinite(obj.z);\n      };\n      Vec32.assert = function(o) {\n      };\n      Vec32.prototype.setZero = function() {\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        return this;\n      };\n      Vec32.prototype.set = function(x2, y, z) {\n        this.x = x2;\n        this.y = y;\n        this.z = z;\n        return this;\n      };\n      Vec32.prototype.add = function(w) {\n        this.x += w.x;\n        this.y += w.y;\n        this.z += w.z;\n        return this;\n      };\n      Vec32.prototype.sub = function(w) {\n        this.x -= w.x;\n        this.y -= w.y;\n        this.z -= w.z;\n        return this;\n      };\n      Vec32.prototype.mul = function(m) {\n        this.x *= m;\n        this.y *= m;\n        this.z *= m;\n        return this;\n      };\n      Vec32.areEqual = function(v3, w) {\n        return v3 === w || typeof v3 === \"object\" && v3 !== null && typeof w === \"object\" && w !== null && v3.x === w.x && v3.y === w.y && v3.z === w.z;\n      };\n      Vec32.dot = function(v3, w) {\n        return v3.x * w.x + v3.y * w.y + v3.z * w.z;\n      };\n      Vec32.cross = function(v3, w) {\n        return new Vec32(v3.y * w.z - v3.z * w.y, v3.z * w.x - v3.x * w.z, v3.x * w.y - v3.y * w.x);\n      };\n      Vec32.add = function(v3, w) {\n        return new Vec32(v3.x + w.x, v3.y + w.y, v3.z + w.z);\n      };\n      Vec32.sub = function(v3, w) {\n        return new Vec32(v3.x - w.x, v3.y - w.y, v3.z - w.z);\n      };\n      Vec32.mul = function(v3, m) {\n        return new Vec32(m * v3.x, m * v3.y, m * v3.z);\n      };\n      Vec32.prototype.neg = function() {\n        this.x = -this.x;\n        this.y = -this.y;\n        this.z = -this.z;\n        return this;\n      };\n      Vec32.neg = function(v3) {\n        return new Vec32(-v3.x, -v3.y, -v3.z);\n      };\n      return Vec32;\n    }()\n  );\n  var v1$2 = vec2(0, 0);\n  var v2$1 = vec2(0, 0);\n  var EdgeShape = (\n    /** @class */\n    function(_super) {\n      __extends(EdgeShape2, _super);\n      function EdgeShape2(v122, v22) {\n        var _this = this;\n        if (!(_this instanceof EdgeShape2)) {\n          return new EdgeShape2(v122, v22);\n        }\n        _this = _super.call(this) || this;\n        _this.m_type = EdgeShape2.TYPE;\n        _this.m_radius = SettingsInternal.polygonRadius;\n        _this.m_vertex1 = v122 ? Vec2.clone(v122) : Vec2.zero();\n        _this.m_vertex2 = v22 ? Vec2.clone(v22) : Vec2.zero();\n        _this.m_vertex0 = Vec2.zero();\n        _this.m_vertex3 = Vec2.zero();\n        _this.m_hasVertex0 = false;\n        _this.m_hasVertex3 = false;\n        return _this;\n      }\n      EdgeShape2.prototype._serialize = function() {\n        return {\n          type: this.m_type,\n          vertex1: this.m_vertex1,\n          vertex2: this.m_vertex2,\n          vertex0: this.m_vertex0,\n          vertex3: this.m_vertex3,\n          hasVertex0: this.m_hasVertex0,\n          hasVertex3: this.m_hasVertex3\n        };\n      };\n      EdgeShape2._deserialize = function(data) {\n        var shape = new EdgeShape2(data.vertex1, data.vertex2);\n        if (shape.m_hasVertex0) {\n          shape.setPrevVertex(data.vertex0);\n        }\n        if (shape.m_hasVertex3) {\n          shape.setNextVertex(data.vertex3);\n        }\n        return shape;\n      };\n      EdgeShape2.prototype._reset = function() {\n      };\n      EdgeShape2.prototype.getRadius = function() {\n        return this.m_radius;\n      };\n      EdgeShape2.prototype.getType = function() {\n        return this.m_type;\n      };\n      EdgeShape2.prototype.setNext = function(v3) {\n        return this.setNextVertex(v3);\n      };\n      EdgeShape2.prototype.setNextVertex = function(v3) {\n        if (v3) {\n          this.m_vertex3.setVec2(v3);\n          this.m_hasVertex3 = true;\n        } else {\n          this.m_vertex3.setZero();\n          this.m_hasVertex3 = false;\n        }\n        return this;\n      };\n      EdgeShape2.prototype.getNextVertex = function() {\n        return this.m_vertex3;\n      };\n      EdgeShape2.prototype.setPrev = function(v3) {\n        return this.setPrevVertex(v3);\n      };\n      EdgeShape2.prototype.setPrevVertex = function(v3) {\n        if (v3) {\n          this.m_vertex0.setVec2(v3);\n          this.m_hasVertex0 = true;\n        } else {\n          this.m_vertex0.setZero();\n          this.m_hasVertex0 = false;\n        }\n        return this;\n      };\n      EdgeShape2.prototype.getPrevVertex = function() {\n        return this.m_vertex0;\n      };\n      EdgeShape2.prototype._set = function(v122, v22) {\n        this.m_vertex1.setVec2(v122);\n        this.m_vertex2.setVec2(v22);\n        this.m_hasVertex0 = false;\n        this.m_hasVertex3 = false;\n        return this;\n      };\n      EdgeShape2.prototype._clone = function() {\n        var clone = new EdgeShape2();\n        clone.m_type = this.m_type;\n        clone.m_radius = this.m_radius;\n        clone.m_vertex1.setVec2(this.m_vertex1);\n        clone.m_vertex2.setVec2(this.m_vertex2);\n        clone.m_vertex0.setVec2(this.m_vertex0);\n        clone.m_vertex3.setVec2(this.m_vertex3);\n        clone.m_hasVertex0 = this.m_hasVertex0;\n        clone.m_hasVertex3 = this.m_hasVertex3;\n        return clone;\n      };\n      EdgeShape2.prototype.getChildCount = function() {\n        return 1;\n      };\n      EdgeShape2.prototype.testPoint = function(xf2, p) {\n        return false;\n      };\n      EdgeShape2.prototype.rayCast = function(output2, input2, xf2, childIndex) {\n        var p1 = Rot.mulTVec2(xf2.q, Vec2.sub(input2.p1, xf2.p));\n        var p2 = Rot.mulTVec2(xf2.q, Vec2.sub(input2.p2, xf2.p));\n        var d2 = Vec2.sub(p2, p1);\n        var v122 = this.m_vertex1;\n        var v22 = this.m_vertex2;\n        var e3 = Vec2.sub(v22, v122);\n        var normal3 = Vec2.neo(e3.y, -e3.x);\n        normal3.normalize();\n        var numerator = Vec2.dot(normal3, Vec2.sub(v122, p1));\n        var denominator = Vec2.dot(normal3, d2);\n        if (denominator == 0) {\n          return false;\n        }\n        var t = numerator / denominator;\n        if (t < 0 || input2.maxFraction < t) {\n          return false;\n        }\n        var q = Vec2.add(p1, Vec2.mulNumVec2(t, d2));\n        var r = Vec2.sub(v22, v122);\n        var rr = Vec2.dot(r, r);\n        if (rr == 0) {\n          return false;\n        }\n        var s2 = Vec2.dot(Vec2.sub(q, v122), r) / rr;\n        if (s2 < 0 || 1 < s2) {\n          return false;\n        }\n        output2.fraction = t;\n        if (numerator > 0) {\n          output2.normal = Rot.mulVec2(xf2.q, normal3).neg();\n        } else {\n          output2.normal = Rot.mulVec2(xf2.q, normal3);\n        }\n        return true;\n      };\n      EdgeShape2.prototype.computeAABB = function(aabb, xf2, childIndex) {\n        transformVec2(v1$2, xf2, this.m_vertex1);\n        transformVec2(v2$1, xf2, this.m_vertex2);\n        AABB.combinePoints(aabb, v1$2, v2$1);\n        AABB.extend(aabb, this.m_radius);\n      };\n      EdgeShape2.prototype.computeMass = function(massData, density) {\n        massData.mass = 0;\n        combine2Vec2(massData.center, 0.5, this.m_vertex1, 0.5, this.m_vertex2);\n        massData.I = 0;\n      };\n      EdgeShape2.prototype.computeDistanceProxy = function(proxy) {\n        proxy.m_vertices[0] = this.m_vertex1;\n        proxy.m_vertices[1] = this.m_vertex2;\n        proxy.m_vertices.length = 2;\n        proxy.m_count = 2;\n        proxy.m_radius = this.m_radius;\n      };\n      EdgeShape2.TYPE = \"edge\";\n      return EdgeShape2;\n    }(Shape)\n  );\n  var Edge = EdgeShape;\n  var v1$1 = vec2(0, 0);\n  var v2 = vec2(0, 0);\n  var ChainShape = (\n    /** @class */\n    function(_super) {\n      __extends(ChainShape2, _super);\n      function ChainShape2(vertices, loop) {\n        var _this = this;\n        if (!(_this instanceof ChainShape2)) {\n          return new ChainShape2(vertices, loop);\n        }\n        _this = _super.call(this) || this;\n        _this.m_type = ChainShape2.TYPE;\n        _this.m_radius = SettingsInternal.polygonRadius;\n        _this.m_vertices = [];\n        _this.m_count = 0;\n        _this.m_prevVertex = null;\n        _this.m_nextVertex = null;\n        _this.m_hasPrevVertex = false;\n        _this.m_hasNextVertex = false;\n        _this.m_isLoop = !!loop;\n        if (vertices && vertices.length) {\n          if (loop) {\n            _this._createLoop(vertices);\n          } else {\n            _this._createChain(vertices);\n          }\n        }\n        return _this;\n      }\n      ChainShape2.prototype._serialize = function() {\n        var data = {\n          type: this.m_type,\n          vertices: this.m_isLoop ? this.m_vertices.slice(0, this.m_vertices.length - 1) : this.m_vertices,\n          isLoop: this.m_isLoop,\n          hasPrevVertex: this.m_hasPrevVertex,\n          hasNextVertex: this.m_hasNextVertex,\n          prevVertex: null,\n          nextVertex: null\n        };\n        if (this.m_prevVertex) {\n          data.prevVertex = this.m_prevVertex;\n        }\n        if (this.m_nextVertex) {\n          data.nextVertex = this.m_nextVertex;\n        }\n        return data;\n      };\n      ChainShape2._deserialize = function(data, fixture, restore) {\n        var vertices = [];\n        if (data.vertices) {\n          for (var i = 0; i < data.vertices.length; i++) {\n            vertices.push(restore(Vec2, data.vertices[i]));\n          }\n        }\n        var shape = new ChainShape2(vertices, data.isLoop);\n        if (data.prevVertex) {\n          shape.setPrevVertex(data.prevVertex);\n        }\n        if (data.nextVertex) {\n          shape.setNextVertex(data.nextVertex);\n        }\n        return shape;\n      };\n      ChainShape2.prototype.getType = function() {\n        return this.m_type;\n      };\n      ChainShape2.prototype.getRadius = function() {\n        return this.m_radius;\n      };\n      ChainShape2.prototype._createLoop = function(vertices) {\n        if (vertices.length < 3) {\n          return;\n        }\n        for (var i = 1; i < vertices.length; ++i) {\n          vertices[i - 1];\n          vertices[i];\n        }\n        this.m_vertices = [];\n        this.m_count = vertices.length + 1;\n        for (var i = 0; i < vertices.length; ++i) {\n          this.m_vertices[i] = Vec2.clone(vertices[i]);\n        }\n        this.m_vertices[vertices.length] = Vec2.clone(vertices[0]);\n        this.m_prevVertex = this.m_vertices[this.m_count - 2];\n        this.m_nextVertex = this.m_vertices[1];\n        this.m_hasPrevVertex = true;\n        this.m_hasNextVertex = true;\n        return this;\n      };\n      ChainShape2.prototype._createChain = function(vertices) {\n        for (var i = 1; i < vertices.length; ++i) {\n          vertices[i - 1];\n          vertices[i];\n        }\n        this.m_vertices = [];\n        this.m_count = vertices.length;\n        for (var i = 0; i < vertices.length; ++i) {\n          this.m_vertices[i] = Vec2.clone(vertices[i]);\n        }\n        this.m_prevVertex = null;\n        this.m_nextVertex = null;\n        this.m_hasPrevVertex = false;\n        this.m_hasNextVertex = false;\n        return this;\n      };\n      ChainShape2.prototype._reset = function() {\n        if (this.m_isLoop) {\n          this._createLoop(this.m_vertices.slice(0, this.m_vertices.length - 1));\n        } else {\n          this._createChain(this.m_vertices);\n        }\n      };\n      ChainShape2.prototype.setPrevVertex = function(prevVertex) {\n        this.m_prevVertex = prevVertex;\n        this.m_hasPrevVertex = true;\n      };\n      ChainShape2.prototype.getPrevVertex = function() {\n        return this.m_prevVertex;\n      };\n      ChainShape2.prototype.setNextVertex = function(nextVertex) {\n        this.m_nextVertex = nextVertex;\n        this.m_hasNextVertex = true;\n      };\n      ChainShape2.prototype.getNextVertex = function() {\n        return this.m_nextVertex;\n      };\n      ChainShape2.prototype._clone = function() {\n        var clone = new ChainShape2();\n        clone._createChain(this.m_vertices);\n        clone.m_type = this.m_type;\n        clone.m_radius = this.m_radius;\n        clone.m_prevVertex = this.m_prevVertex;\n        clone.m_nextVertex = this.m_nextVertex;\n        clone.m_hasPrevVertex = this.m_hasPrevVertex;\n        clone.m_hasNextVertex = this.m_hasNextVertex;\n        return clone;\n      };\n      ChainShape2.prototype.getChildCount = function() {\n        return this.m_count - 1;\n      };\n      ChainShape2.prototype.getChildEdge = function(edge, childIndex) {\n        edge.m_type = EdgeShape.TYPE;\n        edge.m_radius = this.m_radius;\n        edge.m_vertex1 = this.m_vertices[childIndex];\n        edge.m_vertex2 = this.m_vertices[childIndex + 1];\n        if (childIndex > 0) {\n          edge.m_vertex0 = this.m_vertices[childIndex - 1];\n          edge.m_hasVertex0 = true;\n        } else {\n          edge.m_vertex0 = this.m_prevVertex;\n          edge.m_hasVertex0 = this.m_hasPrevVertex;\n        }\n        if (childIndex < this.m_count - 2) {\n          edge.m_vertex3 = this.m_vertices[childIndex + 2];\n          edge.m_hasVertex3 = true;\n        } else {\n          edge.m_vertex3 = this.m_nextVertex;\n          edge.m_hasVertex3 = this.m_hasNextVertex;\n        }\n      };\n      ChainShape2.prototype.getVertex = function(index) {\n        if (index < this.m_count) {\n          return this.m_vertices[index];\n        } else {\n          return this.m_vertices[0];\n        }\n      };\n      ChainShape2.prototype.isLoop = function() {\n        return this.m_isLoop;\n      };\n      ChainShape2.prototype.testPoint = function(xf2, p) {\n        return false;\n      };\n      ChainShape2.prototype.rayCast = function(output2, input2, xf2, childIndex) {\n        var edgeShape = new EdgeShape(this.getVertex(childIndex), this.getVertex(childIndex + 1));\n        return edgeShape.rayCast(output2, input2, xf2, 0);\n      };\n      ChainShape2.prototype.computeAABB = function(aabb, xf2, childIndex) {\n        transformVec2(v1$1, xf2, this.getVertex(childIndex));\n        transformVec2(v2, xf2, this.getVertex(childIndex + 1));\n        AABB.combinePoints(aabb, v1$1, v2);\n      };\n      ChainShape2.prototype.computeMass = function(massData, density) {\n        massData.mass = 0;\n        zeroVec2(massData.center);\n        massData.I = 0;\n      };\n      ChainShape2.prototype.computeDistanceProxy = function(proxy, childIndex) {\n        proxy.m_vertices[0] = this.getVertex(childIndex);\n        proxy.m_vertices[1] = this.getVertex(childIndex + 1);\n        proxy.m_count = 2;\n        proxy.m_radius = this.m_radius;\n      };\n      ChainShape2.TYPE = \"chain\";\n      return ChainShape2;\n    }(Shape)\n  );\n  var Chain = ChainShape;\n  var math_max$1 = Math.max;\n  var math_min$3 = Math.min;\n  var temp$1 = vec2(0, 0);\n  var e$1 = vec2(0, 0);\n  var e1$1 = vec2(0, 0);\n  var e2$1 = vec2(0, 0);\n  var center = vec2(0, 0);\n  var s = vec2(0, 0);\n  var PolygonShape = (\n    /** @class */\n    function(_super) {\n      __extends(PolygonShape2, _super);\n      function PolygonShape2(vertices) {\n        var _this = this;\n        if (!(_this instanceof PolygonShape2)) {\n          return new PolygonShape2(vertices);\n        }\n        _this = _super.call(this) || this;\n        _this.m_type = PolygonShape2.TYPE;\n        _this.m_radius = SettingsInternal.polygonRadius;\n        _this.m_centroid = Vec2.zero();\n        _this.m_vertices = [];\n        _this.m_normals = [];\n        _this.m_count = 0;\n        if (vertices && vertices.length) {\n          _this._set(vertices);\n        }\n        return _this;\n      }\n      PolygonShape2.prototype._serialize = function() {\n        return {\n          type: this.m_type,\n          vertices: this.m_vertices\n        };\n      };\n      PolygonShape2._deserialize = function(data, fixture, restore) {\n        var vertices = [];\n        if (data.vertices) {\n          for (var i = 0; i < data.vertices.length; i++) {\n            vertices.push(restore(Vec2, data.vertices[i]));\n          }\n        }\n        var shape = new PolygonShape2(vertices);\n        return shape;\n      };\n      PolygonShape2.prototype.getType = function() {\n        return this.m_type;\n      };\n      PolygonShape2.prototype.getRadius = function() {\n        return this.m_radius;\n      };\n      PolygonShape2.prototype._clone = function() {\n        var clone = new PolygonShape2();\n        clone.m_type = this.m_type;\n        clone.m_radius = this.m_radius;\n        clone.m_count = this.m_count;\n        clone.m_centroid.setVec2(this.m_centroid);\n        for (var i = 0; i < this.m_count; i++) {\n          clone.m_vertices.push(this.m_vertices[i].clone());\n        }\n        for (var i = 0; i < this.m_normals.length; i++) {\n          clone.m_normals.push(this.m_normals[i].clone());\n        }\n        return clone;\n      };\n      PolygonShape2.prototype.getChildCount = function() {\n        return 1;\n      };\n      PolygonShape2.prototype._reset = function() {\n        this._set(this.m_vertices);\n      };\n      PolygonShape2.prototype._set = function(vertices) {\n        if (vertices.length < 3) {\n          this._setAsBox(1, 1);\n          return;\n        }\n        var n2 = math_min$3(vertices.length, SettingsInternal.maxPolygonVertices);\n        var ps = [];\n        for (var i = 0; i < n2; ++i) {\n          var v3 = vertices[i];\n          var unique = true;\n          for (var j = 0; j < ps.length; ++j) {\n            if (Vec2.distanceSquared(v3, ps[j]) < 0.25 * SettingsInternal.linearSlopSquared) {\n              unique = false;\n              break;\n            }\n          }\n          if (unique) {\n            ps.push(Vec2.clone(v3));\n          }\n        }\n        n2 = ps.length;\n        if (n2 < 3) {\n          this._setAsBox(1, 1);\n          return;\n        }\n        var i0 = 0;\n        var x0 = ps[0].x;\n        for (var i = 1; i < n2; ++i) {\n          var x2 = ps[i].x;\n          if (x2 > x0 || x2 === x0 && ps[i].y < ps[i0].y) {\n            i0 = i;\n            x0 = x2;\n          }\n        }\n        var hull = [];\n        var m = 0;\n        var ih = i0;\n        while (true) {\n          hull[m] = ih;\n          var ie2 = 0;\n          for (var j = 1; j < n2; ++j) {\n            if (ie2 === ih) {\n              ie2 = j;\n              continue;\n            }\n            var r = Vec2.sub(ps[ie2], ps[hull[m]]);\n            var v3 = Vec2.sub(ps[j], ps[hull[m]]);\n            var c2 = Vec2.crossVec2Vec2(r, v3);\n            if (c2 < 0) {\n              ie2 = j;\n            }\n            if (c2 === 0 && v3.lengthSquared() > r.lengthSquared()) {\n              ie2 = j;\n            }\n          }\n          ++m;\n          ih = ie2;\n          if (ie2 === i0) {\n            break;\n          }\n        }\n        if (m < 3) {\n          this._setAsBox(1, 1);\n          return;\n        }\n        this.m_count = m;\n        this.m_vertices = [];\n        for (var i = 0; i < m; ++i) {\n          this.m_vertices[i] = ps[hull[i]];\n        }\n        for (var i = 0; i < m; ++i) {\n          var i1 = i;\n          var i2 = i + 1 < m ? i + 1 : 0;\n          var edge = Vec2.sub(this.m_vertices[i2], this.m_vertices[i1]);\n          this.m_normals[i] = Vec2.crossVec2Num(edge, 1);\n          this.m_normals[i].normalize();\n        }\n        this.m_centroid = computeCentroid(this.m_vertices, m);\n      };\n      PolygonShape2.prototype._setAsBox = function(hx, hy, center2, angle) {\n        this.m_vertices[0] = Vec2.neo(hx, -hy);\n        this.m_vertices[1] = Vec2.neo(hx, hy);\n        this.m_vertices[2] = Vec2.neo(-hx, hy);\n        this.m_vertices[3] = Vec2.neo(-hx, -hy);\n        this.m_normals[0] = Vec2.neo(1, 0);\n        this.m_normals[1] = Vec2.neo(0, 1);\n        this.m_normals[2] = Vec2.neo(-1, 0);\n        this.m_normals[3] = Vec2.neo(0, -1);\n        this.m_count = 4;\n        if (center2 && Vec2.isValid(center2)) {\n          angle = angle || 0;\n          copyVec2(this.m_centroid, center2);\n          var xf2 = Transform.identity();\n          xf2.p.setVec2(center2);\n          xf2.q.setAngle(angle);\n          for (var i = 0; i < this.m_count; ++i) {\n            this.m_vertices[i] = Transform.mulVec2(xf2, this.m_vertices[i]);\n            this.m_normals[i] = Rot.mulVec2(xf2.q, this.m_normals[i]);\n          }\n        }\n      };\n      PolygonShape2.prototype.testPoint = function(xf2, p) {\n        var pLocal = detransformVec2(temp$1, xf2, p);\n        for (var i = 0; i < this.m_count; ++i) {\n          var dot = dotVec2(this.m_normals[i], pLocal) - dotVec2(this.m_normals[i], this.m_vertices[i]);\n          if (dot > 0) {\n            return false;\n          }\n        }\n        return true;\n      };\n      PolygonShape2.prototype.rayCast = function(output2, input2, xf2, childIndex) {\n        var p1 = Rot.mulTVec2(xf2.q, Vec2.sub(input2.p1, xf2.p));\n        var p2 = Rot.mulTVec2(xf2.q, Vec2.sub(input2.p2, xf2.p));\n        var d2 = Vec2.sub(p2, p1);\n        var lower = 0;\n        var upper = input2.maxFraction;\n        var index = -1;\n        for (var i = 0; i < this.m_count; ++i) {\n          var numerator = Vec2.dot(this.m_normals[i], Vec2.sub(this.m_vertices[i], p1));\n          var denominator = Vec2.dot(this.m_normals[i], d2);\n          if (denominator == 0) {\n            if (numerator < 0) {\n              return false;\n            }\n          } else {\n            if (denominator < 0 && numerator < lower * denominator) {\n              lower = numerator / denominator;\n              index = i;\n            } else if (denominator > 0 && numerator < upper * denominator) {\n              upper = numerator / denominator;\n            }\n          }\n          if (upper < lower) {\n            return false;\n          }\n        }\n        if (index >= 0) {\n          output2.fraction = lower;\n          output2.normal = Rot.mulVec2(xf2.q, this.m_normals[index]);\n          return true;\n        }\n        return false;\n      };\n      PolygonShape2.prototype.computeAABB = function(aabb, xf2, childIndex) {\n        var minX = Infinity;\n        var minY = Infinity;\n        var maxX = -Infinity;\n        var maxY = -Infinity;\n        for (var i = 0; i < this.m_count; ++i) {\n          var v3 = transformVec2(temp$1, xf2, this.m_vertices[i]);\n          minX = math_min$3(minX, v3.x);\n          maxX = math_max$1(maxX, v3.x);\n          minY = math_min$3(minY, v3.y);\n          maxY = math_max$1(maxY, v3.y);\n        }\n        setVec2(aabb.lowerBound, minX - this.m_radius, minY - this.m_radius);\n        setVec2(aabb.upperBound, maxX + this.m_radius, maxY + this.m_radius);\n      };\n      PolygonShape2.prototype.computeMass = function(massData, density) {\n        zeroVec2(center);\n        var area = 0;\n        var I = 0;\n        zeroVec2(s);\n        for (var i = 0; i < this.m_count; ++i) {\n          plusVec2(s, this.m_vertices[i]);\n        }\n        scaleVec2(s, 1 / this.m_count, s);\n        var k_inv3 = 1 / 3;\n        for (var i = 0; i < this.m_count; ++i) {\n          subVec2(e1$1, this.m_vertices[i], s);\n          if (i + 1 < this.m_count) {\n            subVec2(e2$1, this.m_vertices[i + 1], s);\n          } else {\n            subVec2(e2$1, this.m_vertices[0], s);\n          }\n          var D = crossVec2Vec2(e1$1, e2$1);\n          var triangleArea = 0.5 * D;\n          area += triangleArea;\n          combine2Vec2(temp$1, triangleArea * k_inv3, e1$1, triangleArea * k_inv3, e2$1);\n          plusVec2(center, temp$1);\n          var ex1 = e1$1.x;\n          var ey1 = e1$1.y;\n          var ex2 = e2$1.x;\n          var ey2 = e2$1.y;\n          var intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;\n          var inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;\n          I += 0.25 * k_inv3 * D * (intx2 + inty2);\n        }\n        massData.mass = density * area;\n        scaleVec2(center, 1 / area, center);\n        addVec2(massData.center, center, s);\n        massData.I = density * I;\n        massData.I += massData.mass * (dotVec2(massData.center, massData.center) - dotVec2(center, center));\n      };\n      PolygonShape2.prototype.validate = function() {\n        for (var i = 0; i < this.m_count; ++i) {\n          var i1 = i;\n          var i2 = i < this.m_count - 1 ? i1 + 1 : 0;\n          var p = this.m_vertices[i1];\n          subVec2(e$1, this.m_vertices[i2], p);\n          for (var j = 0; j < this.m_count; ++j) {\n            if (j == i1 || j == i2) {\n              continue;\n            }\n            var c2 = crossVec2Vec2(e$1, subVec2(temp$1, this.m_vertices[j], p));\n            if (c2 < 0) {\n              return false;\n            }\n          }\n        }\n        return true;\n      };\n      PolygonShape2.prototype.computeDistanceProxy = function(proxy) {\n        for (var i = 0; i < this.m_count; ++i) {\n          proxy.m_vertices[i] = this.m_vertices[i];\n        }\n        proxy.m_vertices.length = this.m_count;\n        proxy.m_count = this.m_count;\n        proxy.m_radius = this.m_radius;\n      };\n      PolygonShape2.TYPE = \"polygon\";\n      return PolygonShape2;\n    }(Shape)\n  );\n  function computeCentroid(vs, count) {\n    var c2 = Vec2.zero();\n    var area = 0;\n    var pRef = Vec2.zero();\n    var i;\n    var inv3 = 1 / 3;\n    for (var i = 0; i < count; ++i) {\n      var p1 = pRef;\n      var p2 = vs[i];\n      var p3 = i + 1 < count ? vs[i + 1] : vs[0];\n      var e1_1 = Vec2.sub(p2, p1);\n      var e2_1 = Vec2.sub(p3, p1);\n      var D = Vec2.crossVec2Vec2(e1_1, e2_1);\n      var triangleArea = 0.5 * D;\n      area += triangleArea;\n      combine3Vec2(temp$1, 1, p1, 1, p2, 1, p3);\n      plusScaleVec2(c2, triangleArea * inv3, temp$1);\n    }\n    c2.mul(1 / area);\n    return c2;\n  }\n  var Polygon = PolygonShape;\n  var math_sqrt = Math.sqrt;\n  var math_PI$4 = Math.PI;\n  var temp = vec2(0, 0);\n  var CircleShape = (\n    /** @class */\n    function(_super) {\n      __extends(CircleShape2, _super);\n      function CircleShape2(a2, b2) {\n        var _this = this;\n        if (!(_this instanceof CircleShape2)) {\n          return new CircleShape2(a2, b2);\n        }\n        _this = _super.call(this) || this;\n        _this.m_type = CircleShape2.TYPE;\n        _this.m_p = Vec2.zero();\n        _this.m_radius = 1;\n        if (typeof a2 === \"object\" && Vec2.isValid(a2)) {\n          _this.m_p.setVec2(a2);\n          if (typeof b2 === \"number\") {\n            _this.m_radius = b2;\n          }\n        } else if (typeof a2 === \"number\") {\n          _this.m_radius = a2;\n        }\n        return _this;\n      }\n      CircleShape2.prototype._serialize = function() {\n        return {\n          type: this.m_type,\n          p: this.m_p,\n          radius: this.m_radius\n        };\n      };\n      CircleShape2._deserialize = function(data) {\n        return new CircleShape2(data.p, data.radius);\n      };\n      CircleShape2.prototype._reset = function() {\n      };\n      CircleShape2.prototype.getType = function() {\n        return this.m_type;\n      };\n      CircleShape2.prototype.getRadius = function() {\n        return this.m_radius;\n      };\n      CircleShape2.prototype.getCenter = function() {\n        return this.m_p;\n      };\n      CircleShape2.prototype._clone = function() {\n        var clone = new CircleShape2();\n        clone.m_type = this.m_type;\n        clone.m_radius = this.m_radius;\n        clone.m_p = this.m_p.clone();\n        return clone;\n      };\n      CircleShape2.prototype.getChildCount = function() {\n        return 1;\n      };\n      CircleShape2.prototype.testPoint = function(xf2, p) {\n        var center2 = transformVec2(temp, xf2, this.m_p);\n        return distSqrVec2(p, center2) <= this.m_radius * this.m_radius;\n      };\n      CircleShape2.prototype.rayCast = function(output2, input2, xf2, childIndex) {\n        var position = Vec2.add(xf2.p, Rot.mulVec2(xf2.q, this.m_p));\n        var s2 = Vec2.sub(input2.p1, position);\n        var b2 = Vec2.dot(s2, s2) - this.m_radius * this.m_radius;\n        var r = Vec2.sub(input2.p2, input2.p1);\n        var c2 = Vec2.dot(s2, r);\n        var rr = Vec2.dot(r, r);\n        var sigma = c2 * c2 - rr * b2;\n        if (sigma < 0 || rr < EPSILON) {\n          return false;\n        }\n        var a2 = -(c2 + math_sqrt(sigma));\n        if (0 <= a2 && a2 <= input2.maxFraction * rr) {\n          a2 /= rr;\n          output2.fraction = a2;\n          output2.normal = Vec2.add(s2, Vec2.mulNumVec2(a2, r));\n          output2.normal.normalize();\n          return true;\n        }\n        return false;\n      };\n      CircleShape2.prototype.computeAABB = function(aabb, xf2, childIndex) {\n        var p = transformVec2(temp, xf2, this.m_p);\n        setVec2(aabb.lowerBound, p.x - this.m_radius, p.y - this.m_radius);\n        setVec2(aabb.upperBound, p.x + this.m_radius, p.y + this.m_radius);\n      };\n      CircleShape2.prototype.computeMass = function(massData, density) {\n        massData.mass = density * math_PI$4 * this.m_radius * this.m_radius;\n        copyVec2(massData.center, this.m_p);\n        massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + lengthSqrVec2(this.m_p));\n      };\n      CircleShape2.prototype.computeDistanceProxy = function(proxy) {\n        proxy.m_vertices[0] = this.m_p;\n        proxy.m_vertices.length = 1;\n        proxy.m_count = 1;\n        proxy.m_radius = this.m_radius;\n      };\n      CircleShape2.TYPE = \"circle\";\n      return CircleShape2;\n    }(Shape)\n  );\n  var Circle = CircleShape;\n  var math_abs$5 = Math.abs;\n  var math_PI$3 = Math.PI;\n  var DEFAULTS$a = {\n    frequencyHz: 0,\n    dampingRatio: 0\n  };\n  var DistanceJoint = (\n    /** @class */\n    function(_super) {\n      __extends(DistanceJoint2, _super);\n      function DistanceJoint2(def, bodyA, bodyB, anchorA, anchorB) {\n        var _this = this;\n        if (!(_this instanceof DistanceJoint2)) {\n          return new DistanceJoint2(def, bodyA, bodyB, anchorA, anchorB);\n        }\n        if (bodyB && anchorA && \"m_type\" in anchorA && \"x\" in bodyB && \"y\" in bodyB) {\n          var temp3 = bodyB;\n          bodyB = anchorA;\n          anchorA = temp3;\n        }\n        def = options(def, DEFAULTS$a);\n        _this = _super.call(this, def, bodyA, bodyB) || this;\n        bodyA = _this.m_bodyA;\n        bodyB = _this.m_bodyB;\n        _this.m_type = DistanceJoint2.TYPE;\n        _this.m_localAnchorA = Vec2.clone(anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.zero());\n        _this.m_localAnchorB = Vec2.clone(anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.zero());\n        _this.m_length = Number.isFinite(def.length) ? def.length : Vec2.distance(bodyA.getWorldPoint(_this.m_localAnchorA), bodyB.getWorldPoint(_this.m_localAnchorB));\n        _this.m_frequencyHz = def.frequencyHz;\n        _this.m_dampingRatio = def.dampingRatio;\n        _this.m_impulse = 0;\n        _this.m_gamma = 0;\n        _this.m_bias = 0;\n        return _this;\n      }\n      DistanceJoint2.prototype._serialize = function() {\n        return {\n          type: this.m_type,\n          bodyA: this.m_bodyA,\n          bodyB: this.m_bodyB,\n          collideConnected: this.m_collideConnected,\n          frequencyHz: this.m_frequencyHz,\n          dampingRatio: this.m_dampingRatio,\n          localAnchorA: this.m_localAnchorA,\n          localAnchorB: this.m_localAnchorB,\n          length: this.m_length,\n          impulse: this.m_impulse,\n          gamma: this.m_gamma,\n          bias: this.m_bias\n        };\n      };\n      DistanceJoint2._deserialize = function(data, world, restore) {\n        data = __assign({}, data);\n        data.bodyA = restore(Body, data.bodyA, world);\n        data.bodyB = restore(Body, data.bodyB, world);\n        var joint = new DistanceJoint2(data);\n        return joint;\n      };\n      DistanceJoint2.prototype._reset = function(def) {\n        if (def.anchorA) {\n          this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n        } else if (def.localAnchorA) {\n          this.m_localAnchorA.setVec2(def.localAnchorA);\n        }\n        if (def.anchorB) {\n          this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n        } else if (def.localAnchorB) {\n          this.m_localAnchorB.setVec2(def.localAnchorB);\n        }\n        if (def.length > 0) {\n          this.m_length = +def.length;\n        } else if (def.length < 0) ;\n        else if (def.anchorA || def.anchorA || def.anchorA || def.anchorA) {\n          this.m_length = Vec2.distance(this.m_bodyA.getWorldPoint(this.m_localAnchorA), this.m_bodyB.getWorldPoint(this.m_localAnchorB));\n        }\n        if (Number.isFinite(def.frequencyHz)) {\n          this.m_frequencyHz = def.frequencyHz;\n        }\n        if (Number.isFinite(def.dampingRatio)) {\n          this.m_dampingRatio = def.dampingRatio;\n        }\n      };\n      DistanceJoint2.prototype.getLocalAnchorA = function() {\n        return this.m_localAnchorA;\n      };\n      DistanceJoint2.prototype.getLocalAnchorB = function() {\n        return this.m_localAnchorB;\n      };\n      DistanceJoint2.prototype.setLength = function(length) {\n        this.m_length = length;\n      };\n      DistanceJoint2.prototype.getLength = function() {\n        return this.m_length;\n      };\n      DistanceJoint2.prototype.setFrequency = function(hz) {\n        this.m_frequencyHz = hz;\n      };\n      DistanceJoint2.prototype.getFrequency = function() {\n        return this.m_frequencyHz;\n      };\n      DistanceJoint2.prototype.setDampingRatio = function(ratio) {\n        this.m_dampingRatio = ratio;\n      };\n      DistanceJoint2.prototype.getDampingRatio = function() {\n        return this.m_dampingRatio;\n      };\n      DistanceJoint2.prototype.getAnchorA = function() {\n        return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n      };\n      DistanceJoint2.prototype.getAnchorB = function() {\n        return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n      };\n      DistanceJoint2.prototype.getReactionForce = function(inv_dt) {\n        return Vec2.mulNumVec2(this.m_impulse, this.m_u).mul(inv_dt);\n      };\n      DistanceJoint2.prototype.getReactionTorque = function(inv_dt) {\n        return 0;\n      };\n      DistanceJoint2.prototype.initVelocityConstraints = function(step) {\n        this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n        this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n        this.m_invMassA = this.m_bodyA.m_invMass;\n        this.m_invMassB = this.m_bodyB.m_invMass;\n        this.m_invIA = this.m_bodyA.m_invI;\n        this.m_invIB = this.m_bodyB.m_invI;\n        var cA2 = this.m_bodyA.c_position.c;\n        var aA = this.m_bodyA.c_position.a;\n        var vA2 = this.m_bodyA.c_velocity.v;\n        var wA = this.m_bodyA.c_velocity.w;\n        var cB2 = this.m_bodyB.c_position.c;\n        var aB = this.m_bodyB.c_position.a;\n        var vB2 = this.m_bodyB.c_velocity.v;\n        var wB = this.m_bodyB.c_velocity.w;\n        var qA = Rot.neo(aA);\n        var qB = Rot.neo(aB);\n        this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n        this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n        this.m_u = Vec2.sub(Vec2.add(cB2, this.m_rB), Vec2.add(cA2, this.m_rA));\n        var length = this.m_u.length();\n        if (length > SettingsInternal.linearSlop) {\n          this.m_u.mul(1 / length);\n        } else {\n          this.m_u.setNum(0, 0);\n        }\n        var crAu = Vec2.crossVec2Vec2(this.m_rA, this.m_u);\n        var crBu = Vec2.crossVec2Vec2(this.m_rB, this.m_u);\n        var invMass = this.m_invMassA + this.m_invIA * crAu * crAu + this.m_invMassB + this.m_invIB * crBu * crBu;\n        this.m_mass = invMass != 0 ? 1 / invMass : 0;\n        if (this.m_frequencyHz > 0) {\n          var C = length - this.m_length;\n          var omega = 2 * math_PI$3 * this.m_frequencyHz;\n          var d2 = 2 * this.m_mass * this.m_dampingRatio * omega;\n          var k = this.m_mass * omega * omega;\n          var h = step.dt;\n          this.m_gamma = h * (d2 + h * k);\n          this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0;\n          this.m_bias = C * h * k * this.m_gamma;\n          invMass += this.m_gamma;\n          this.m_mass = invMass != 0 ? 1 / invMass : 0;\n        } else {\n          this.m_gamma = 0;\n          this.m_bias = 0;\n        }\n        if (step.warmStarting) {\n          this.m_impulse *= step.dtRatio;\n          var P3 = Vec2.mulNumVec2(this.m_impulse, this.m_u);\n          vA2.subMul(this.m_invMassA, P3);\n          wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P3);\n          vB2.addMul(this.m_invMassB, P3);\n          wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P3);\n        } else {\n          this.m_impulse = 0;\n        }\n        this.m_bodyA.c_velocity.v.setVec2(vA2);\n        this.m_bodyA.c_velocity.w = wA;\n        this.m_bodyB.c_velocity.v.setVec2(vB2);\n        this.m_bodyB.c_velocity.w = wB;\n      };\n      DistanceJoint2.prototype.solveVelocityConstraints = function(step) {\n        var vA2 = this.m_bodyA.c_velocity.v;\n        var wA = this.m_bodyA.c_velocity.w;\n        var vB2 = this.m_bodyB.c_velocity.v;\n        var wB = this.m_bodyB.c_velocity.w;\n        var vpA = Vec2.add(vA2, Vec2.crossNumVec2(wA, this.m_rA));\n        var vpB = Vec2.add(vB2, Vec2.crossNumVec2(wB, this.m_rB));\n        var Cdot = Vec2.dot(this.m_u, vpB) - Vec2.dot(this.m_u, vpA);\n        var impulse = -this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);\n        this.m_impulse += impulse;\n        var P3 = Vec2.mulNumVec2(impulse, this.m_u);\n        vA2.subMul(this.m_invMassA, P3);\n        wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P3);\n        vB2.addMul(this.m_invMassB, P3);\n        wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P3);\n        this.m_bodyA.c_velocity.v.setVec2(vA2);\n        this.m_bodyA.c_velocity.w = wA;\n        this.m_bodyB.c_velocity.v.setVec2(vB2);\n        this.m_bodyB.c_velocity.w = wB;\n      };\n      DistanceJoint2.prototype.solvePositionConstraints = function(step) {\n        if (this.m_frequencyHz > 0) {\n          return true;\n        }\n        var cA2 = this.m_bodyA.c_position.c;\n        var aA = this.m_bodyA.c_position.a;\n        var cB2 = this.m_bodyB.c_position.c;\n        var aB = this.m_bodyB.c_position.a;\n        var qA = Rot.neo(aA);\n        var qB = Rot.neo(aB);\n        var rA2 = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n        var rB2 = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n        var u = Vec2.sub(Vec2.add(cB2, rB2), Vec2.add(cA2, rA2));\n        var length = u.normalize();\n        var C = clamp(length - this.m_length, -SettingsInternal.maxLinearCorrection, SettingsInternal.maxLinearCorrection);\n        var impulse = -this.m_mass * C;\n        var P3 = Vec2.mulNumVec2(impulse, u);\n        cA2.subMul(this.m_invMassA, P3);\n        aA -= this.m_invIA * Vec2.crossVec2Vec2(rA2, P3);\n        cB2.addMul(this.m_invMassB, P3);\n        aB += this.m_invIB * Vec2.crossVec2Vec2(rB2, P3);\n        this.m_bodyA.c_position.c.setVec2(cA2);\n        this.m_bodyA.c_position.a = aA;\n        this.m_bodyB.c_position.c.setVec2(cB2);\n        this.m_bodyB.c_position.a = aB;\n        return math_abs$5(C) < SettingsInternal.linearSlop;\n      };\n      DistanceJoint2.TYPE = \"distance-joint\";\n      return DistanceJoint2;\n    }(Joint)\n  );\n  var DEFAULTS$9 = {\n    maxForce: 0,\n    maxTorque: 0\n  };\n  var FrictionJoint = (\n    /** @class */\n    function(_super) {\n      __extends(FrictionJoint2, _super);\n      function FrictionJoint2(def, bodyA, bodyB, anchor) {\n        var _this = this;\n        if (!(_this instanceof FrictionJoint2)) {\n          return new FrictionJoint2(def, bodyA, bodyB, anchor);\n        }\n        def = options(def, DEFAULTS$9);\n        _this = _super.call(this, def, bodyA, bodyB) || this;\n        bodyA = _this.m_bodyA;\n        bodyB = _this.m_bodyB;\n        _this.m_type = FrictionJoint2.TYPE;\n        _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n        _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n        _this.m_linearImpulse = Vec2.zero();\n        _this.m_angularImpulse = 0;\n        _this.m_maxForce = def.maxForce;\n        _this.m_maxTorque = def.maxTorque;\n        return _this;\n      }\n      FrictionJoint2.prototype._serialize = function() {\n        return {\n          type: this.m_type,\n          bodyA: this.m_bodyA,\n          bodyB: this.m_bodyB,\n          collideConnected: this.m_collideConnected,\n          maxForce: this.m_maxForce,\n          maxTorque: this.m_maxTorque,\n          localAnchorA: this.m_localAnchorA,\n          localAnchorB: this.m_localAnchorB\n        };\n      };\n      FrictionJoint2._deserialize = function(data, world, restore) {\n        data = __assign({}, data);\n        data.bodyA = restore(Body, data.bodyA, world);\n        data.bodyB = restore(Body, data.bodyB, world);\n        var joint = new FrictionJoint2(data);\n        return joint;\n      };\n      FrictionJoint2.prototype._reset = function(def) {\n        if (def.anchorA) {\n          this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n        } else if (def.localAnchorA) {\n          this.m_localAnchorA.setVec2(def.localAnchorA);\n        }\n        if (def.anchorB) {\n          this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n        } else if (def.localAnchorB) {\n          this.m_localAnchorB.setVec2(def.localAnchorB);\n        }\n        if (Number.isFinite(def.maxForce)) {\n          this.m_maxForce = def.maxForce;\n        }\n        if (Number.isFinite(def.maxTorque)) {\n          this.m_maxTorque = def.maxTorque;\n        }\n      };\n      FrictionJoint2.prototype.getLocalAnchorA = function() {\n        return this.m_localAnchorA;\n      };\n      FrictionJoint2.prototype.getLocalAnchorB = function() {\n        return this.m_localAnchorB;\n      };\n      FrictionJoint2.prototype.setMaxForce = function(force) {\n        this.m_maxForce = force;\n      };\n      FrictionJoint2.prototype.getMaxForce = function() {\n        return this.m_maxForce;\n      };\n      FrictionJoint2.prototype.setMaxTorque = function(torque) {\n        this.m_maxTorque = torque;\n      };\n      FrictionJoint2.prototype.getMaxTorque = function() {\n        return this.m_maxTorque;\n      };\n      FrictionJoint2.prototype.getAnchorA = function() {\n        return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n      };\n      FrictionJoint2.prototype.getAnchorB = function() {\n        return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n      };\n      FrictionJoint2.prototype.getReactionForce = function(inv_dt) {\n        return Vec2.mulNumVec2(inv_dt, this.m_linearImpulse);\n      };\n      FrictionJoint2.prototype.getReactionTorque = function(inv_dt) {\n        return inv_dt * this.m_angularImpulse;\n      };\n      FrictionJoint2.prototype.initVelocityConstraints = function(step) {\n        this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n        this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n        this.m_invMassA = this.m_bodyA.m_invMass;\n        this.m_invMassB = this.m_bodyB.m_invMass;\n        this.m_invIA = this.m_bodyA.m_invI;\n        this.m_invIB = this.m_bodyB.m_invI;\n        var aA = this.m_bodyA.c_position.a;\n        var vA2 = this.m_bodyA.c_velocity.v;\n        var wA = this.m_bodyA.c_velocity.w;\n        var aB = this.m_bodyB.c_position.a;\n        var vB2 = this.m_bodyB.c_velocity.v;\n        var wB = this.m_bodyB.c_velocity.w;\n        var qA = Rot.neo(aA);\n        var qB = Rot.neo(aB);\n        this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n        this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n        var mA = this.m_invMassA;\n        var mB = this.m_invMassB;\n        var iA = this.m_invIA;\n        var iB = this.m_invIB;\n        var K = new Mat22();\n        K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y * this.m_rB.y;\n        K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;\n        K.ey.x = K.ex.y;\n        K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x * this.m_rB.x;\n        this.m_linearMass = K.getInverse();\n        this.m_angularMass = iA + iB;\n        if (this.m_angularMass > 0) {\n          this.m_angularMass = 1 / this.m_angularMass;\n        }\n        if (step.warmStarting) {\n          this.m_linearImpulse.mul(step.dtRatio);\n          this.m_angularImpulse *= step.dtRatio;\n          var P3 = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);\n          vA2.subMul(mA, P3);\n          wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P3) + this.m_angularImpulse);\n          vB2.addMul(mB, P3);\n          wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P3) + this.m_angularImpulse);\n        } else {\n          this.m_linearImpulse.setZero();\n          this.m_angularImpulse = 0;\n        }\n        this.m_bodyA.c_velocity.v = vA2;\n        this.m_bodyA.c_velocity.w = wA;\n        this.m_bodyB.c_velocity.v = vB2;\n        this.m_bodyB.c_velocity.w = wB;\n      };\n      FrictionJoint2.prototype.solveVelocityConstraints = function(step) {\n        var vA2 = this.m_bodyA.c_velocity.v;\n        var wA = this.m_bodyA.c_velocity.w;\n        var vB2 = this.m_bodyB.c_velocity.v;\n        var wB = this.m_bodyB.c_velocity.w;\n        var mA = this.m_invMassA;\n        var mB = this.m_invMassB;\n        var iA = this.m_invIA;\n        var iB = this.m_invIB;\n        var h = step.dt;\n        {\n          var Cdot = wB - wA;\n          var impulse = -this.m_angularMass * Cdot;\n          var oldImpulse = this.m_angularImpulse;\n          var maxImpulse = h * this.m_maxTorque;\n          this.m_angularImpulse = clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);\n          impulse = this.m_angularImpulse - oldImpulse;\n          wA -= iA * impulse;\n          wB += iB * impulse;\n        }\n        {\n          var Cdot = Vec2.sub(Vec2.add(vB2, Vec2.crossNumVec2(wB, this.m_rB)), Vec2.add(vA2, Vec2.crossNumVec2(wA, this.m_rA)));\n          var impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot));\n          var oldImpulse = this.m_linearImpulse;\n          this.m_linearImpulse.add(impulse);\n          var maxImpulse = h * this.m_maxForce;\n          if (this.m_linearImpulse.lengthSquared() > maxImpulse * maxImpulse) {\n            this.m_linearImpulse.normalize();\n            this.m_linearImpulse.mul(maxImpulse);\n          }\n          impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);\n          vA2.subMul(mA, impulse);\n          wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n          vB2.addMul(mB, impulse);\n          wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n        }\n        this.m_bodyA.c_velocity.v = vA2;\n        this.m_bodyA.c_velocity.w = wA;\n        this.m_bodyB.c_velocity.v = vB2;\n        this.m_bodyB.c_velocity.w = wB;\n      };\n      FrictionJoint2.prototype.solvePositionConstraints = function(step) {\n        return true;\n      };\n      FrictionJoint2.TYPE = \"friction-joint\";\n      return FrictionJoint2;\n    }(Joint)\n  );\n  var Mat33 = (\n    /** @class */\n    function() {\n      function Mat332(a2, b2, c2) {\n        if (typeof a2 === \"object\" && a2 !== null) {\n          this.ex = Vec3.clone(a2);\n          this.ey = Vec3.clone(b2);\n          this.ez = Vec3.clone(c2);\n        } else {\n          this.ex = Vec3.zero();\n          this.ey = Vec3.zero();\n          this.ez = Vec3.zero();\n        }\n      }\n      Mat332.prototype.toString = function() {\n        return JSON.stringify(this);\n      };\n      Mat332.isValid = function(obj) {\n        if (obj === null || typeof obj === \"undefined\") {\n          return false;\n        }\n        return Vec3.isValid(obj.ex) && Vec3.isValid(obj.ey) && Vec3.isValid(obj.ez);\n      };\n      Mat332.assert = function(o) {\n      };\n      Mat332.prototype.setZero = function() {\n        this.ex.setZero();\n        this.ey.setZero();\n        this.ez.setZero();\n        return this;\n      };\n      Mat332.prototype.solve33 = function(v3) {\n        var cross_x = this.ey.y * this.ez.z - this.ey.z * this.ez.y;\n        var cross_y = this.ey.z * this.ez.x - this.ey.x * this.ez.z;\n        var cross_z = this.ey.x * this.ez.y - this.ey.y * this.ez.x;\n        var det = this.ex.x * cross_x + this.ex.y * cross_y + this.ex.z * cross_z;\n        if (det !== 0) {\n          det = 1 / det;\n        }\n        var r = new Vec3();\n        cross_x = this.ey.y * this.ez.z - this.ey.z * this.ez.y;\n        cross_y = this.ey.z * this.ez.x - this.ey.x * this.ez.z;\n        cross_z = this.ey.x * this.ez.y - this.ey.y * this.ez.x;\n        r.x = det * (v3.x * cross_x + v3.y * cross_y + v3.z * cross_z);\n        cross_x = v3.y * this.ez.z - v3.z * this.ez.y;\n        cross_y = v3.z * this.ez.x - v3.x * this.ez.z;\n        cross_z = v3.x * this.ez.y - v3.y * this.ez.x;\n        r.y = det * (this.ex.x * cross_x + this.ex.y * cross_y + this.ex.z * cross_z);\n        cross_x = this.ey.y * v3.z - this.ey.z * v3.y;\n        cross_y = this.ey.z * v3.x - this.ey.x * v3.z;\n        cross_z = this.ey.x * v3.y - this.ey.y * v3.x;\n        r.z = det * (this.ex.x * cross_x + this.ex.y * cross_y + this.ex.z * cross_z);\n        return r;\n      };\n      Mat332.prototype.solve22 = function(v3) {\n        var a11 = this.ex.x;\n        var a12 = this.ey.x;\n        var a21 = this.ex.y;\n        var a22 = this.ey.y;\n        var det = a11 * a22 - a12 * a21;\n        if (det !== 0) {\n          det = 1 / det;\n        }\n        var r = Vec2.zero();\n        r.x = det * (a22 * v3.x - a12 * v3.y);\n        r.y = det * (a11 * v3.y - a21 * v3.x);\n        return r;\n      };\n      Mat332.prototype.getInverse22 = function(M) {\n        var a2 = this.ex.x;\n        var b2 = this.ey.x;\n        var c2 = this.ex.y;\n        var d2 = this.ey.y;\n        var det = a2 * d2 - b2 * c2;\n        if (det !== 0) {\n          det = 1 / det;\n        }\n        M.ex.x = det * d2;\n        M.ey.x = -det * b2;\n        M.ex.z = 0;\n        M.ex.y = -det * c2;\n        M.ey.y = det * a2;\n        M.ey.z = 0;\n        M.ez.x = 0;\n        M.ez.y = 0;\n        M.ez.z = 0;\n      };\n      Mat332.prototype.getSymInverse33 = function(M) {\n        var det = Vec3.dot(this.ex, Vec3.cross(this.ey, this.ez));\n        if (det !== 0) {\n          det = 1 / det;\n        }\n        var a11 = this.ex.x;\n        var a12 = this.ey.x;\n        var a13 = this.ez.x;\n        var a22 = this.ey.y;\n        var a23 = this.ez.y;\n        var a33 = this.ez.z;\n        M.ex.x = det * (a22 * a33 - a23 * a23);\n        M.ex.y = det * (a13 * a23 - a12 * a33);\n        M.ex.z = det * (a12 * a23 - a13 * a22);\n        M.ey.x = M.ex.y;\n        M.ey.y = det * (a11 * a33 - a13 * a13);\n        M.ey.z = det * (a13 * a12 - a11 * a23);\n        M.ez.x = M.ex.z;\n        M.ez.y = M.ey.z;\n        M.ez.z = det * (a11 * a22 - a12 * a12);\n      };\n      Mat332.mul = function(a2, b2) {\n        if (b2 && \"z\" in b2 && \"y\" in b2 && \"x\" in b2) {\n          var x2 = a2.ex.x * b2.x + a2.ey.x * b2.y + a2.ez.x * b2.z;\n          var y = a2.ex.y * b2.x + a2.ey.y * b2.y + a2.ez.y * b2.z;\n          var z = a2.ex.z * b2.x + a2.ey.z * b2.y + a2.ez.z * b2.z;\n          return new Vec3(x2, y, z);\n        } else if (b2 && \"y\" in b2 && \"x\" in b2) {\n          var x2 = a2.ex.x * b2.x + a2.ey.x * b2.y;\n          var y = a2.ex.y * b2.x + a2.ey.y * b2.y;\n          return Vec2.neo(x2, y);\n        }\n      };\n      Mat332.mulVec3 = function(a2, b2) {\n        var x2 = a2.ex.x * b2.x + a2.ey.x * b2.y + a2.ez.x * b2.z;\n        var y = a2.ex.y * b2.x + a2.ey.y * b2.y + a2.ez.y * b2.z;\n        var z = a2.ex.z * b2.x + a2.ey.z * b2.y + a2.ez.z * b2.z;\n        return new Vec3(x2, y, z);\n      };\n      Mat332.mulVec2 = function(a2, b2) {\n        var x2 = a2.ex.x * b2.x + a2.ey.x * b2.y;\n        var y = a2.ex.y * b2.x + a2.ey.y * b2.y;\n        return Vec2.neo(x2, y);\n      };\n      Mat332.add = function(a2, b2) {\n        return new Mat332(Vec3.add(a2.ex, b2.ex), Vec3.add(a2.ey, b2.ey), Vec3.add(a2.ez, b2.ez));\n      };\n      return Mat332;\n    }()\n  );\n  var math_abs$4 = Math.abs;\n  var LimitState$2;\n  (function(LimitState2) {\n    LimitState2[LimitState2[\"inactiveLimit\"] = 0] = \"inactiveLimit\";\n    LimitState2[LimitState2[\"atLowerLimit\"] = 1] = \"atLowerLimit\";\n    LimitState2[LimitState2[\"atUpperLimit\"] = 2] = \"atUpperLimit\";\n    LimitState2[LimitState2[\"equalLimits\"] = 3] = \"equalLimits\";\n  })(LimitState$2 || (LimitState$2 = {}));\n  var DEFAULTS$8 = {\n    lowerAngle: 0,\n    upperAngle: 0,\n    maxMotorTorque: 0,\n    motorSpeed: 0,\n    enableLimit: false,\n    enableMotor: false\n  };\n  var RevoluteJoint = (\n    /** @class */\n    function(_super) {\n      __extends(RevoluteJoint2, _super);\n      function RevoluteJoint2(def, bodyA, bodyB, anchor) {\n        var _this = this;\n        var _a2, _b, _c, _d, _e, _f;\n        if (!(_this instanceof RevoluteJoint2)) {\n          return new RevoluteJoint2(def, bodyA, bodyB, anchor);\n        }\n        def = def !== null && def !== void 0 ? def : {};\n        _this = _super.call(this, def, bodyA, bodyB) || this;\n        bodyA = _this.m_bodyA;\n        bodyB = _this.m_bodyB;\n        _this.m_mass = new Mat33();\n        _this.m_limitState = LimitState$2.inactiveLimit;\n        _this.m_type = RevoluteJoint2.TYPE;\n        if (Vec2.isValid(anchor)) {\n          _this.m_localAnchorA = bodyA.getLocalPoint(anchor);\n        } else if (Vec2.isValid(def.localAnchorA)) {\n          _this.m_localAnchorA = Vec2.clone(def.localAnchorA);\n        } else {\n          _this.m_localAnchorA = Vec2.zero();\n        }\n        if (Vec2.isValid(anchor)) {\n          _this.m_localAnchorB = bodyB.getLocalPoint(anchor);\n        } else if (Vec2.isValid(def.localAnchorB)) {\n          _this.m_localAnchorB = Vec2.clone(def.localAnchorB);\n        } else {\n          _this.m_localAnchorB = Vec2.zero();\n        }\n        if (Number.isFinite(def.referenceAngle)) {\n          _this.m_referenceAngle = def.referenceAngle;\n        } else {\n          _this.m_referenceAngle = bodyB.getAngle() - bodyA.getAngle();\n        }\n        _this.m_impulse = new Vec3();\n        _this.m_motorImpulse = 0;\n        _this.m_lowerAngle = (_a2 = def.lowerAngle) !== null && _a2 !== void 0 ? _a2 : DEFAULTS$8.lowerAngle;\n        _this.m_upperAngle = (_b = def.upperAngle) !== null && _b !== void 0 ? _b : DEFAULTS$8.upperAngle;\n        _this.m_maxMotorTorque = (_c = def.maxMotorTorque) !== null && _c !== void 0 ? _c : DEFAULTS$8.maxMotorTorque;\n        _this.m_motorSpeed = (_d = def.motorSpeed) !== null && _d !== void 0 ? _d : DEFAULTS$8.motorSpeed;\n        _this.m_enableLimit = (_e = def.enableLimit) !== null && _e !== void 0 ? _e : DEFAULTS$8.enableLimit;\n        _this.m_enableMotor = (_f = def.enableMotor) !== null && _f !== void 0 ? _f : DEFAULTS$8.enableMotor;\n        return _this;\n      }\n      RevoluteJoint2.prototype._serialize = function() {\n        return {\n          type: this.m_type,\n          bodyA: this.m_bodyA,\n          bodyB: this.m_bodyB,\n          collideConnected: this.m_collideConnected,\n          lowerAngle: this.m_lowerAngle,\n          upperAngle: this.m_upperAngle,\n          maxMotorTorque: this.m_maxMotorTorque,\n          motorSpeed: this.m_motorSpeed,\n          enableLimit: this.m_enableLimit,\n          enableMotor: this.m_enableMotor,\n          localAnchorA: this.m_localAnchorA,\n          localAnchorB: this.m_localAnchorB,\n          referenceAngle: this.m_referenceAngle\n        };\n      };\n      RevoluteJoint2._deserialize = function(data, world, restore) {\n        data = __assign({}, data);\n        data.bodyA = restore(Body, data.bodyA, world);\n        data.bodyB = restore(Body, data.bodyB, world);\n        var joint = new RevoluteJoint2(data);\n        return joint;\n      };\n      RevoluteJoint2.prototype._reset = function(def) {\n        if (def.anchorA) {\n          this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n        } else if (def.localAnchorA) {\n          this.m_localAnchorA.setVec2(def.localAnchorA);\n        }\n        if (def.anchorB) {\n          this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n        } else if (def.localAnchorB) {\n          this.m_localAnchorB.setVec2(def.localAnchorB);\n        }\n        if (Number.isFinite(def.referenceAngle)) {\n          this.m_referenceAngle = def.referenceAngle;\n        }\n        if (def.enableLimit !== void 0) {\n          this.m_enableLimit = def.enableLimit;\n        }\n        if (Number.isFinite(def.lowerAngle)) {\n          this.m_lowerAngle = def.lowerAngle;\n        }\n        if (Number.isFinite(def.upperAngle)) {\n          this.m_upperAngle = def.upperAngle;\n        }\n        if (Number.isFinite(def.maxMotorTorque)) {\n          this.m_maxMotorTorque = def.maxMotorTorque;\n        }\n        if (Number.isFinite(def.motorSpeed)) {\n          this.m_motorSpeed = def.motorSpeed;\n        }\n        if (def.enableMotor !== void 0) {\n          this.m_enableMotor = def.enableMotor;\n        }\n      };\n      RevoluteJoint2.prototype.getLocalAnchorA = function() {\n        return this.m_localAnchorA;\n      };\n      RevoluteJoint2.prototype.getLocalAnchorB = function() {\n        return this.m_localAnchorB;\n      };\n      RevoluteJoint2.prototype.getReferenceAngle = function() {\n        return this.m_referenceAngle;\n      };\n      RevoluteJoint2.prototype.getJointAngle = function() {\n        var bA = this.m_bodyA;\n        var bB = this.m_bodyB;\n        return bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;\n      };\n      RevoluteJoint2.prototype.getJointSpeed = function() {\n        var bA = this.m_bodyA;\n        var bB = this.m_bodyB;\n        return bB.m_angularVelocity - bA.m_angularVelocity;\n      };\n      RevoluteJoint2.prototype.isMotorEnabled = function() {\n        return this.m_enableMotor;\n      };\n      RevoluteJoint2.prototype.enableMotor = function(flag) {\n        if (flag == this.m_enableMotor)\n          return;\n        this.m_bodyA.setAwake(true);\n        this.m_bodyB.setAwake(true);\n        this.m_enableMotor = flag;\n      };\n      RevoluteJoint2.prototype.getMotorTorque = function(inv_dt) {\n        return inv_dt * this.m_motorImpulse;\n      };\n      RevoluteJoint2.prototype.setMotorSpeed = function(speed) {\n        if (speed == this.m_motorSpeed)\n          return;\n        this.m_bodyA.setAwake(true);\n        this.m_bodyB.setAwake(true);\n        this.m_motorSpeed = speed;\n      };\n      RevoluteJoint2.prototype.getMotorSpeed = function() {\n        return this.m_motorSpeed;\n      };\n      RevoluteJoint2.prototype.setMaxMotorTorque = function(torque) {\n        if (torque == this.m_maxMotorTorque)\n          return;\n        this.m_bodyA.setAwake(true);\n        this.m_bodyB.setAwake(true);\n        this.m_maxMotorTorque = torque;\n      };\n      RevoluteJoint2.prototype.getMaxMotorTorque = function() {\n        return this.m_maxMotorTorque;\n      };\n      RevoluteJoint2.prototype.isLimitEnabled = function() {\n        return this.m_enableLimit;\n      };\n      RevoluteJoint2.prototype.enableLimit = function(flag) {\n        if (flag != this.m_enableLimit) {\n          this.m_bodyA.setAwake(true);\n          this.m_bodyB.setAwake(true);\n          this.m_enableLimit = flag;\n          this.m_impulse.z = 0;\n        }\n      };\n      RevoluteJoint2.prototype.getLowerLimit = function() {\n        return this.m_lowerAngle;\n      };\n      RevoluteJoint2.prototype.getUpperLimit = function() {\n        return this.m_upperAngle;\n      };\n      RevoluteJoint2.prototype.setLimits = function(lower, upper) {\n        if (lower != this.m_lowerAngle || upper != this.m_upperAngle) {\n          this.m_bodyA.setAwake(true);\n          this.m_bodyB.setAwake(true);\n          this.m_impulse.z = 0;\n          this.m_lowerAngle = lower;\n          this.m_upperAngle = upper;\n        }\n      };\n      RevoluteJoint2.prototype.getAnchorA = function() {\n        return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n      };\n      RevoluteJoint2.prototype.getAnchorB = function() {\n        return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n      };\n      RevoluteJoint2.prototype.getReactionForce = function(inv_dt) {\n        return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);\n      };\n      RevoluteJoint2.prototype.getReactionTorque = function(inv_dt) {\n        return inv_dt * this.m_impulse.z;\n      };\n      RevoluteJoint2.prototype.initVelocityConstraints = function(step) {\n        this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n        this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n        this.m_invMassA = this.m_bodyA.m_invMass;\n        this.m_invMassB = this.m_bodyB.m_invMass;\n        this.m_invIA = this.m_bodyA.m_invI;\n        this.m_invIB = this.m_bodyB.m_invI;\n        var aA = this.m_bodyA.c_position.a;\n        var vA2 = this.m_bodyA.c_velocity.v;\n        var wA = this.m_bodyA.c_velocity.w;\n        var aB = this.m_bodyB.c_position.a;\n        var vB2 = this.m_bodyB.c_velocity.v;\n        var wB = this.m_bodyB.c_velocity.w;\n        var qA = Rot.neo(aA);\n        var qB = Rot.neo(aB);\n        this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n        this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n        var mA = this.m_invMassA;\n        var mB = this.m_invMassB;\n        var iA = this.m_invIA;\n        var iB = this.m_invIB;\n        var fixedRotation = iA + iB === 0;\n        this.m_mass.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;\n        this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;\n        this.m_mass.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;\n        this.m_mass.ex.y = this.m_mass.ey.x;\n        this.m_mass.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;\n        this.m_mass.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;\n        this.m_mass.ex.z = this.m_mass.ez.x;\n        this.m_mass.ey.z = this.m_mass.ez.y;\n        this.m_mass.ez.z = iA + iB;\n        this.m_motorMass = iA + iB;\n        if (this.m_motorMass > 0) {\n          this.m_motorMass = 1 / this.m_motorMass;\n        }\n        if (this.m_enableMotor == false || fixedRotation) {\n          this.m_motorImpulse = 0;\n        }\n        if (this.m_enableLimit && fixedRotation == false) {\n          var jointAngle = aB - aA - this.m_referenceAngle;\n          if (math_abs$4(this.m_upperAngle - this.m_lowerAngle) < 2 * SettingsInternal.angularSlop) {\n            this.m_limitState = LimitState$2.equalLimits;\n          } else if (jointAngle <= this.m_lowerAngle) {\n            if (this.m_limitState != LimitState$2.atLowerLimit) {\n              this.m_impulse.z = 0;\n            }\n            this.m_limitState = LimitState$2.atLowerLimit;\n          } else if (jointAngle >= this.m_upperAngle) {\n            if (this.m_limitState != LimitState$2.atUpperLimit) {\n              this.m_impulse.z = 0;\n            }\n            this.m_limitState = LimitState$2.atUpperLimit;\n          } else {\n            this.m_limitState = LimitState$2.inactiveLimit;\n            this.m_impulse.z = 0;\n          }\n        } else {\n          this.m_limitState = LimitState$2.inactiveLimit;\n        }\n        if (step.warmStarting) {\n          this.m_impulse.mul(step.dtRatio);\n          this.m_motorImpulse *= step.dtRatio;\n          var P3 = Vec2.neo(this.m_impulse.x, this.m_impulse.y);\n          vA2.subMul(mA, P3);\n          wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P3) + this.m_motorImpulse + this.m_impulse.z);\n          vB2.addMul(mB, P3);\n          wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P3) + this.m_motorImpulse + this.m_impulse.z);\n        } else {\n          this.m_impulse.setZero();\n          this.m_motorImpulse = 0;\n        }\n        this.m_bodyA.c_velocity.v = vA2;\n        this.m_bodyA.c_velocity.w = wA;\n        this.m_bodyB.c_velocity.v = vB2;\n        this.m_bodyB.c_velocity.w = wB;\n      };\n      RevoluteJoint2.prototype.solveVelocityConstraints = function(step) {\n        var vA2 = this.m_bodyA.c_velocity.v;\n        var wA = this.m_bodyA.c_velocity.w;\n        var vB2 = this.m_bodyB.c_velocity.v;\n        var wB = this.m_bodyB.c_velocity.w;\n        var mA = this.m_invMassA;\n        var mB = this.m_invMassB;\n        var iA = this.m_invIA;\n        var iB = this.m_invIB;\n        var fixedRotation = iA + iB === 0;\n        if (this.m_enableMotor && this.m_limitState != LimitState$2.equalLimits && fixedRotation == false) {\n          var Cdot = wB - wA - this.m_motorSpeed;\n          var impulse = -this.m_motorMass * Cdot;\n          var oldImpulse = this.m_motorImpulse;\n          var maxImpulse = step.dt * this.m_maxMotorTorque;\n          this.m_motorImpulse = clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);\n          impulse = this.m_motorImpulse - oldImpulse;\n          wA -= iA * impulse;\n          wB += iB * impulse;\n        }\n        if (this.m_enableLimit && this.m_limitState != LimitState$2.inactiveLimit && fixedRotation == false) {\n          var Cdot1 = Vec2.zero();\n          Cdot1.addCombine(1, vB2, 1, Vec2.crossNumVec2(wB, this.m_rB));\n          Cdot1.subCombine(1, vA2, 1, Vec2.crossNumVec2(wA, this.m_rA));\n          var Cdot2 = wB - wA;\n          var Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);\n          var impulse = Vec3.neg(this.m_mass.solve33(Cdot));\n          if (this.m_limitState == LimitState$2.equalLimits) {\n            this.m_impulse.add(impulse);\n          } else if (this.m_limitState == LimitState$2.atLowerLimit) {\n            var newImpulse = this.m_impulse.z + impulse.z;\n            if (newImpulse < 0) {\n              var rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y));\n              var reduced = this.m_mass.solve22(rhs);\n              impulse.x = reduced.x;\n              impulse.y = reduced.y;\n              impulse.z = -this.m_impulse.z;\n              this.m_impulse.x += reduced.x;\n              this.m_impulse.y += reduced.y;\n              this.m_impulse.z = 0;\n            } else {\n              this.m_impulse.add(impulse);\n            }\n          } else if (this.m_limitState == LimitState$2.atUpperLimit) {\n            var newImpulse = this.m_impulse.z + impulse.z;\n            if (newImpulse > 0) {\n              var rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y));\n              var reduced = this.m_mass.solve22(rhs);\n              impulse.x = reduced.x;\n              impulse.y = reduced.y;\n              impulse.z = -this.m_impulse.z;\n              this.m_impulse.x += reduced.x;\n              this.m_impulse.y += reduced.y;\n              this.m_impulse.z = 0;\n            } else {\n              this.m_impulse.add(impulse);\n            }\n          }\n          var P3 = Vec2.neo(impulse.x, impulse.y);\n          vA2.subMul(mA, P3);\n          wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P3) + impulse.z);\n          vB2.addMul(mB, P3);\n          wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P3) + impulse.z);\n        } else {\n          var Cdot = Vec2.zero();\n          Cdot.addCombine(1, vB2, 1, Vec2.crossNumVec2(wB, this.m_rB));\n          Cdot.subCombine(1, vA2, 1, Vec2.crossNumVec2(wA, this.m_rA));\n          var impulse = this.m_mass.solve22(Vec2.neg(Cdot));\n          this.m_impulse.x += impulse.x;\n          this.m_impulse.y += impulse.y;\n          vA2.subMul(mA, impulse);\n          wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n          vB2.addMul(mB, impulse);\n          wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n        }\n        this.m_bodyA.c_velocity.v = vA2;\n        this.m_bodyA.c_velocity.w = wA;\n        this.m_bodyB.c_velocity.v = vB2;\n        this.m_bodyB.c_velocity.w = wB;\n      };\n      RevoluteJoint2.prototype.solvePositionConstraints = function(step) {\n        var cA2 = this.m_bodyA.c_position.c;\n        var aA = this.m_bodyA.c_position.a;\n        var cB2 = this.m_bodyB.c_position.c;\n        var aB = this.m_bodyB.c_position.a;\n        var qA = Rot.neo(aA);\n        var qB = Rot.neo(aB);\n        var angularError = 0;\n        var positionError = 0;\n        var fixedRotation = this.m_invIA + this.m_invIB == 0;\n        if (this.m_enableLimit && this.m_limitState != LimitState$2.inactiveLimit && fixedRotation == false) {\n          var angle = aB - aA - this.m_referenceAngle;\n          var limitImpulse = 0;\n          if (this.m_limitState == LimitState$2.equalLimits) {\n            var C = clamp(angle - this.m_lowerAngle, -SettingsInternal.maxAngularCorrection, SettingsInternal.maxAngularCorrection);\n            limitImpulse = -this.m_motorMass * C;\n            angularError = math_abs$4(C);\n          } else if (this.m_limitState == LimitState$2.atLowerLimit) {\n            var C = angle - this.m_lowerAngle;\n            angularError = -C;\n            C = clamp(C + SettingsInternal.angularSlop, -SettingsInternal.maxAngularCorrection, 0);\n            limitImpulse = -this.m_motorMass * C;\n          } else if (this.m_limitState == LimitState$2.atUpperLimit) {\n            var C = angle - this.m_upperAngle;\n            angularError = C;\n            C = clamp(C - SettingsInternal.angularSlop, 0, SettingsInternal.maxAngularCorrection);\n            limitImpulse = -this.m_motorMass * C;\n          }\n          aA -= this.m_invIA * limitImpulse;\n          aB += this.m_invIB * limitImpulse;\n        }\n        {\n          qA.setAngle(aA);\n          qB.setAngle(aB);\n          var rA2 = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n          var rB2 = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n          var C = Vec2.zero();\n          C.addCombine(1, cB2, 1, rB2);\n          C.subCombine(1, cA2, 1, rA2);\n          positionError = C.length();\n          var mA = this.m_invMassA;\n          var mB = this.m_invMassB;\n          var iA = this.m_invIA;\n          var iB = this.m_invIB;\n          var K = new Mat22();\n          K.ex.x = mA + mB + iA * rA2.y * rA2.y + iB * rB2.y * rB2.y;\n          K.ex.y = -iA * rA2.x * rA2.y - iB * rB2.x * rB2.y;\n          K.ey.x = K.ex.y;\n          K.ey.y = mA + mB + iA * rA2.x * rA2.x + iB * rB2.x * rB2.x;\n          var impulse = Vec2.neg(K.solve(C));\n          cA2.subMul(mA, impulse);\n          aA -= iA * Vec2.crossVec2Vec2(rA2, impulse);\n          cB2.addMul(mB, impulse);\n          aB += iB * Vec2.crossVec2Vec2(rB2, impulse);\n        }\n        this.m_bodyA.c_position.c.setVec2(cA2);\n        this.m_bodyA.c_position.a = aA;\n        this.m_bodyB.c_position.c.setVec2(cB2);\n        this.m_bodyB.c_position.a = aB;\n        return positionError <= SettingsInternal.linearSlop && angularError <= SettingsInternal.angularSlop;\n      };\n      RevoluteJoint2.TYPE = \"revolute-joint\";\n      return RevoluteJoint2;\n    }(Joint)\n  );\n  var math_abs$3 = Math.abs;\n  var math_max = Math.max;\n  var math_min$2 = Math.min;\n  var LimitState$1;\n  (function(LimitState2) {\n    LimitState2[LimitState2[\"inactiveLimit\"] = 0] = \"inactiveLimit\";\n    LimitState2[LimitState2[\"atLowerLimit\"] = 1] = \"atLowerLimit\";\n    LimitState2[LimitState2[\"atUpperLimit\"] = 2] = \"atUpperLimit\";\n    LimitState2[LimitState2[\"equalLimits\"] = 3] = \"equalLimits\";\n  })(LimitState$1 || (LimitState$1 = {}));\n  var DEFAULTS$7 = {\n    enableLimit: false,\n    lowerTranslation: 0,\n    upperTranslation: 0,\n    enableMotor: false,\n    maxMotorForce: 0,\n    motorSpeed: 0\n  };\n  var PrismaticJoint = (\n    /** @class */\n    function(_super) {\n      __extends(PrismaticJoint2, _super);\n      function PrismaticJoint2(def, bodyA, bodyB, anchor, axis) {\n        var _this = this;\n        if (!(_this instanceof PrismaticJoint2)) {\n          return new PrismaticJoint2(def, bodyA, bodyB, anchor, axis);\n        }\n        def = options(def, DEFAULTS$7);\n        _this = _super.call(this, def, bodyA, bodyB) || this;\n        bodyA = _this.m_bodyA;\n        bodyB = _this.m_bodyB;\n        _this.m_type = PrismaticJoint2.TYPE;\n        _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n        _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n        _this.m_localXAxisA = Vec2.clone(axis ? bodyA.getLocalVector(axis) : def.localAxisA || Vec2.neo(1, 0));\n        _this.m_localXAxisA.normalize();\n        _this.m_localYAxisA = Vec2.crossNumVec2(1, _this.m_localXAxisA);\n        _this.m_referenceAngle = Number.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n        _this.m_impulse = new Vec3();\n        _this.m_motorMass = 0;\n        _this.m_motorImpulse = 0;\n        _this.m_lowerTranslation = def.lowerTranslation;\n        _this.m_upperTranslation = def.upperTranslation;\n        _this.m_maxMotorForce = def.maxMotorForce;\n        _this.m_motorSpeed = def.motorSpeed;\n        _this.m_enableLimit = def.enableLimit;\n        _this.m_enableMotor = def.enableMotor;\n        _this.m_limitState = LimitState$1.inactiveLimit;\n        _this.m_axis = Vec2.zero();\n        _this.m_perp = Vec2.zero();\n        _this.m_K = new Mat33();\n        return _this;\n      }\n      PrismaticJoint2.prototype._serialize = function() {\n        return {\n          type: this.m_type,\n          bodyA: this.m_bodyA,\n          bodyB: this.m_bodyB,\n          collideConnected: this.m_collideConnected,\n          lowerTranslation: this.m_lowerTranslation,\n          upperTranslation: this.m_upperTranslation,\n          maxMotorForce: this.m_maxMotorForce,\n          motorSpeed: this.m_motorSpeed,\n          enableLimit: this.m_enableLimit,\n          enableMotor: this.m_enableMotor,\n          localAnchorA: this.m_localAnchorA,\n          localAnchorB: this.m_localAnchorB,\n          localAxisA: this.m_localXAxisA,\n          referenceAngle: this.m_referenceAngle\n        };\n      };\n      PrismaticJoint2._deserialize = function(data, world, restore) {\n        data = __assign({}, data);\n        data.bodyA = restore(Body, data.bodyA, world);\n        data.bodyB = restore(Body, data.bodyB, world);\n        data.localAxisA = Vec2.clone(data.localAxisA);\n        var joint = new PrismaticJoint2(data);\n        return joint;\n      };\n      PrismaticJoint2.prototype._reset = function(def) {\n        if (def.anchorA) {\n          this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n        } else if (def.localAnchorA) {\n          this.m_localAnchorA.setVec2(def.localAnchorA);\n        }\n        if (def.anchorB) {\n          this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n        } else if (def.localAnchorB) {\n          this.m_localAnchorB.setVec2(def.localAnchorB);\n        }\n        if (def.localAxisA) {\n          this.m_localXAxisA.setVec2(def.localAxisA);\n          this.m_localYAxisA.setVec2(Vec2.crossNumVec2(1, def.localAxisA));\n        }\n        if (Number.isFinite(def.referenceAngle)) {\n          this.m_referenceAngle = def.referenceAngle;\n        }\n        if (typeof def.enableLimit !== \"undefined\") {\n          this.m_enableLimit = !!def.enableLimit;\n        }\n        if (Number.isFinite(def.lowerTranslation)) {\n          this.m_lowerTranslation = def.lowerTranslation;\n        }\n        if (Number.isFinite(def.upperTranslation)) {\n          this.m_upperTranslation = def.upperTranslation;\n        }\n        if (typeof def.enableMotor !== \"undefined\") {\n          this.m_enableMotor = !!def.enableMotor;\n        }\n        if (Number.isFinite(def.maxMotorForce)) {\n          this.m_maxMotorForce = def.maxMotorForce;\n        }\n        if (Number.isFinite(def.motorSpeed)) {\n          this.m_motorSpeed = def.motorSpeed;\n        }\n      };\n      PrismaticJoint2.prototype.getLocalAnchorA = function() {\n        return this.m_localAnchorA;\n      };\n      PrismaticJoint2.prototype.getLocalAnchorB = function() {\n        return this.m_localAnchorB;\n      };\n      PrismaticJoint2.prototype.getLocalAxisA = function() {\n        return this.m_localXAxisA;\n      };\n      PrismaticJoint2.prototype.getReferenceAngle = function() {\n        return this.m_referenceAngle;\n      };\n      PrismaticJoint2.prototype.getJointTranslation = function() {\n        var pA2 = this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        var pB2 = this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        var d2 = Vec2.sub(pB2, pA2);\n        var axis = this.m_bodyA.getWorldVector(this.m_localXAxisA);\n        var translation2 = Vec2.dot(d2, axis);\n        return translation2;\n      };\n      PrismaticJoint2.prototype.getJointSpeed = function() {\n        var bA = this.m_bodyA;\n        var bB = this.m_bodyB;\n        var rA2 = Rot.mulVec2(bA.m_xf.q, Vec2.sub(this.m_localAnchorA, bA.m_sweep.localCenter));\n        var rB2 = Rot.mulVec2(bB.m_xf.q, Vec2.sub(this.m_localAnchorB, bB.m_sweep.localCenter));\n        var p1 = Vec2.add(bA.m_sweep.c, rA2);\n        var p2 = Vec2.add(bB.m_sweep.c, rB2);\n        var d2 = Vec2.sub(p2, p1);\n        var axis = Rot.mulVec2(bA.m_xf.q, this.m_localXAxisA);\n        var vA2 = bA.m_linearVelocity;\n        var vB2 = bB.m_linearVelocity;\n        var wA = bA.m_angularVelocity;\n        var wB = bB.m_angularVelocity;\n        var speed = Vec2.dot(d2, Vec2.crossNumVec2(wA, axis)) + Vec2.dot(axis, Vec2.sub(Vec2.addCrossNumVec2(vB2, wB, rB2), Vec2.addCrossNumVec2(vA2, wA, rA2)));\n        return speed;\n      };\n      PrismaticJoint2.prototype.isLimitEnabled = function() {\n        return this.m_enableLimit;\n      };\n      PrismaticJoint2.prototype.enableLimit = function(flag) {\n        if (flag != this.m_enableLimit) {\n          this.m_bodyA.setAwake(true);\n          this.m_bodyB.setAwake(true);\n          this.m_enableLimit = flag;\n          this.m_impulse.z = 0;\n        }\n      };\n      PrismaticJoint2.prototype.getLowerLimit = function() {\n        return this.m_lowerTranslation;\n      };\n      PrismaticJoint2.prototype.getUpperLimit = function() {\n        return this.m_upperTranslation;\n      };\n      PrismaticJoint2.prototype.setLimits = function(lower, upper) {\n        if (lower != this.m_lowerTranslation || upper != this.m_upperTranslation) {\n          this.m_bodyA.setAwake(true);\n          this.m_bodyB.setAwake(true);\n          this.m_lowerTranslation = lower;\n          this.m_upperTranslation = upper;\n          this.m_impulse.z = 0;\n        }\n      };\n      PrismaticJoint2.prototype.isMotorEnabled = function() {\n        return this.m_enableMotor;\n      };\n      PrismaticJoint2.prototype.enableMotor = function(flag) {\n        if (flag == this.m_enableMotor)\n          return;\n        this.m_bodyA.setAwake(true);\n        this.m_bodyB.setAwake(true);\n        this.m_enableMotor = flag;\n      };\n      PrismaticJoint2.prototype.setMotorSpeed = function(speed) {\n        if (speed == this.m_motorSpeed)\n          return;\n        this.m_bodyA.setAwake(true);\n        this.m_bodyB.setAwake(true);\n        this.m_motorSpeed = speed;\n      };\n      PrismaticJoint2.prototype.setMaxMotorForce = function(force) {\n        if (force == this.m_maxMotorForce)\n          return;\n        this.m_bodyA.setAwake(true);\n        this.m_bodyB.setAwake(true);\n        this.m_maxMotorForce = force;\n      };\n      PrismaticJoint2.prototype.getMaxMotorForce = function() {\n        return this.m_maxMotorForce;\n      };\n      PrismaticJoint2.prototype.getMotorSpeed = function() {\n        return this.m_motorSpeed;\n      };\n      PrismaticJoint2.prototype.getMotorForce = function(inv_dt) {\n        return inv_dt * this.m_motorImpulse;\n      };\n      PrismaticJoint2.prototype.getAnchorA = function() {\n        return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n      };\n      PrismaticJoint2.prototype.getAnchorB = function() {\n        return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n      };\n      PrismaticJoint2.prototype.getReactionForce = function(inv_dt) {\n        return Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse + this.m_impulse.z, this.m_axis).mul(inv_dt);\n      };\n      PrismaticJoint2.prototype.getReactionTorque = function(inv_dt) {\n        return inv_dt * this.m_impulse.y;\n      };\n      PrismaticJoint2.prototype.initVelocityConstraints = function(step) {\n        this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n        this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n        this.m_invMassA = this.m_bodyA.m_invMass;\n        this.m_invMassB = this.m_bodyB.m_invMass;\n        this.m_invIA = this.m_bodyA.m_invI;\n        this.m_invIB = this.m_bodyB.m_invI;\n        var cA2 = this.m_bodyA.c_position.c;\n        var aA = this.m_bodyA.c_position.a;\n        var vA2 = this.m_bodyA.c_velocity.v;\n        var wA = this.m_bodyA.c_velocity.w;\n        var cB2 = this.m_bodyB.c_position.c;\n        var aB = this.m_bodyB.c_position.a;\n        var vB2 = this.m_bodyB.c_velocity.v;\n        var wB = this.m_bodyB.c_velocity.w;\n        var qA = Rot.neo(aA);\n        var qB = Rot.neo(aB);\n        var rA2 = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n        var rB2 = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n        var d2 = Vec2.zero();\n        d2.addCombine(1, cB2, 1, rB2);\n        d2.subCombine(1, cA2, 1, rA2);\n        var mA = this.m_invMassA;\n        var mB = this.m_invMassB;\n        var iA = this.m_invIA;\n        var iB = this.m_invIB;\n        {\n          this.m_axis = Rot.mulVec2(qA, this.m_localXAxisA);\n          this.m_a1 = Vec2.crossVec2Vec2(Vec2.add(d2, rA2), this.m_axis);\n          this.m_a2 = Vec2.crossVec2Vec2(rB2, this.m_axis);\n          this.m_motorMass = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;\n          if (this.m_motorMass > 0) {\n            this.m_motorMass = 1 / this.m_motorMass;\n          }\n        }\n        {\n          this.m_perp = Rot.mulVec2(qA, this.m_localYAxisA);\n          this.m_s1 = Vec2.crossVec2Vec2(Vec2.add(d2, rA2), this.m_perp);\n          this.m_s2 = Vec2.crossVec2Vec2(rB2, this.m_perp);\n          Vec2.crossVec2Vec2(rA2, this.m_perp);\n          var k11 = mA + mB + iA * this.m_s1 * this.m_s1 + iB * this.m_s2 * this.m_s2;\n          var k12 = iA * this.m_s1 + iB * this.m_s2;\n          var k13 = iA * this.m_s1 * this.m_a1 + iB * this.m_s2 * this.m_a2;\n          var k22 = iA + iB;\n          if (k22 == 0) {\n            k22 = 1;\n          }\n          var k23 = iA * this.m_a1 + iB * this.m_a2;\n          var k33 = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;\n          this.m_K.ex.set(k11, k12, k13);\n          this.m_K.ey.set(k12, k22, k23);\n          this.m_K.ez.set(k13, k23, k33);\n        }\n        if (this.m_enableLimit) {\n          var jointTranslation = Vec2.dot(this.m_axis, d2);\n          if (math_abs$3(this.m_upperTranslation - this.m_lowerTranslation) < 2 * SettingsInternal.linearSlop) {\n            this.m_limitState = LimitState$1.equalLimits;\n          } else if (jointTranslation <= this.m_lowerTranslation) {\n            if (this.m_limitState != LimitState$1.atLowerLimit) {\n              this.m_limitState = LimitState$1.atLowerLimit;\n              this.m_impulse.z = 0;\n            }\n          } else if (jointTranslation >= this.m_upperTranslation) {\n            if (this.m_limitState != LimitState$1.atUpperLimit) {\n              this.m_limitState = LimitState$1.atUpperLimit;\n              this.m_impulse.z = 0;\n            }\n          } else {\n            this.m_limitState = LimitState$1.inactiveLimit;\n            this.m_impulse.z = 0;\n          }\n        } else {\n          this.m_limitState = LimitState$1.inactiveLimit;\n          this.m_impulse.z = 0;\n        }\n        if (this.m_enableMotor == false) {\n          this.m_motorImpulse = 0;\n        }\n        if (step.warmStarting) {\n          this.m_impulse.mul(step.dtRatio);\n          this.m_motorImpulse *= step.dtRatio;\n          var P3 = Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse + this.m_impulse.z, this.m_axis);\n          var LA = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;\n          var LB = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;\n          vA2.subMul(mA, P3);\n          wA -= iA * LA;\n          vB2.addMul(mB, P3);\n          wB += iB * LB;\n        } else {\n          this.m_impulse.setZero();\n          this.m_motorImpulse = 0;\n        }\n        this.m_bodyA.c_velocity.v.setVec2(vA2);\n        this.m_bodyA.c_velocity.w = wA;\n        this.m_bodyB.c_velocity.v.setVec2(vB2);\n        this.m_bodyB.c_velocity.w = wB;\n      };\n      PrismaticJoint2.prototype.solveVelocityConstraints = function(step) {\n        var vA2 = this.m_bodyA.c_velocity.v;\n        var wA = this.m_bodyA.c_velocity.w;\n        var vB2 = this.m_bodyB.c_velocity.v;\n        var wB = this.m_bodyB.c_velocity.w;\n        var mA = this.m_invMassA;\n        var mB = this.m_invMassB;\n        var iA = this.m_invIA;\n        var iB = this.m_invIB;\n        if (this.m_enableMotor && this.m_limitState != LimitState$1.equalLimits) {\n          var Cdot = Vec2.dot(this.m_axis, Vec2.sub(vB2, vA2)) + this.m_a2 * wB - this.m_a1 * wA;\n          var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);\n          var oldImpulse = this.m_motorImpulse;\n          var maxImpulse = step.dt * this.m_maxMotorForce;\n          this.m_motorImpulse = clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);\n          impulse = this.m_motorImpulse - oldImpulse;\n          var P3 = Vec2.mulNumVec2(impulse, this.m_axis);\n          var LA = impulse * this.m_a1;\n          var LB = impulse * this.m_a2;\n          vA2.subMul(mA, P3);\n          wA -= iA * LA;\n          vB2.addMul(mB, P3);\n          wB += iB * LB;\n        }\n        var Cdot1 = Vec2.zero();\n        Cdot1.x += Vec2.dot(this.m_perp, vB2) + this.m_s2 * wB;\n        Cdot1.x -= Vec2.dot(this.m_perp, vA2) + this.m_s1 * wA;\n        Cdot1.y = wB - wA;\n        if (this.m_enableLimit && this.m_limitState != LimitState$1.inactiveLimit) {\n          var Cdot2 = 0;\n          Cdot2 += Vec2.dot(this.m_axis, vB2) + this.m_a2 * wB;\n          Cdot2 -= Vec2.dot(this.m_axis, vA2) + this.m_a1 * wA;\n          var Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);\n          var f1 = Vec3.clone(this.m_impulse);\n          var df = this.m_K.solve33(Vec3.neg(Cdot));\n          this.m_impulse.add(df);\n          if (this.m_limitState == LimitState$1.atLowerLimit) {\n            this.m_impulse.z = math_max(this.m_impulse.z, 0);\n          } else if (this.m_limitState == LimitState$1.atUpperLimit) {\n            this.m_impulse.z = math_min$2(this.m_impulse.z, 0);\n          }\n          var b2 = Vec2.combine(-1, Cdot1, -(this.m_impulse.z - f1.z), Vec2.neo(this.m_K.ez.x, this.m_K.ez.y));\n          var f2r = Vec2.add(this.m_K.solve22(b2), Vec2.neo(f1.x, f1.y));\n          this.m_impulse.x = f2r.x;\n          this.m_impulse.y = f2r.y;\n          df = Vec3.sub(this.m_impulse, f1);\n          var P3 = Vec2.combine(df.x, this.m_perp, df.z, this.m_axis);\n          var LA = df.x * this.m_s1 + df.y + df.z * this.m_a1;\n          var LB = df.x * this.m_s2 + df.y + df.z * this.m_a2;\n          vA2.subMul(mA, P3);\n          wA -= iA * LA;\n          vB2.addMul(mB, P3);\n          wB += iB * LB;\n        } else {\n          var df = this.m_K.solve22(Vec2.neg(Cdot1));\n          this.m_impulse.x += df.x;\n          this.m_impulse.y += df.y;\n          var P3 = Vec2.mulNumVec2(df.x, this.m_perp);\n          var LA = df.x * this.m_s1 + df.y;\n          var LB = df.x * this.m_s2 + df.y;\n          vA2.subMul(mA, P3);\n          wA -= iA * LA;\n          vB2.addMul(mB, P3);\n          wB += iB * LB;\n        }\n        this.m_bodyA.c_velocity.v = vA2;\n        this.m_bodyA.c_velocity.w = wA;\n        this.m_bodyB.c_velocity.v = vB2;\n        this.m_bodyB.c_velocity.w = wB;\n      };\n      PrismaticJoint2.prototype.solvePositionConstraints = function(step) {\n        var cA2 = this.m_bodyA.c_position.c;\n        var aA = this.m_bodyA.c_position.a;\n        var cB2 = this.m_bodyB.c_position.c;\n        var aB = this.m_bodyB.c_position.a;\n        var qA = Rot.neo(aA);\n        var qB = Rot.neo(aB);\n        var mA = this.m_invMassA;\n        var mB = this.m_invMassB;\n        var iA = this.m_invIA;\n        var iB = this.m_invIB;\n        var rA2 = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n        var rB2 = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n        var d2 = Vec2.sub(Vec2.add(cB2, rB2), Vec2.add(cA2, rA2));\n        var axis = Rot.mulVec2(qA, this.m_localXAxisA);\n        var a1 = Vec2.crossVec2Vec2(Vec2.add(d2, rA2), axis);\n        var a2 = Vec2.crossVec2Vec2(rB2, axis);\n        var perp2 = Rot.mulVec2(qA, this.m_localYAxisA);\n        var s1 = Vec2.crossVec2Vec2(Vec2.add(d2, rA2), perp2);\n        var s2 = Vec2.crossVec2Vec2(rB2, perp2);\n        var impulse = new Vec3();\n        var C1 = Vec2.zero();\n        C1.x = Vec2.dot(perp2, d2);\n        C1.y = aB - aA - this.m_referenceAngle;\n        var linearError = math_abs$3(C1.x);\n        var angularError = math_abs$3(C1.y);\n        var linearSlop = SettingsInternal.linearSlop;\n        var maxLinearCorrection = SettingsInternal.maxLinearCorrection;\n        var active = false;\n        var C2 = 0;\n        if (this.m_enableLimit) {\n          var translation2 = Vec2.dot(axis, d2);\n          if (math_abs$3(this.m_upperTranslation - this.m_lowerTranslation) < 2 * linearSlop) {\n            C2 = clamp(translation2, -maxLinearCorrection, maxLinearCorrection);\n            linearError = math_max(linearError, math_abs$3(translation2));\n            active = true;\n          } else if (translation2 <= this.m_lowerTranslation) {\n            C2 = clamp(translation2 - this.m_lowerTranslation + linearSlop, -maxLinearCorrection, 0);\n            linearError = Math.max(linearError, this.m_lowerTranslation - translation2);\n            active = true;\n          } else if (translation2 >= this.m_upperTranslation) {\n            C2 = clamp(translation2 - this.m_upperTranslation - linearSlop, 0, maxLinearCorrection);\n            linearError = Math.max(linearError, translation2 - this.m_upperTranslation);\n            active = true;\n          }\n        }\n        if (active) {\n          var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;\n          var k12 = iA * s1 + iB * s2;\n          var k13 = iA * s1 * a1 + iB * s2 * a2;\n          var k22 = iA + iB;\n          if (k22 == 0) {\n            k22 = 1;\n          }\n          var k23 = iA * a1 + iB * a2;\n          var k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2;\n          var K = new Mat33();\n          K.ex.set(k11, k12, k13);\n          K.ey.set(k12, k22, k23);\n          K.ez.set(k13, k23, k33);\n          var C = new Vec3();\n          C.x = C1.x;\n          C.y = C1.y;\n          C.z = C2;\n          impulse = K.solve33(Vec3.neg(C));\n        } else {\n          var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;\n          var k12 = iA * s1 + iB * s2;\n          var k22 = iA + iB;\n          if (k22 == 0) {\n            k22 = 1;\n          }\n          var K = new Mat22();\n          K.ex.setNum(k11, k12);\n          K.ey.setNum(k12, k22);\n          var impulse1 = K.solve(Vec2.neg(C1));\n          impulse.x = impulse1.x;\n          impulse.y = impulse1.y;\n          impulse.z = 0;\n        }\n        var P3 = Vec2.combine(impulse.x, perp2, impulse.z, axis);\n        var LA = impulse.x * s1 + impulse.y + impulse.z * a1;\n        var LB = impulse.x * s2 + impulse.y + impulse.z * a2;\n        cA2.subMul(mA, P3);\n        aA -= iA * LA;\n        cB2.addMul(mB, P3);\n        aB += iB * LB;\n        this.m_bodyA.c_position.c = cA2;\n        this.m_bodyA.c_position.a = aA;\n        this.m_bodyB.c_position.c = cB2;\n        this.m_bodyB.c_position.a = aB;\n        return linearError <= SettingsInternal.linearSlop && angularError <= SettingsInternal.angularSlop;\n      };\n      PrismaticJoint2.TYPE = \"prismatic-joint\";\n      return PrismaticJoint2;\n    }(Joint)\n  );\n  var DEFAULTS$6 = {\n    ratio: 1\n  };\n  var GearJoint = (\n    /** @class */\n    function(_super) {\n      __extends(GearJoint2, _super);\n      function GearJoint2(def, bodyA, bodyB, joint1, joint2, ratio) {\n        var _this = this;\n        if (!(_this instanceof GearJoint2)) {\n          return new GearJoint2(def, bodyA, bodyB, joint1, joint2, ratio);\n        }\n        def = options(def, DEFAULTS$6);\n        _this = _super.call(this, def, bodyA, bodyB) || this;\n        bodyA = _this.m_bodyA;\n        bodyB = _this.m_bodyB;\n        _this.m_type = GearJoint2.TYPE;\n        _this.m_joint1 = joint1 ? joint1 : def.joint1;\n        _this.m_joint2 = joint2 ? joint2 : def.joint2;\n        _this.m_ratio = Number.isFinite(ratio) ? ratio : def.ratio;\n        _this.m_type1 = _this.m_joint1.getType();\n        _this.m_type2 = _this.m_joint2.getType();\n        var coordinateA;\n        var coordinateB;\n        _this.m_bodyC = _this.m_joint1.getBodyA();\n        _this.m_bodyA = _this.m_joint1.getBodyB();\n        var xfA2 = _this.m_bodyA.m_xf;\n        var aA = _this.m_bodyA.m_sweep.a;\n        var xfC = _this.m_bodyC.m_xf;\n        var aC = _this.m_bodyC.m_sweep.a;\n        if (_this.m_type1 === RevoluteJoint.TYPE) {\n          var revolute = _this.m_joint1;\n          _this.m_localAnchorC = revolute.m_localAnchorA;\n          _this.m_localAnchorA = revolute.m_localAnchorB;\n          _this.m_referenceAngleA = revolute.m_referenceAngle;\n          _this.m_localAxisC = Vec2.zero();\n          coordinateA = aA - aC - _this.m_referenceAngleA;\n        } else {\n          var prismatic = _this.m_joint1;\n          _this.m_localAnchorC = prismatic.m_localAnchorA;\n          _this.m_localAnchorA = prismatic.m_localAnchorB;\n          _this.m_referenceAngleA = prismatic.m_referenceAngle;\n          _this.m_localAxisC = prismatic.m_localXAxisA;\n          var pC = _this.m_localAnchorC;\n          var pA2 = Rot.mulTVec2(xfC.q, Vec2.add(Rot.mulVec2(xfA2.q, _this.m_localAnchorA), Vec2.sub(xfA2.p, xfC.p)));\n          coordinateA = Vec2.dot(pA2, _this.m_localAxisC) - Vec2.dot(pC, _this.m_localAxisC);\n        }\n        _this.m_bodyD = _this.m_joint2.getBodyA();\n        _this.m_bodyB = _this.m_joint2.getBodyB();\n        var xfB2 = _this.m_bodyB.m_xf;\n        var aB = _this.m_bodyB.m_sweep.a;\n        var xfD = _this.m_bodyD.m_xf;\n        var aD = _this.m_bodyD.m_sweep.a;\n        if (_this.m_type2 === RevoluteJoint.TYPE) {\n          var revolute = _this.m_joint2;\n          _this.m_localAnchorD = revolute.m_localAnchorA;\n          _this.m_localAnchorB = revolute.m_localAnchorB;\n          _this.m_referenceAngleB = revolute.m_referenceAngle;\n          _this.m_localAxisD = Vec2.zero();\n          coordinateB = aB - aD - _this.m_referenceAngleB;\n        } else {\n          var prismatic = _this.m_joint2;\n          _this.m_localAnchorD = prismatic.m_localAnchorA;\n          _this.m_localAnchorB = prismatic.m_localAnchorB;\n          _this.m_referenceAngleB = prismatic.m_referenceAngle;\n          _this.m_localAxisD = prismatic.m_localXAxisA;\n          var pD = _this.m_localAnchorD;\n          var pB2 = Rot.mulTVec2(xfD.q, Vec2.add(Rot.mulVec2(xfB2.q, _this.m_localAnchorB), Vec2.sub(xfB2.p, xfD.p)));\n          coordinateB = Vec2.dot(pB2, _this.m_localAxisD) - Vec2.dot(pD, _this.m_localAxisD);\n        }\n        _this.m_constant = coordinateA + _this.m_ratio * coordinateB;\n        _this.m_impulse = 0;\n        return _this;\n      }\n      GearJoint2.prototype._serialize = function() {\n        return {\n          type: this.m_type,\n          bodyA: this.m_bodyA,\n          bodyB: this.m_bodyB,\n          collideConnected: this.m_collideConnected,\n          joint1: this.m_joint1,\n          joint2: this.m_joint2,\n          ratio: this.m_ratio\n          // _constant: this.m_constant,\n        };\n      };\n      GearJoint2._deserialize = function(data, world, restore) {\n        data = __assign({}, data);\n        data.bodyA = restore(Body, data.bodyA, world);\n        data.bodyB = restore(Body, data.bodyB, world);\n        data.joint1 = restore(Joint, data.joint1, world);\n        data.joint2 = restore(Joint, data.joint2, world);\n        var joint = new GearJoint2(data);\n        return joint;\n      };\n      GearJoint2.prototype._reset = function(def) {\n        if (Number.isFinite(def.ratio)) {\n          this.m_ratio = def.ratio;\n        }\n      };\n      GearJoint2.prototype.getJoint1 = function() {\n        return this.m_joint1;\n      };\n      GearJoint2.prototype.getJoint2 = function() {\n        return this.m_joint2;\n      };\n      GearJoint2.prototype.setRatio = function(ratio) {\n        this.m_ratio = ratio;\n      };\n      GearJoint2.prototype.getRatio = function() {\n        return this.m_ratio;\n      };\n      GearJoint2.prototype.getAnchorA = function() {\n        return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n      };\n      GearJoint2.prototype.getAnchorB = function() {\n        return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n      };\n      GearJoint2.prototype.getReactionForce = function(inv_dt) {\n        return Vec2.mulNumVec2(this.m_impulse, this.m_JvAC).mul(inv_dt);\n      };\n      GearJoint2.prototype.getReactionTorque = function(inv_dt) {\n        var L = this.m_impulse * this.m_JwA;\n        return inv_dt * L;\n      };\n      GearJoint2.prototype.initVelocityConstraints = function(step) {\n        this.m_lcA = this.m_bodyA.m_sweep.localCenter;\n        this.m_lcB = this.m_bodyB.m_sweep.localCenter;\n        this.m_lcC = this.m_bodyC.m_sweep.localCenter;\n        this.m_lcD = this.m_bodyD.m_sweep.localCenter;\n        this.m_mA = this.m_bodyA.m_invMass;\n        this.m_mB = this.m_bodyB.m_invMass;\n        this.m_mC = this.m_bodyC.m_invMass;\n        this.m_mD = this.m_bodyD.m_invMass;\n        this.m_iA = this.m_bodyA.m_invI;\n        this.m_iB = this.m_bodyB.m_invI;\n        this.m_iC = this.m_bodyC.m_invI;\n        this.m_iD = this.m_bodyD.m_invI;\n        var aA = this.m_bodyA.c_position.a;\n        var vA2 = this.m_bodyA.c_velocity.v;\n        var wA = this.m_bodyA.c_velocity.w;\n        var aB = this.m_bodyB.c_position.a;\n        var vB2 = this.m_bodyB.c_velocity.v;\n        var wB = this.m_bodyB.c_velocity.w;\n        var aC = this.m_bodyC.c_position.a;\n        var vC = this.m_bodyC.c_velocity.v;\n        var wC = this.m_bodyC.c_velocity.w;\n        var aD = this.m_bodyD.c_position.a;\n        var vD = this.m_bodyD.c_velocity.v;\n        var wD = this.m_bodyD.c_velocity.w;\n        var qA = Rot.neo(aA);\n        var qB = Rot.neo(aB);\n        var qC = Rot.neo(aC);\n        var qD = Rot.neo(aD);\n        this.m_mass = 0;\n        if (this.m_type1 == RevoluteJoint.TYPE) {\n          this.m_JvAC = Vec2.zero();\n          this.m_JwA = 1;\n          this.m_JwC = 1;\n          this.m_mass += this.m_iA + this.m_iC;\n        } else {\n          var u = Rot.mulVec2(qC, this.m_localAxisC);\n          var rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC);\n          var rA2 = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA);\n          this.m_JvAC = u;\n          this.m_JwC = Vec2.crossVec2Vec2(rC, u);\n          this.m_JwA = Vec2.crossVec2Vec2(rA2, u);\n          this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA;\n        }\n        if (this.m_type2 == RevoluteJoint.TYPE) {\n          this.m_JvBD = Vec2.zero();\n          this.m_JwB = this.m_ratio;\n          this.m_JwD = this.m_ratio;\n          this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);\n        } else {\n          var u = Rot.mulVec2(qD, this.m_localAxisD);\n          var rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD);\n          var rB2 = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB);\n          this.m_JvBD = Vec2.mulNumVec2(this.m_ratio, u);\n          this.m_JwD = this.m_ratio * Vec2.crossVec2Vec2(rD, u);\n          this.m_JwB = this.m_ratio * Vec2.crossVec2Vec2(rB2, u);\n          this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB;\n        }\n        this.m_mass = this.m_mass > 0 ? 1 / this.m_mass : 0;\n        if (step.warmStarting) {\n          vA2.addMul(this.m_mA * this.m_impulse, this.m_JvAC);\n          wA += this.m_iA * this.m_impulse * this.m_JwA;\n          vB2.addMul(this.m_mB * this.m_impulse, this.m_JvBD);\n          wB += this.m_iB * this.m_impulse * this.m_JwB;\n          vC.subMul(this.m_mC * this.m_impulse, this.m_JvAC);\n          wC -= this.m_iC * this.m_impulse * this.m_JwC;\n          vD.subMul(this.m_mD * this.m_impulse, this.m_JvBD);\n          wD -= this.m_iD * this.m_impulse * this.m_JwD;\n        } else {\n          this.m_impulse = 0;\n        }\n        this.m_bodyA.c_velocity.v.setVec2(vA2);\n        this.m_bodyA.c_velocity.w = wA;\n        this.m_bodyB.c_velocity.v.setVec2(vB2);\n        this.m_bodyB.c_velocity.w = wB;\n        this.m_bodyC.c_velocity.v.setVec2(vC);\n        this.m_bodyC.c_velocity.w = wC;\n        this.m_bodyD.c_velocity.v.setVec2(vD);\n        this.m_bodyD.c_velocity.w = wD;\n      };\n      GearJoint2.prototype.solveVelocityConstraints = function(step) {\n        var vA2 = this.m_bodyA.c_velocity.v;\n        var wA = this.m_bodyA.c_velocity.w;\n        var vB2 = this.m_bodyB.c_velocity.v;\n        var wB = this.m_bodyB.c_velocity.w;\n        var vC = this.m_bodyC.c_velocity.v;\n        var wC = this.m_bodyC.c_velocity.w;\n        var vD = this.m_bodyD.c_velocity.v;\n        var wD = this.m_bodyD.c_velocity.w;\n        var Cdot = Vec2.dot(this.m_JvAC, vA2) - Vec2.dot(this.m_JvAC, vC) + Vec2.dot(this.m_JvBD, vB2) - Vec2.dot(this.m_JvBD, vD);\n        Cdot += this.m_JwA * wA - this.m_JwC * wC + (this.m_JwB * wB - this.m_JwD * wD);\n        var impulse = -this.m_mass * Cdot;\n        this.m_impulse += impulse;\n        vA2.addMul(this.m_mA * impulse, this.m_JvAC);\n        wA += this.m_iA * impulse * this.m_JwA;\n        vB2.addMul(this.m_mB * impulse, this.m_JvBD);\n        wB += this.m_iB * impulse * this.m_JwB;\n        vC.subMul(this.m_mC * impulse, this.m_JvAC);\n        wC -= this.m_iC * impulse * this.m_JwC;\n        vD.subMul(this.m_mD * impulse, this.m_JvBD);\n        wD -= this.m_iD * impulse * this.m_JwD;\n        this.m_bodyA.c_velocity.v.setVec2(vA2);\n        this.m_bodyA.c_velocity.w = wA;\n        this.m_bodyB.c_velocity.v.setVec2(vB2);\n        this.m_bodyB.c_velocity.w = wB;\n        this.m_bodyC.c_velocity.v.setVec2(vC);\n        this.m_bodyC.c_velocity.w = wC;\n        this.m_bodyD.c_velocity.v.setVec2(vD);\n        this.m_bodyD.c_velocity.w = wD;\n      };\n      GearJoint2.prototype.solvePositionConstraints = function(step) {\n        var cA2 = this.m_bodyA.c_position.c;\n        var aA = this.m_bodyA.c_position.a;\n        var cB2 = this.m_bodyB.c_position.c;\n        var aB = this.m_bodyB.c_position.a;\n        var cC = this.m_bodyC.c_position.c;\n        var aC = this.m_bodyC.c_position.a;\n        var cD = this.m_bodyD.c_position.c;\n        var aD = this.m_bodyD.c_position.a;\n        var qA = Rot.neo(aA);\n        var qB = Rot.neo(aB);\n        var qC = Rot.neo(aC);\n        var qD = Rot.neo(aD);\n        var linearError = 0;\n        var coordinateA;\n        var coordinateB;\n        var JvAC;\n        var JvBD;\n        var JwA;\n        var JwB;\n        var JwC;\n        var JwD;\n        var mass = 0;\n        if (this.m_type1 == RevoluteJoint.TYPE) {\n          JvAC = Vec2.zero();\n          JwA = 1;\n          JwC = 1;\n          mass += this.m_iA + this.m_iC;\n          coordinateA = aA - aC - this.m_referenceAngleA;\n        } else {\n          var u = Rot.mulVec2(qC, this.m_localAxisC);\n          var rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC);\n          var rA2 = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA);\n          JvAC = u;\n          JwC = Vec2.crossVec2Vec2(rC, u);\n          JwA = Vec2.crossVec2Vec2(rA2, u);\n          mass += this.m_mC + this.m_mA + this.m_iC * JwC * JwC + this.m_iA * JwA * JwA;\n          var pC = Vec2.sub(this.m_localAnchorC, this.m_lcC);\n          var pA2 = Rot.mulTVec2(qC, Vec2.add(rA2, Vec2.sub(cA2, cC)));\n          coordinateA = Vec2.dot(Vec2.sub(pA2, pC), this.m_localAxisC);\n        }\n        if (this.m_type2 == RevoluteJoint.TYPE) {\n          JvBD = Vec2.zero();\n          JwB = this.m_ratio;\n          JwD = this.m_ratio;\n          mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);\n          coordinateB = aB - aD - this.m_referenceAngleB;\n        } else {\n          var u = Rot.mulVec2(qD, this.m_localAxisD);\n          var rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD);\n          var rB2 = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB);\n          JvBD = Vec2.mulNumVec2(this.m_ratio, u);\n          JwD = this.m_ratio * Vec2.crossVec2Vec2(rD, u);\n          JwB = this.m_ratio * Vec2.crossVec2Vec2(rB2, u);\n          mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * JwD * JwD + this.m_iB * JwB * JwB;\n          var pD = Vec2.sub(this.m_localAnchorD, this.m_lcD);\n          var pB2 = Rot.mulTVec2(qD, Vec2.add(rB2, Vec2.sub(cB2, cD)));\n          coordinateB = Vec2.dot(pB2, this.m_localAxisD) - Vec2.dot(pD, this.m_localAxisD);\n        }\n        var C = coordinateA + this.m_ratio * coordinateB - this.m_constant;\n        var impulse = 0;\n        if (mass > 0) {\n          impulse = -C / mass;\n        }\n        cA2.addMul(this.m_mA * impulse, JvAC);\n        aA += this.m_iA * impulse * JwA;\n        cB2.addMul(this.m_mB * impulse, JvBD);\n        aB += this.m_iB * impulse * JwB;\n        cC.subMul(this.m_mC * impulse, JvAC);\n        aC -= this.m_iC * impulse * JwC;\n        cD.subMul(this.m_mD * impulse, JvBD);\n        aD -= this.m_iD * impulse * JwD;\n        this.m_bodyA.c_position.c.setVec2(cA2);\n        this.m_bodyA.c_position.a = aA;\n        this.m_bodyB.c_position.c.setVec2(cB2);\n        this.m_bodyB.c_position.a = aB;\n        this.m_bodyC.c_position.c.setVec2(cC);\n        this.m_bodyC.c_position.a = aC;\n        this.m_bodyD.c_position.c.setVec2(cD);\n        this.m_bodyD.c_position.a = aD;\n        return linearError < SettingsInternal.linearSlop;\n      };\n      GearJoint2.TYPE = \"gear-joint\";\n      return GearJoint2;\n    }(Joint)\n  );\n  var DEFAULTS$5 = {\n    maxForce: 1,\n    maxTorque: 1,\n    correctionFactor: 0.3\n  };\n  var MotorJoint = (\n    /** @class */\n    function(_super) {\n      __extends(MotorJoint2, _super);\n      function MotorJoint2(def, bodyA, bodyB) {\n        var _this = this;\n        if (!(_this instanceof MotorJoint2)) {\n          return new MotorJoint2(def, bodyA, bodyB);\n        }\n        def = options(def, DEFAULTS$5);\n        _this = _super.call(this, def, bodyA, bodyB) || this;\n        bodyA = _this.m_bodyA;\n        bodyB = _this.m_bodyB;\n        _this.m_type = MotorJoint2.TYPE;\n        _this.m_linearOffset = Vec2.isValid(def.linearOffset) ? Vec2.clone(def.linearOffset) : bodyA.getLocalPoint(bodyB.getPosition());\n        _this.m_angularOffset = Number.isFinite(def.angularOffset) ? def.angularOffset : bodyB.getAngle() - bodyA.getAngle();\n        _this.m_linearImpulse = Vec2.zero();\n        _this.m_angularImpulse = 0;\n        _this.m_maxForce = def.maxForce;\n        _this.m_maxTorque = def.maxTorque;\n        _this.m_correctionFactor = def.correctionFactor;\n        return _this;\n      }\n      MotorJoint2.prototype._serialize = function() {\n        return {\n          type: this.m_type,\n          bodyA: this.m_bodyA,\n          bodyB: this.m_bodyB,\n          collideConnected: this.m_collideConnected,\n          maxForce: this.m_maxForce,\n          maxTorque: this.m_maxTorque,\n          correctionFactor: this.m_correctionFactor,\n          linearOffset: this.m_linearOffset,\n          angularOffset: this.m_angularOffset\n        };\n      };\n      MotorJoint2._deserialize = function(data, world, restore) {\n        data = __assign({}, data);\n        data.bodyA = restore(Body, data.bodyA, world);\n        data.bodyB = restore(Body, data.bodyB, world);\n        var joint = new MotorJoint2(data);\n        return joint;\n      };\n      MotorJoint2.prototype._reset = function(def) {\n        if (Number.isFinite(def.angularOffset)) {\n          this.m_angularOffset = def.angularOffset;\n        }\n        if (Number.isFinite(def.maxForce)) {\n          this.m_maxForce = def.maxForce;\n        }\n        if (Number.isFinite(def.maxTorque)) {\n          this.m_maxTorque = def.maxTorque;\n        }\n        if (Number.isFinite(def.correctionFactor)) {\n          this.m_correctionFactor = def.correctionFactor;\n        }\n        if (Vec2.isValid(def.linearOffset)) {\n          this.m_linearOffset.set(def.linearOffset);\n        }\n      };\n      MotorJoint2.prototype.setMaxForce = function(force) {\n        this.m_maxForce = force;\n      };\n      MotorJoint2.prototype.getMaxForce = function() {\n        return this.m_maxForce;\n      };\n      MotorJoint2.prototype.setMaxTorque = function(torque) {\n        this.m_maxTorque = torque;\n      };\n      MotorJoint2.prototype.getMaxTorque = function() {\n        return this.m_maxTorque;\n      };\n      MotorJoint2.prototype.setCorrectionFactor = function(factor) {\n        this.m_correctionFactor = factor;\n      };\n      MotorJoint2.prototype.getCorrectionFactor = function() {\n        return this.m_correctionFactor;\n      };\n      MotorJoint2.prototype.setLinearOffset = function(linearOffset) {\n        if (linearOffset.x != this.m_linearOffset.x || linearOffset.y != this.m_linearOffset.y) {\n          this.m_bodyA.setAwake(true);\n          this.m_bodyB.setAwake(true);\n          this.m_linearOffset.set(linearOffset);\n        }\n      };\n      MotorJoint2.prototype.getLinearOffset = function() {\n        return this.m_linearOffset;\n      };\n      MotorJoint2.prototype.setAngularOffset = function(angularOffset) {\n        if (angularOffset != this.m_angularOffset) {\n          this.m_bodyA.setAwake(true);\n          this.m_bodyB.setAwake(true);\n          this.m_angularOffset = angularOffset;\n        }\n      };\n      MotorJoint2.prototype.getAngularOffset = function() {\n        return this.m_angularOffset;\n      };\n      MotorJoint2.prototype.getAnchorA = function() {\n        return this.m_bodyA.getPosition();\n      };\n      MotorJoint2.prototype.getAnchorB = function() {\n        return this.m_bodyB.getPosition();\n      };\n      MotorJoint2.prototype.getReactionForce = function(inv_dt) {\n        return Vec2.mulNumVec2(inv_dt, this.m_linearImpulse);\n      };\n      MotorJoint2.prototype.getReactionTorque = function(inv_dt) {\n        return inv_dt * this.m_angularImpulse;\n      };\n      MotorJoint2.prototype.initVelocityConstraints = function(step) {\n        this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n        this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n        this.m_invMassA = this.m_bodyA.m_invMass;\n        this.m_invMassB = this.m_bodyB.m_invMass;\n        this.m_invIA = this.m_bodyA.m_invI;\n        this.m_invIB = this.m_bodyB.m_invI;\n        var cA2 = this.m_bodyA.c_position.c;\n        var aA = this.m_bodyA.c_position.a;\n        var vA2 = this.m_bodyA.c_velocity.v;\n        var wA = this.m_bodyA.c_velocity.w;\n        var cB2 = this.m_bodyB.c_position.c;\n        var aB = this.m_bodyB.c_position.a;\n        var vB2 = this.m_bodyB.c_velocity.v;\n        var wB = this.m_bodyB.c_velocity.w;\n        var qA = Rot.neo(aA);\n        var qB = Rot.neo(aB);\n        this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_linearOffset, this.m_localCenterA));\n        this.m_rB = Rot.mulVec2(qB, Vec2.neg(this.m_localCenterB));\n        var mA = this.m_invMassA;\n        var mB = this.m_invMassB;\n        var iA = this.m_invIA;\n        var iB = this.m_invIB;\n        var K = new Mat22();\n        K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y * this.m_rB.y;\n        K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;\n        K.ey.x = K.ex.y;\n        K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x * this.m_rB.x;\n        this.m_linearMass = K.getInverse();\n        this.m_angularMass = iA + iB;\n        if (this.m_angularMass > 0) {\n          this.m_angularMass = 1 / this.m_angularMass;\n        }\n        this.m_linearError = Vec2.zero();\n        this.m_linearError.addCombine(1, cB2, 1, this.m_rB);\n        this.m_linearError.subCombine(1, cA2, 1, this.m_rA);\n        this.m_angularError = aB - aA - this.m_angularOffset;\n        if (step.warmStarting) {\n          this.m_linearImpulse.mul(step.dtRatio);\n          this.m_angularImpulse *= step.dtRatio;\n          var P3 = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);\n          vA2.subMul(mA, P3);\n          wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P3) + this.m_angularImpulse);\n          vB2.addMul(mB, P3);\n          wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P3) + this.m_angularImpulse);\n        } else {\n          this.m_linearImpulse.setZero();\n          this.m_angularImpulse = 0;\n        }\n        this.m_bodyA.c_velocity.v = vA2;\n        this.m_bodyA.c_velocity.w = wA;\n        this.m_bodyB.c_velocity.v = vB2;\n        this.m_bodyB.c_velocity.w = wB;\n      };\n      MotorJoint2.prototype.solveVelocityConstraints = function(step) {\n        var vA2 = this.m_bodyA.c_velocity.v;\n        var wA = this.m_bodyA.c_velocity.w;\n        var vB2 = this.m_bodyB.c_velocity.v;\n        var wB = this.m_bodyB.c_velocity.w;\n        var mA = this.m_invMassA;\n        var mB = this.m_invMassB;\n        var iA = this.m_invIA;\n        var iB = this.m_invIB;\n        var h = step.dt;\n        var inv_h = step.inv_dt;\n        {\n          var Cdot = wB - wA + inv_h * this.m_correctionFactor * this.m_angularError;\n          var impulse = -this.m_angularMass * Cdot;\n          var oldImpulse = this.m_angularImpulse;\n          var maxImpulse = h * this.m_maxTorque;\n          this.m_angularImpulse = clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);\n          impulse = this.m_angularImpulse - oldImpulse;\n          wA -= iA * impulse;\n          wB += iB * impulse;\n        }\n        {\n          var Cdot = Vec2.zero();\n          Cdot.addCombine(1, vB2, 1, Vec2.crossNumVec2(wB, this.m_rB));\n          Cdot.subCombine(1, vA2, 1, Vec2.crossNumVec2(wA, this.m_rA));\n          Cdot.addMul(inv_h * this.m_correctionFactor, this.m_linearError);\n          var impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot));\n          var oldImpulse = Vec2.clone(this.m_linearImpulse);\n          this.m_linearImpulse.add(impulse);\n          var maxImpulse = h * this.m_maxForce;\n          this.m_linearImpulse.clamp(maxImpulse);\n          impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);\n          vA2.subMul(mA, impulse);\n          wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n          vB2.addMul(mB, impulse);\n          wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n        }\n        this.m_bodyA.c_velocity.v = vA2;\n        this.m_bodyA.c_velocity.w = wA;\n        this.m_bodyB.c_velocity.v = vB2;\n        this.m_bodyB.c_velocity.w = wB;\n      };\n      MotorJoint2.prototype.solvePositionConstraints = function(step) {\n        return true;\n      };\n      MotorJoint2.TYPE = \"motor-joint\";\n      return MotorJoint2;\n    }(Joint)\n  );\n  var math_PI$2 = Math.PI;\n  var DEFAULTS$4 = {\n    maxForce: 0,\n    frequencyHz: 5,\n    dampingRatio: 0.7\n  };\n  var MouseJoint = (\n    /** @class */\n    function(_super) {\n      __extends(MouseJoint2, _super);\n      function MouseJoint2(def, bodyA, bodyB, target) {\n        var _this = this;\n        if (!(_this instanceof MouseJoint2)) {\n          return new MouseJoint2(def, bodyA, bodyB, target);\n        }\n        def = options(def, DEFAULTS$4);\n        _this = _super.call(this, def, bodyA, bodyB) || this;\n        bodyA = _this.m_bodyA;\n        bodyB = _this.m_bodyB;\n        _this.m_type = MouseJoint2.TYPE;\n        if (Vec2.isValid(target)) {\n          _this.m_targetA = Vec2.clone(target);\n        } else if (Vec2.isValid(def.target)) {\n          _this.m_targetA = Vec2.clone(def.target);\n        } else {\n          _this.m_targetA = Vec2.zero();\n        }\n        _this.m_localAnchorB = Transform.mulTVec2(bodyB.getTransform(), _this.m_targetA);\n        _this.m_maxForce = def.maxForce;\n        _this.m_impulse = Vec2.zero();\n        _this.m_frequencyHz = def.frequencyHz;\n        _this.m_dampingRatio = def.dampingRatio;\n        _this.m_beta = 0;\n        _this.m_gamma = 0;\n        _this.m_rB = Vec2.zero();\n        _this.m_localCenterB = Vec2.zero();\n        _this.m_invMassB = 0;\n        _this.m_invIB = 0;\n        _this.m_mass = new Mat22();\n        _this.m_C = Vec2.zero();\n        return _this;\n      }\n      MouseJoint2.prototype._serialize = function() {\n        return {\n          type: this.m_type,\n          bodyA: this.m_bodyA,\n          bodyB: this.m_bodyB,\n          collideConnected: this.m_collideConnected,\n          target: this.m_targetA,\n          maxForce: this.m_maxForce,\n          frequencyHz: this.m_frequencyHz,\n          dampingRatio: this.m_dampingRatio,\n          _localAnchorB: this.m_localAnchorB\n        };\n      };\n      MouseJoint2._deserialize = function(data, world, restore) {\n        data = __assign({}, data);\n        data.bodyA = restore(Body, data.bodyA, world);\n        data.bodyB = restore(Body, data.bodyB, world);\n        data.target = Vec2.clone(data.target);\n        var joint = new MouseJoint2(data);\n        if (data._localAnchorB) {\n          joint.m_localAnchorB = data._localAnchorB;\n        }\n        return joint;\n      };\n      MouseJoint2.prototype._reset = function(def) {\n        if (Number.isFinite(def.maxForce)) {\n          this.m_maxForce = def.maxForce;\n        }\n        if (Number.isFinite(def.frequencyHz)) {\n          this.m_frequencyHz = def.frequencyHz;\n        }\n        if (Number.isFinite(def.dampingRatio)) {\n          this.m_dampingRatio = def.dampingRatio;\n        }\n      };\n      MouseJoint2.prototype.setTarget = function(target) {\n        if (Vec2.areEqual(target, this.m_targetA))\n          return;\n        this.m_bodyB.setAwake(true);\n        this.m_targetA.set(target);\n      };\n      MouseJoint2.prototype.getTarget = function() {\n        return this.m_targetA;\n      };\n      MouseJoint2.prototype.setMaxForce = function(force) {\n        this.m_maxForce = force;\n      };\n      MouseJoint2.prototype.getMaxForce = function() {\n        return this.m_maxForce;\n      };\n      MouseJoint2.prototype.setFrequency = function(hz) {\n        this.m_frequencyHz = hz;\n      };\n      MouseJoint2.prototype.getFrequency = function() {\n        return this.m_frequencyHz;\n      };\n      MouseJoint2.prototype.setDampingRatio = function(ratio) {\n        this.m_dampingRatio = ratio;\n      };\n      MouseJoint2.prototype.getDampingRatio = function() {\n        return this.m_dampingRatio;\n      };\n      MouseJoint2.prototype.getAnchorA = function() {\n        return Vec2.clone(this.m_targetA);\n      };\n      MouseJoint2.prototype.getAnchorB = function() {\n        return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n      };\n      MouseJoint2.prototype.getReactionForce = function(inv_dt) {\n        return Vec2.mulNumVec2(inv_dt, this.m_impulse);\n      };\n      MouseJoint2.prototype.getReactionTorque = function(inv_dt) {\n        return inv_dt * 0;\n      };\n      MouseJoint2.prototype.shiftOrigin = function(newOrigin) {\n        this.m_targetA.sub(newOrigin);\n      };\n      MouseJoint2.prototype.initVelocityConstraints = function(step) {\n        this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n        this.m_invMassB = this.m_bodyB.m_invMass;\n        this.m_invIB = this.m_bodyB.m_invI;\n        var position = this.m_bodyB.c_position;\n        var velocity = this.m_bodyB.c_velocity;\n        var cB2 = position.c;\n        var aB = position.a;\n        var vB2 = velocity.v;\n        var wB = velocity.w;\n        var qB = Rot.neo(aB);\n        var mass = this.m_bodyB.getMass();\n        var omega = 2 * math_PI$2 * this.m_frequencyHz;\n        var d2 = 2 * mass * this.m_dampingRatio * omega;\n        var k = mass * (omega * omega);\n        var h = step.dt;\n        this.m_gamma = h * (d2 + h * k);\n        if (this.m_gamma != 0) {\n          this.m_gamma = 1 / this.m_gamma;\n        }\n        this.m_beta = h * k * this.m_gamma;\n        this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n        var K = new Mat22();\n        K.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y + this.m_gamma;\n        K.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;\n        K.ey.x = K.ex.y;\n        K.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x + this.m_gamma;\n        this.m_mass = K.getInverse();\n        this.m_C.setVec2(cB2);\n        this.m_C.addCombine(1, this.m_rB, -1, this.m_targetA);\n        this.m_C.mul(this.m_beta);\n        wB *= 0.98;\n        if (step.warmStarting) {\n          this.m_impulse.mul(step.dtRatio);\n          vB2.addMul(this.m_invMassB, this.m_impulse);\n          wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, this.m_impulse);\n        } else {\n          this.m_impulse.setZero();\n        }\n        velocity.v.setVec2(vB2);\n        velocity.w = wB;\n      };\n      MouseJoint2.prototype.solveVelocityConstraints = function(step) {\n        var velocity = this.m_bodyB.c_velocity;\n        var vB2 = Vec2.clone(velocity.v);\n        var wB = velocity.w;\n        var Cdot = Vec2.crossNumVec2(wB, this.m_rB);\n        Cdot.add(vB2);\n        Cdot.addCombine(1, this.m_C, this.m_gamma, this.m_impulse);\n        Cdot.neg();\n        var impulse = Mat22.mulVec2(this.m_mass, Cdot);\n        var oldImpulse = Vec2.clone(this.m_impulse);\n        this.m_impulse.add(impulse);\n        var maxImpulse = step.dt * this.m_maxForce;\n        this.m_impulse.clamp(maxImpulse);\n        impulse = Vec2.sub(this.m_impulse, oldImpulse);\n        vB2.addMul(this.m_invMassB, impulse);\n        wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n        velocity.v.setVec2(vB2);\n        velocity.w = wB;\n      };\n      MouseJoint2.prototype.solvePositionConstraints = function(step) {\n        return true;\n      };\n      MouseJoint2.TYPE = \"mouse-joint\";\n      return MouseJoint2;\n    }(Joint)\n  );\n  var math_abs$2 = Math.abs;\n  var DEFAULTS$3 = {\n    collideConnected: true\n  };\n  var PulleyJoint = (\n    /** @class */\n    function(_super) {\n      __extends(PulleyJoint2, _super);\n      function PulleyJoint2(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio) {\n        var _this = this;\n        if (!(_this instanceof PulleyJoint2)) {\n          return new PulleyJoint2(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio);\n        }\n        def = options(def, DEFAULTS$3);\n        _this = _super.call(this, def, bodyA, bodyB) || this;\n        bodyA = _this.m_bodyA;\n        bodyB = _this.m_bodyB;\n        _this.m_type = PulleyJoint2.TYPE;\n        _this.m_groundAnchorA = Vec2.clone(groundA ? groundA : def.groundAnchorA || Vec2.neo(-1, 1));\n        _this.m_groundAnchorB = Vec2.clone(groundB ? groundB : def.groundAnchorB || Vec2.neo(1, 1));\n        _this.m_localAnchorA = Vec2.clone(anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.neo(-1, 0));\n        _this.m_localAnchorB = Vec2.clone(anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.neo(1, 0));\n        _this.m_lengthA = Number.isFinite(def.lengthA) ? def.lengthA : Vec2.distance(anchorA, groundA);\n        _this.m_lengthB = Number.isFinite(def.lengthB) ? def.lengthB : Vec2.distance(anchorB, groundB);\n        _this.m_ratio = Number.isFinite(ratio) ? ratio : def.ratio;\n        _this.m_constant = _this.m_lengthA + _this.m_ratio * _this.m_lengthB;\n        _this.m_impulse = 0;\n        return _this;\n      }\n      PulleyJoint2.prototype._serialize = function() {\n        return {\n          type: this.m_type,\n          bodyA: this.m_bodyA,\n          bodyB: this.m_bodyB,\n          collideConnected: this.m_collideConnected,\n          groundAnchorA: this.m_groundAnchorA,\n          groundAnchorB: this.m_groundAnchorB,\n          localAnchorA: this.m_localAnchorA,\n          localAnchorB: this.m_localAnchorB,\n          lengthA: this.m_lengthA,\n          lengthB: this.m_lengthB,\n          ratio: this.m_ratio\n        };\n      };\n      PulleyJoint2._deserialize = function(data, world, restore) {\n        data = __assign({}, data);\n        data.bodyA = restore(Body, data.bodyA, world);\n        data.bodyB = restore(Body, data.bodyB, world);\n        var joint = new PulleyJoint2(data);\n        return joint;\n      };\n      PulleyJoint2.prototype._reset = function(def) {\n        if (Vec2.isValid(def.groundAnchorA)) {\n          this.m_groundAnchorA.set(def.groundAnchorA);\n        }\n        if (Vec2.isValid(def.groundAnchorB)) {\n          this.m_groundAnchorB.set(def.groundAnchorB);\n        }\n        if (Vec2.isValid(def.localAnchorA)) {\n          this.m_localAnchorA.set(def.localAnchorA);\n        } else if (Vec2.isValid(def.anchorA)) {\n          this.m_localAnchorA.set(this.m_bodyA.getLocalPoint(def.anchorA));\n        }\n        if (Vec2.isValid(def.localAnchorB)) {\n          this.m_localAnchorB.set(def.localAnchorB);\n        } else if (Vec2.isValid(def.anchorB)) {\n          this.m_localAnchorB.set(this.m_bodyB.getLocalPoint(def.anchorB));\n        }\n        if (Number.isFinite(def.lengthA)) {\n          this.m_lengthA = def.lengthA;\n        }\n        if (Number.isFinite(def.lengthB)) {\n          this.m_lengthB = def.lengthB;\n        }\n        if (Number.isFinite(def.ratio)) {\n          this.m_ratio = def.ratio;\n        }\n      };\n      PulleyJoint2.prototype.getGroundAnchorA = function() {\n        return this.m_groundAnchorA;\n      };\n      PulleyJoint2.prototype.getGroundAnchorB = function() {\n        return this.m_groundAnchorB;\n      };\n      PulleyJoint2.prototype.getLengthA = function() {\n        return this.m_lengthA;\n      };\n      PulleyJoint2.prototype.getLengthB = function() {\n        return this.m_lengthB;\n      };\n      PulleyJoint2.prototype.getRatio = function() {\n        return this.m_ratio;\n      };\n      PulleyJoint2.prototype.getCurrentLengthA = function() {\n        var p = this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        var s2 = this.m_groundAnchorA;\n        return Vec2.distance(p, s2);\n      };\n      PulleyJoint2.prototype.getCurrentLengthB = function() {\n        var p = this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        var s2 = this.m_groundAnchorB;\n        return Vec2.distance(p, s2);\n      };\n      PulleyJoint2.prototype.shiftOrigin = function(newOrigin) {\n        this.m_groundAnchorA.sub(newOrigin);\n        this.m_groundAnchorB.sub(newOrigin);\n      };\n      PulleyJoint2.prototype.getAnchorA = function() {\n        return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n      };\n      PulleyJoint2.prototype.getAnchorB = function() {\n        return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n      };\n      PulleyJoint2.prototype.getReactionForce = function(inv_dt) {\n        return Vec2.mulNumVec2(this.m_impulse, this.m_uB).mul(inv_dt);\n      };\n      PulleyJoint2.prototype.getReactionTorque = function(inv_dt) {\n        return 0;\n      };\n      PulleyJoint2.prototype.initVelocityConstraints = function(step) {\n        this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n        this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n        this.m_invMassA = this.m_bodyA.m_invMass;\n        this.m_invMassB = this.m_bodyB.m_invMass;\n        this.m_invIA = this.m_bodyA.m_invI;\n        this.m_invIB = this.m_bodyB.m_invI;\n        var cA2 = this.m_bodyA.c_position.c;\n        var aA = this.m_bodyA.c_position.a;\n        var vA2 = this.m_bodyA.c_velocity.v;\n        var wA = this.m_bodyA.c_velocity.w;\n        var cB2 = this.m_bodyB.c_position.c;\n        var aB = this.m_bodyB.c_position.a;\n        var vB2 = this.m_bodyB.c_velocity.v;\n        var wB = this.m_bodyB.c_velocity.w;\n        var qA = Rot.neo(aA);\n        var qB = Rot.neo(aB);\n        this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n        this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n        this.m_uA = Vec2.sub(Vec2.add(cA2, this.m_rA), this.m_groundAnchorA);\n        this.m_uB = Vec2.sub(Vec2.add(cB2, this.m_rB), this.m_groundAnchorB);\n        var lengthA = this.m_uA.length();\n        var lengthB = this.m_uB.length();\n        if (lengthA > 10 * SettingsInternal.linearSlop) {\n          this.m_uA.mul(1 / lengthA);\n        } else {\n          this.m_uA.setZero();\n        }\n        if (lengthB > 10 * SettingsInternal.linearSlop) {\n          this.m_uB.mul(1 / lengthB);\n        } else {\n          this.m_uB.setZero();\n        }\n        var ruA = Vec2.crossVec2Vec2(this.m_rA, this.m_uA);\n        var ruB = Vec2.crossVec2Vec2(this.m_rB, this.m_uB);\n        var mA = this.m_invMassA + this.m_invIA * ruA * ruA;\n        var mB = this.m_invMassB + this.m_invIB * ruB * ruB;\n        this.m_mass = mA + this.m_ratio * this.m_ratio * mB;\n        if (this.m_mass > 0) {\n          this.m_mass = 1 / this.m_mass;\n        }\n        if (step.warmStarting) {\n          this.m_impulse *= step.dtRatio;\n          var PA = Vec2.mulNumVec2(-this.m_impulse, this.m_uA);\n          var PB = Vec2.mulNumVec2(-this.m_ratio * this.m_impulse, this.m_uB);\n          vA2.addMul(this.m_invMassA, PA);\n          wA += this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, PA);\n          vB2.addMul(this.m_invMassB, PB);\n          wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, PB);\n        } else {\n          this.m_impulse = 0;\n        }\n        this.m_bodyA.c_velocity.v = vA2;\n        this.m_bodyA.c_velocity.w = wA;\n        this.m_bodyB.c_velocity.v = vB2;\n        this.m_bodyB.c_velocity.w = wB;\n      };\n      PulleyJoint2.prototype.solveVelocityConstraints = function(step) {\n        var vA2 = this.m_bodyA.c_velocity.v;\n        var wA = this.m_bodyA.c_velocity.w;\n        var vB2 = this.m_bodyB.c_velocity.v;\n        var wB = this.m_bodyB.c_velocity.w;\n        var vpA = Vec2.add(vA2, Vec2.crossNumVec2(wA, this.m_rA));\n        var vpB = Vec2.add(vB2, Vec2.crossNumVec2(wB, this.m_rB));\n        var Cdot = -Vec2.dot(this.m_uA, vpA) - this.m_ratio * Vec2.dot(this.m_uB, vpB);\n        var impulse = -this.m_mass * Cdot;\n        this.m_impulse += impulse;\n        var PA = Vec2.mulNumVec2(-impulse, this.m_uA);\n        var PB = Vec2.mulNumVec2(-this.m_ratio * impulse, this.m_uB);\n        vA2.addMul(this.m_invMassA, PA);\n        wA += this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, PA);\n        vB2.addMul(this.m_invMassB, PB);\n        wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, PB);\n        this.m_bodyA.c_velocity.v = vA2;\n        this.m_bodyA.c_velocity.w = wA;\n        this.m_bodyB.c_velocity.v = vB2;\n        this.m_bodyB.c_velocity.w = wB;\n      };\n      PulleyJoint2.prototype.solvePositionConstraints = function(step) {\n        var cA2 = this.m_bodyA.c_position.c;\n        var aA = this.m_bodyA.c_position.a;\n        var cB2 = this.m_bodyB.c_position.c;\n        var aB = this.m_bodyB.c_position.a;\n        var qA = Rot.neo(aA);\n        var qB = Rot.neo(aB);\n        var rA2 = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n        var rB2 = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n        var uA = Vec2.sub(Vec2.add(cA2, this.m_rA), this.m_groundAnchorA);\n        var uB = Vec2.sub(Vec2.add(cB2, this.m_rB), this.m_groundAnchorB);\n        var lengthA = uA.length();\n        var lengthB = uB.length();\n        if (lengthA > 10 * SettingsInternal.linearSlop) {\n          uA.mul(1 / lengthA);\n        } else {\n          uA.setZero();\n        }\n        if (lengthB > 10 * SettingsInternal.linearSlop) {\n          uB.mul(1 / lengthB);\n        } else {\n          uB.setZero();\n        }\n        var ruA = Vec2.crossVec2Vec2(rA2, uA);\n        var ruB = Vec2.crossVec2Vec2(rB2, uB);\n        var mA = this.m_invMassA + this.m_invIA * ruA * ruA;\n        var mB = this.m_invMassB + this.m_invIB * ruB * ruB;\n        var mass = mA + this.m_ratio * this.m_ratio * mB;\n        if (mass > 0) {\n          mass = 1 / mass;\n        }\n        var C = this.m_constant - lengthA - this.m_ratio * lengthB;\n        var linearError = math_abs$2(C);\n        var impulse = -mass * C;\n        var PA = Vec2.mulNumVec2(-impulse, uA);\n        var PB = Vec2.mulNumVec2(-this.m_ratio * impulse, uB);\n        cA2.addMul(this.m_invMassA, PA);\n        aA += this.m_invIA * Vec2.crossVec2Vec2(rA2, PA);\n        cB2.addMul(this.m_invMassB, PB);\n        aB += this.m_invIB * Vec2.crossVec2Vec2(rB2, PB);\n        this.m_bodyA.c_position.c = cA2;\n        this.m_bodyA.c_position.a = aA;\n        this.m_bodyB.c_position.c = cB2;\n        this.m_bodyB.c_position.a = aB;\n        return linearError < SettingsInternal.linearSlop;\n      };\n      PulleyJoint2.TYPE = \"pulley-joint\";\n      return PulleyJoint2;\n    }(Joint)\n  );\n  var math_min$1 = Math.min;\n  var LimitState;\n  (function(LimitState2) {\n    LimitState2[LimitState2[\"inactiveLimit\"] = 0] = \"inactiveLimit\";\n    LimitState2[LimitState2[\"atLowerLimit\"] = 1] = \"atLowerLimit\";\n    LimitState2[LimitState2[\"atUpperLimit\"] = 2] = \"atUpperLimit\";\n    LimitState2[LimitState2[\"equalLimits\"] = 3] = \"equalLimits\";\n  })(LimitState || (LimitState = {}));\n  var DEFAULTS$2 = {\n    maxLength: 0\n  };\n  var RopeJoint = (\n    /** @class */\n    function(_super) {\n      __extends(RopeJoint2, _super);\n      function RopeJoint2(def, bodyA, bodyB, anchor) {\n        var _this = this;\n        if (!(_this instanceof RopeJoint2)) {\n          return new RopeJoint2(def, bodyA, bodyB, anchor);\n        }\n        def = options(def, DEFAULTS$2);\n        _this = _super.call(this, def, bodyA, bodyB) || this;\n        bodyA = _this.m_bodyA;\n        bodyB = _this.m_bodyB;\n        _this.m_type = RopeJoint2.TYPE;\n        _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.neo(-1, 0));\n        _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.neo(1, 0));\n        _this.m_maxLength = def.maxLength;\n        _this.m_mass = 0;\n        _this.m_impulse = 0;\n        _this.m_length = 0;\n        _this.m_state = LimitState.inactiveLimit;\n        return _this;\n      }\n      RopeJoint2.prototype._serialize = function() {\n        return {\n          type: this.m_type,\n          bodyA: this.m_bodyA,\n          bodyB: this.m_bodyB,\n          collideConnected: this.m_collideConnected,\n          localAnchorA: this.m_localAnchorA,\n          localAnchorB: this.m_localAnchorB,\n          maxLength: this.m_maxLength\n        };\n      };\n      RopeJoint2._deserialize = function(data, world, restore) {\n        data = __assign({}, data);\n        data.bodyA = restore(Body, data.bodyA, world);\n        data.bodyB = restore(Body, data.bodyB, world);\n        var joint = new RopeJoint2(data);\n        return joint;\n      };\n      RopeJoint2.prototype._reset = function(def) {\n        if (Number.isFinite(def.maxLength)) {\n          this.m_maxLength = def.maxLength;\n        }\n      };\n      RopeJoint2.prototype.getLocalAnchorA = function() {\n        return this.m_localAnchorA;\n      };\n      RopeJoint2.prototype.getLocalAnchorB = function() {\n        return this.m_localAnchorB;\n      };\n      RopeJoint2.prototype.setMaxLength = function(length) {\n        this.m_maxLength = length;\n      };\n      RopeJoint2.prototype.getMaxLength = function() {\n        return this.m_maxLength;\n      };\n      RopeJoint2.prototype.getLimitState = function() {\n        return this.m_state;\n      };\n      RopeJoint2.prototype.getAnchorA = function() {\n        return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n      };\n      RopeJoint2.prototype.getAnchorB = function() {\n        return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n      };\n      RopeJoint2.prototype.getReactionForce = function(inv_dt) {\n        return Vec2.mulNumVec2(this.m_impulse, this.m_u).mul(inv_dt);\n      };\n      RopeJoint2.prototype.getReactionTorque = function(inv_dt) {\n        return 0;\n      };\n      RopeJoint2.prototype.initVelocityConstraints = function(step) {\n        this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n        this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n        this.m_invMassA = this.m_bodyA.m_invMass;\n        this.m_invMassB = this.m_bodyB.m_invMass;\n        this.m_invIA = this.m_bodyA.m_invI;\n        this.m_invIB = this.m_bodyB.m_invI;\n        var cA2 = this.m_bodyA.c_position.c;\n        var aA = this.m_bodyA.c_position.a;\n        var vA2 = this.m_bodyA.c_velocity.v;\n        var wA = this.m_bodyA.c_velocity.w;\n        var cB2 = this.m_bodyB.c_position.c;\n        var aB = this.m_bodyB.c_position.a;\n        var vB2 = this.m_bodyB.c_velocity.v;\n        var wB = this.m_bodyB.c_velocity.w;\n        var qA = Rot.neo(aA);\n        var qB = Rot.neo(aB);\n        this.m_rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n        this.m_rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n        this.m_u = Vec2.zero();\n        this.m_u.addCombine(1, cB2, 1, this.m_rB);\n        this.m_u.subCombine(1, cA2, 1, this.m_rA);\n        this.m_length = this.m_u.length();\n        var C = this.m_length - this.m_maxLength;\n        if (C > 0) {\n          this.m_state = LimitState.atUpperLimit;\n        } else {\n          this.m_state = LimitState.inactiveLimit;\n        }\n        if (this.m_length > SettingsInternal.linearSlop) {\n          this.m_u.mul(1 / this.m_length);\n        } else {\n          this.m_u.setZero();\n          this.m_mass = 0;\n          this.m_impulse = 0;\n          return;\n        }\n        var crA = Vec2.crossVec2Vec2(this.m_rA, this.m_u);\n        var crB = Vec2.crossVec2Vec2(this.m_rB, this.m_u);\n        var invMass = this.m_invMassA + this.m_invIA * crA * crA + this.m_invMassB + this.m_invIB * crB * crB;\n        this.m_mass = invMass != 0 ? 1 / invMass : 0;\n        if (step.warmStarting) {\n          this.m_impulse *= step.dtRatio;\n          var P3 = Vec2.mulNumVec2(this.m_impulse, this.m_u);\n          vA2.subMul(this.m_invMassA, P3);\n          wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P3);\n          vB2.addMul(this.m_invMassB, P3);\n          wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P3);\n        } else {\n          this.m_impulse = 0;\n        }\n        this.m_bodyA.c_velocity.v.setVec2(vA2);\n        this.m_bodyA.c_velocity.w = wA;\n        this.m_bodyB.c_velocity.v.setVec2(vB2);\n        this.m_bodyB.c_velocity.w = wB;\n      };\n      RopeJoint2.prototype.solveVelocityConstraints = function(step) {\n        var vA2 = this.m_bodyA.c_velocity.v;\n        var wA = this.m_bodyA.c_velocity.w;\n        var vB2 = this.m_bodyB.c_velocity.v;\n        var wB = this.m_bodyB.c_velocity.w;\n        var vpA = Vec2.addCrossNumVec2(vA2, wA, this.m_rA);\n        var vpB = Vec2.addCrossNumVec2(vB2, wB, this.m_rB);\n        var C = this.m_length - this.m_maxLength;\n        var Cdot = Vec2.dot(this.m_u, Vec2.sub(vpB, vpA));\n        if (C < 0) {\n          Cdot += step.inv_dt * C;\n        }\n        var impulse = -this.m_mass * Cdot;\n        var oldImpulse = this.m_impulse;\n        this.m_impulse = math_min$1(0, this.m_impulse + impulse);\n        impulse = this.m_impulse - oldImpulse;\n        var P3 = Vec2.mulNumVec2(impulse, this.m_u);\n        vA2.subMul(this.m_invMassA, P3);\n        wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P3);\n        vB2.addMul(this.m_invMassB, P3);\n        wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P3);\n        this.m_bodyA.c_velocity.v = vA2;\n        this.m_bodyA.c_velocity.w = wA;\n        this.m_bodyB.c_velocity.v = vB2;\n        this.m_bodyB.c_velocity.w = wB;\n      };\n      RopeJoint2.prototype.solvePositionConstraints = function(step) {\n        var cA2 = this.m_bodyA.c_position.c;\n        var aA = this.m_bodyA.c_position.a;\n        var cB2 = this.m_bodyB.c_position.c;\n        var aB = this.m_bodyB.c_position.a;\n        var qA = Rot.neo(aA);\n        var qB = Rot.neo(aB);\n        var rA2 = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n        var rB2 = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n        var u = Vec2.zero();\n        u.addCombine(1, cB2, 1, rB2);\n        u.subCombine(1, cA2, 1, rA2);\n        var length = u.normalize();\n        var C = length - this.m_maxLength;\n        C = clamp(C, 0, SettingsInternal.maxLinearCorrection);\n        var impulse = -this.m_mass * C;\n        var P3 = Vec2.mulNumVec2(impulse, u);\n        cA2.subMul(this.m_invMassA, P3);\n        aA -= this.m_invIA * Vec2.crossVec2Vec2(rA2, P3);\n        cB2.addMul(this.m_invMassB, P3);\n        aB += this.m_invIB * Vec2.crossVec2Vec2(rB2, P3);\n        this.m_bodyA.c_position.c.setVec2(cA2);\n        this.m_bodyA.c_position.a = aA;\n        this.m_bodyB.c_position.c.setVec2(cB2);\n        this.m_bodyB.c_position.a = aB;\n        return length - this.m_maxLength < SettingsInternal.linearSlop;\n      };\n      RopeJoint2.TYPE = \"rope-joint\";\n      return RopeJoint2;\n    }(Joint)\n  );\n  var math_abs$1 = Math.abs;\n  var math_PI$1 = Math.PI;\n  var DEFAULTS$1 = {\n    frequencyHz: 0,\n    dampingRatio: 0\n  };\n  var WeldJoint = (\n    /** @class */\n    function(_super) {\n      __extends(WeldJoint2, _super);\n      function WeldJoint2(def, bodyA, bodyB, anchor) {\n        var _this = this;\n        if (!(_this instanceof WeldJoint2)) {\n          return new WeldJoint2(def, bodyA, bodyB, anchor);\n        }\n        def = options(def, DEFAULTS$1);\n        _this = _super.call(this, def, bodyA, bodyB) || this;\n        bodyA = _this.m_bodyA;\n        bodyB = _this.m_bodyB;\n        _this.m_type = WeldJoint2.TYPE;\n        _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n        _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n        _this.m_referenceAngle = Number.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n        _this.m_frequencyHz = def.frequencyHz;\n        _this.m_dampingRatio = def.dampingRatio;\n        _this.m_impulse = new Vec3();\n        _this.m_bias = 0;\n        _this.m_gamma = 0;\n        _this.m_mass = new Mat33();\n        return _this;\n      }\n      WeldJoint2.prototype._serialize = function() {\n        return {\n          type: this.m_type,\n          bodyA: this.m_bodyA,\n          bodyB: this.m_bodyB,\n          collideConnected: this.m_collideConnected,\n          frequencyHz: this.m_frequencyHz,\n          dampingRatio: this.m_dampingRatio,\n          localAnchorA: this.m_localAnchorA,\n          localAnchorB: this.m_localAnchorB,\n          referenceAngle: this.m_referenceAngle\n        };\n      };\n      WeldJoint2._deserialize = function(data, world, restore) {\n        data = __assign({}, data);\n        data.bodyA = restore(Body, data.bodyA, world);\n        data.bodyB = restore(Body, data.bodyB, world);\n        var joint = new WeldJoint2(data);\n        return joint;\n      };\n      WeldJoint2.prototype._reset = function(def) {\n        if (def.anchorA) {\n          this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n        } else if (def.localAnchorA) {\n          this.m_localAnchorA.setVec2(def.localAnchorA);\n        }\n        if (def.anchorB) {\n          this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n        } else if (def.localAnchorB) {\n          this.m_localAnchorB.setVec2(def.localAnchorB);\n        }\n        if (Number.isFinite(def.frequencyHz)) {\n          this.m_frequencyHz = def.frequencyHz;\n        }\n        if (Number.isFinite(def.dampingRatio)) {\n          this.m_dampingRatio = def.dampingRatio;\n        }\n      };\n      WeldJoint2.prototype.getLocalAnchorA = function() {\n        return this.m_localAnchorA;\n      };\n      WeldJoint2.prototype.getLocalAnchorB = function() {\n        return this.m_localAnchorB;\n      };\n      WeldJoint2.prototype.getReferenceAngle = function() {\n        return this.m_referenceAngle;\n      };\n      WeldJoint2.prototype.setFrequency = function(hz) {\n        this.m_frequencyHz = hz;\n      };\n      WeldJoint2.prototype.getFrequency = function() {\n        return this.m_frequencyHz;\n      };\n      WeldJoint2.prototype.setDampingRatio = function(ratio) {\n        this.m_dampingRatio = ratio;\n      };\n      WeldJoint2.prototype.getDampingRatio = function() {\n        return this.m_dampingRatio;\n      };\n      WeldJoint2.prototype.getAnchorA = function() {\n        return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n      };\n      WeldJoint2.prototype.getAnchorB = function() {\n        return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n      };\n      WeldJoint2.prototype.getReactionForce = function(inv_dt) {\n        return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);\n      };\n      WeldJoint2.prototype.getReactionTorque = function(inv_dt) {\n        return inv_dt * this.m_impulse.z;\n      };\n      WeldJoint2.prototype.initVelocityConstraints = function(step) {\n        this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n        this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n        this.m_invMassA = this.m_bodyA.m_invMass;\n        this.m_invMassB = this.m_bodyB.m_invMass;\n        this.m_invIA = this.m_bodyA.m_invI;\n        this.m_invIB = this.m_bodyB.m_invI;\n        var aA = this.m_bodyA.c_position.a;\n        var vA2 = this.m_bodyA.c_velocity.v;\n        var wA = this.m_bodyA.c_velocity.w;\n        var aB = this.m_bodyB.c_position.a;\n        var vB2 = this.m_bodyB.c_velocity.v;\n        var wB = this.m_bodyB.c_velocity.w;\n        var qA = Rot.neo(aA);\n        var qB = Rot.neo(aB);\n        this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n        this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n        var mA = this.m_invMassA;\n        var mB = this.m_invMassB;\n        var iA = this.m_invIA;\n        var iB = this.m_invIB;\n        var K = new Mat33();\n        K.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;\n        K.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;\n        K.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;\n        K.ex.y = K.ey.x;\n        K.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;\n        K.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;\n        K.ex.z = K.ez.x;\n        K.ey.z = K.ez.y;\n        K.ez.z = iA + iB;\n        if (this.m_frequencyHz > 0) {\n          K.getInverse22(this.m_mass);\n          var invM = iA + iB;\n          var m = invM > 0 ? 1 / invM : 0;\n          var C = aB - aA - this.m_referenceAngle;\n          var omega = 2 * math_PI$1 * this.m_frequencyHz;\n          var d2 = 2 * m * this.m_dampingRatio * omega;\n          var k = m * omega * omega;\n          var h = step.dt;\n          this.m_gamma = h * (d2 + h * k);\n          this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0;\n          this.m_bias = C * h * k * this.m_gamma;\n          invM += this.m_gamma;\n          this.m_mass.ez.z = invM != 0 ? 1 / invM : 0;\n        } else if (K.ez.z == 0) {\n          K.getInverse22(this.m_mass);\n          this.m_gamma = 0;\n          this.m_bias = 0;\n        } else {\n          K.getSymInverse33(this.m_mass);\n          this.m_gamma = 0;\n          this.m_bias = 0;\n        }\n        if (step.warmStarting) {\n          this.m_impulse.mul(step.dtRatio);\n          var P3 = Vec2.neo(this.m_impulse.x, this.m_impulse.y);\n          vA2.subMul(mA, P3);\n          wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P3) + this.m_impulse.z);\n          vB2.addMul(mB, P3);\n          wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P3) + this.m_impulse.z);\n        } else {\n          this.m_impulse.setZero();\n        }\n        this.m_bodyA.c_velocity.v = vA2;\n        this.m_bodyA.c_velocity.w = wA;\n        this.m_bodyB.c_velocity.v = vB2;\n        this.m_bodyB.c_velocity.w = wB;\n      };\n      WeldJoint2.prototype.solveVelocityConstraints = function(step) {\n        var vA2 = this.m_bodyA.c_velocity.v;\n        var wA = this.m_bodyA.c_velocity.w;\n        var vB2 = this.m_bodyB.c_velocity.v;\n        var wB = this.m_bodyB.c_velocity.w;\n        var mA = this.m_invMassA;\n        var mB = this.m_invMassB;\n        var iA = this.m_invIA;\n        var iB = this.m_invIB;\n        if (this.m_frequencyHz > 0) {\n          var Cdot2 = wB - wA;\n          var impulse2 = -this.m_mass.ez.z * (Cdot2 + this.m_bias + this.m_gamma * this.m_impulse.z);\n          this.m_impulse.z += impulse2;\n          wA -= iA * impulse2;\n          wB += iB * impulse2;\n          var Cdot1 = Vec2.zero();\n          Cdot1.addCombine(1, vB2, 1, Vec2.crossNumVec2(wB, this.m_rB));\n          Cdot1.subCombine(1, vA2, 1, Vec2.crossNumVec2(wA, this.m_rA));\n          var impulse1 = Vec2.neg(Mat33.mulVec2(this.m_mass, Cdot1));\n          this.m_impulse.x += impulse1.x;\n          this.m_impulse.y += impulse1.y;\n          var P3 = Vec2.clone(impulse1);\n          vA2.subMul(mA, P3);\n          wA -= iA * Vec2.crossVec2Vec2(this.m_rA, P3);\n          vB2.addMul(mB, P3);\n          wB += iB * Vec2.crossVec2Vec2(this.m_rB, P3);\n        } else {\n          var Cdot1 = Vec2.zero();\n          Cdot1.addCombine(1, vB2, 1, Vec2.crossNumVec2(wB, this.m_rB));\n          Cdot1.subCombine(1, vA2, 1, Vec2.crossNumVec2(wA, this.m_rA));\n          var Cdot2 = wB - wA;\n          var Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);\n          var impulse = Vec3.neg(Mat33.mulVec3(this.m_mass, Cdot));\n          this.m_impulse.add(impulse);\n          var P3 = Vec2.neo(impulse.x, impulse.y);\n          vA2.subMul(mA, P3);\n          wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P3) + impulse.z);\n          vB2.addMul(mB, P3);\n          wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P3) + impulse.z);\n        }\n        this.m_bodyA.c_velocity.v = vA2;\n        this.m_bodyA.c_velocity.w = wA;\n        this.m_bodyB.c_velocity.v = vB2;\n        this.m_bodyB.c_velocity.w = wB;\n      };\n      WeldJoint2.prototype.solvePositionConstraints = function(step) {\n        var cA2 = this.m_bodyA.c_position.c;\n        var aA = this.m_bodyA.c_position.a;\n        var cB2 = this.m_bodyB.c_position.c;\n        var aB = this.m_bodyB.c_position.a;\n        var qA = Rot.neo(aA);\n        var qB = Rot.neo(aB);\n        var mA = this.m_invMassA;\n        var mB = this.m_invMassB;\n        var iA = this.m_invIA;\n        var iB = this.m_invIB;\n        var rA2 = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n        var rB2 = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n        var positionError;\n        var angularError;\n        var K = new Mat33();\n        K.ex.x = mA + mB + rA2.y * rA2.y * iA + rB2.y * rB2.y * iB;\n        K.ey.x = -rA2.y * rA2.x * iA - rB2.y * rB2.x * iB;\n        K.ez.x = -rA2.y * iA - rB2.y * iB;\n        K.ex.y = K.ey.x;\n        K.ey.y = mA + mB + rA2.x * rA2.x * iA + rB2.x * rB2.x * iB;\n        K.ez.y = rA2.x * iA + rB2.x * iB;\n        K.ex.z = K.ez.x;\n        K.ey.z = K.ez.y;\n        K.ez.z = iA + iB;\n        if (this.m_frequencyHz > 0) {\n          var C1 = Vec2.zero();\n          C1.addCombine(1, cB2, 1, rB2);\n          C1.subCombine(1, cA2, 1, rA2);\n          positionError = C1.length();\n          angularError = 0;\n          var P3 = Vec2.neg(K.solve22(C1));\n          cA2.subMul(mA, P3);\n          aA -= iA * Vec2.crossVec2Vec2(rA2, P3);\n          cB2.addMul(mB, P3);\n          aB += iB * Vec2.crossVec2Vec2(rB2, P3);\n        } else {\n          var C1 = Vec2.zero();\n          C1.addCombine(1, cB2, 1, rB2);\n          C1.subCombine(1, cA2, 1, rA2);\n          var C2 = aB - aA - this.m_referenceAngle;\n          positionError = C1.length();\n          angularError = math_abs$1(C2);\n          var C = new Vec3(C1.x, C1.y, C2);\n          var impulse = new Vec3();\n          if (K.ez.z > 0) {\n            impulse = Vec3.neg(K.solve33(C));\n          } else {\n            var impulse2 = Vec2.neg(K.solve22(C1));\n            impulse.set(impulse2.x, impulse2.y, 0);\n          }\n          var P3 = Vec2.neo(impulse.x, impulse.y);\n          cA2.subMul(mA, P3);\n          aA -= iA * (Vec2.crossVec2Vec2(rA2, P3) + impulse.z);\n          cB2.addMul(mB, P3);\n          aB += iB * (Vec2.crossVec2Vec2(rB2, P3) + impulse.z);\n        }\n        this.m_bodyA.c_position.c = cA2;\n        this.m_bodyA.c_position.a = aA;\n        this.m_bodyB.c_position.c = cB2;\n        this.m_bodyB.c_position.a = aB;\n        return positionError <= SettingsInternal.linearSlop && angularError <= SettingsInternal.angularSlop;\n      };\n      WeldJoint2.TYPE = \"weld-joint\";\n      return WeldJoint2;\n    }(Joint)\n  );\n  var math_abs = Math.abs;\n  var math_PI = Math.PI;\n  var DEFAULTS = {\n    enableMotor: false,\n    maxMotorTorque: 0,\n    motorSpeed: 0,\n    frequencyHz: 2,\n    dampingRatio: 0.7\n  };\n  var WheelJoint = (\n    /** @class */\n    function(_super) {\n      __extends(WheelJoint2, _super);\n      function WheelJoint2(def, bodyA, bodyB, anchor, axis) {\n        var _this = this;\n        if (!(_this instanceof WheelJoint2)) {\n          return new WheelJoint2(def, bodyA, bodyB, anchor, axis);\n        }\n        def = options(def, DEFAULTS);\n        _this = _super.call(this, def, bodyA, bodyB) || this;\n        bodyA = _this.m_bodyA;\n        bodyB = _this.m_bodyB;\n        _this.m_ax = Vec2.zero();\n        _this.m_ay = Vec2.zero();\n        _this.m_type = WheelJoint2.TYPE;\n        _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n        _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n        if (Vec2.isValid(axis)) {\n          _this.m_localXAxisA = bodyA.getLocalVector(axis);\n        } else if (Vec2.isValid(def.localAxisA)) {\n          _this.m_localXAxisA = Vec2.clone(def.localAxisA);\n        } else if (Vec2.isValid(def.localAxis)) {\n          _this.m_localXAxisA = Vec2.clone(def.localAxis);\n        } else {\n          _this.m_localXAxisA = Vec2.neo(1, 0);\n        }\n        _this.m_localYAxisA = Vec2.crossNumVec2(1, _this.m_localXAxisA);\n        _this.m_mass = 0;\n        _this.m_impulse = 0;\n        _this.m_motorMass = 0;\n        _this.m_motorImpulse = 0;\n        _this.m_springMass = 0;\n        _this.m_springImpulse = 0;\n        _this.m_maxMotorTorque = def.maxMotorTorque;\n        _this.m_motorSpeed = def.motorSpeed;\n        _this.m_enableMotor = def.enableMotor;\n        _this.m_frequencyHz = def.frequencyHz;\n        _this.m_dampingRatio = def.dampingRatio;\n        _this.m_bias = 0;\n        _this.m_gamma = 0;\n        return _this;\n      }\n      WheelJoint2.prototype._serialize = function() {\n        return {\n          type: this.m_type,\n          bodyA: this.m_bodyA,\n          bodyB: this.m_bodyB,\n          collideConnected: this.m_collideConnected,\n          enableMotor: this.m_enableMotor,\n          maxMotorTorque: this.m_maxMotorTorque,\n          motorSpeed: this.m_motorSpeed,\n          frequencyHz: this.m_frequencyHz,\n          dampingRatio: this.m_dampingRatio,\n          localAnchorA: this.m_localAnchorA,\n          localAnchorB: this.m_localAnchorB,\n          localAxisA: this.m_localXAxisA\n        };\n      };\n      WheelJoint2._deserialize = function(data, world, restore) {\n        data = __assign({}, data);\n        data.bodyA = restore(Body, data.bodyA, world);\n        data.bodyB = restore(Body, data.bodyB, world);\n        var joint = new WheelJoint2(data);\n        return joint;\n      };\n      WheelJoint2.prototype._reset = function(def) {\n        if (def.anchorA) {\n          this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n        } else if (def.localAnchorA) {\n          this.m_localAnchorA.setVec2(def.localAnchorA);\n        }\n        if (def.anchorB) {\n          this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n        } else if (def.localAnchorB) {\n          this.m_localAnchorB.setVec2(def.localAnchorB);\n        }\n        if (def.localAxisA) {\n          this.m_localXAxisA.setVec2(def.localAxisA);\n          this.m_localYAxisA.setVec2(Vec2.crossNumVec2(1, def.localAxisA));\n        }\n        if (def.enableMotor !== void 0) {\n          this.m_enableMotor = def.enableMotor;\n        }\n        if (Number.isFinite(def.maxMotorTorque)) {\n          this.m_maxMotorTorque = def.maxMotorTorque;\n        }\n        if (Number.isFinite(def.motorSpeed)) {\n          this.m_motorSpeed = def.motorSpeed;\n        }\n        if (Number.isFinite(def.frequencyHz)) {\n          this.m_frequencyHz = def.frequencyHz;\n        }\n        if (Number.isFinite(def.dampingRatio)) {\n          this.m_dampingRatio = def.dampingRatio;\n        }\n      };\n      WheelJoint2.prototype.getLocalAnchorA = function() {\n        return this.m_localAnchorA;\n      };\n      WheelJoint2.prototype.getLocalAnchorB = function() {\n        return this.m_localAnchorB;\n      };\n      WheelJoint2.prototype.getLocalAxisA = function() {\n        return this.m_localXAxisA;\n      };\n      WheelJoint2.prototype.getJointTranslation = function() {\n        var bA = this.m_bodyA;\n        var bB = this.m_bodyB;\n        var pA2 = bA.getWorldPoint(this.m_localAnchorA);\n        var pB2 = bB.getWorldPoint(this.m_localAnchorB);\n        var d2 = Vec2.sub(pB2, pA2);\n        var axis = bA.getWorldVector(this.m_localXAxisA);\n        var translation2 = Vec2.dot(d2, axis);\n        return translation2;\n      };\n      WheelJoint2.prototype.getJointSpeed = function() {\n        var wA = this.m_bodyA.m_angularVelocity;\n        var wB = this.m_bodyB.m_angularVelocity;\n        return wB - wA;\n      };\n      WheelJoint2.prototype.isMotorEnabled = function() {\n        return this.m_enableMotor;\n      };\n      WheelJoint2.prototype.enableMotor = function(flag) {\n        if (flag == this.m_enableMotor)\n          return;\n        this.m_bodyA.setAwake(true);\n        this.m_bodyB.setAwake(true);\n        this.m_enableMotor = flag;\n      };\n      WheelJoint2.prototype.setMotorSpeed = function(speed) {\n        if (speed == this.m_motorSpeed)\n          return;\n        this.m_bodyA.setAwake(true);\n        this.m_bodyB.setAwake(true);\n        this.m_motorSpeed = speed;\n      };\n      WheelJoint2.prototype.getMotorSpeed = function() {\n        return this.m_motorSpeed;\n      };\n      WheelJoint2.prototype.setMaxMotorTorque = function(torque) {\n        if (torque == this.m_maxMotorTorque)\n          return;\n        this.m_bodyA.setAwake(true);\n        this.m_bodyB.setAwake(true);\n        this.m_maxMotorTorque = torque;\n      };\n      WheelJoint2.prototype.getMaxMotorTorque = function() {\n        return this.m_maxMotorTorque;\n      };\n      WheelJoint2.prototype.getMotorTorque = function(inv_dt) {\n        return inv_dt * this.m_motorImpulse;\n      };\n      WheelJoint2.prototype.setSpringFrequencyHz = function(hz) {\n        this.m_frequencyHz = hz;\n      };\n      WheelJoint2.prototype.getSpringFrequencyHz = function() {\n        return this.m_frequencyHz;\n      };\n      WheelJoint2.prototype.setSpringDampingRatio = function(ratio) {\n        this.m_dampingRatio = ratio;\n      };\n      WheelJoint2.prototype.getSpringDampingRatio = function() {\n        return this.m_dampingRatio;\n      };\n      WheelJoint2.prototype.getAnchorA = function() {\n        return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n      };\n      WheelJoint2.prototype.getAnchorB = function() {\n        return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n      };\n      WheelJoint2.prototype.getReactionForce = function(inv_dt) {\n        return Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax).mul(inv_dt);\n      };\n      WheelJoint2.prototype.getReactionTorque = function(inv_dt) {\n        return inv_dt * this.m_motorImpulse;\n      };\n      WheelJoint2.prototype.initVelocityConstraints = function(step) {\n        this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n        this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n        this.m_invMassA = this.m_bodyA.m_invMass;\n        this.m_invMassB = this.m_bodyB.m_invMass;\n        this.m_invIA = this.m_bodyA.m_invI;\n        this.m_invIB = this.m_bodyB.m_invI;\n        var mA = this.m_invMassA;\n        var mB = this.m_invMassB;\n        var iA = this.m_invIA;\n        var iB = this.m_invIB;\n        var cA2 = this.m_bodyA.c_position.c;\n        var aA = this.m_bodyA.c_position.a;\n        var vA2 = this.m_bodyA.c_velocity.v;\n        var wA = this.m_bodyA.c_velocity.w;\n        var cB2 = this.m_bodyB.c_position.c;\n        var aB = this.m_bodyB.c_position.a;\n        var vB2 = this.m_bodyB.c_velocity.v;\n        var wB = this.m_bodyB.c_velocity.w;\n        var qA = Rot.neo(aA);\n        var qB = Rot.neo(aB);\n        var rA2 = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n        var rB2 = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n        var d2 = Vec2.zero();\n        d2.addCombine(1, cB2, 1, rB2);\n        d2.subCombine(1, cA2, 1, rA2);\n        {\n          this.m_ay = Rot.mulVec2(qA, this.m_localYAxisA);\n          this.m_sAy = Vec2.crossVec2Vec2(Vec2.add(d2, rA2), this.m_ay);\n          this.m_sBy = Vec2.crossVec2Vec2(rB2, this.m_ay);\n          this.m_mass = mA + mB + iA * this.m_sAy * this.m_sAy + iB * this.m_sBy * this.m_sBy;\n          if (this.m_mass > 0) {\n            this.m_mass = 1 / this.m_mass;\n          }\n        }\n        this.m_springMass = 0;\n        this.m_bias = 0;\n        this.m_gamma = 0;\n        if (this.m_frequencyHz > 0) {\n          this.m_ax = Rot.mulVec2(qA, this.m_localXAxisA);\n          this.m_sAx = Vec2.crossVec2Vec2(Vec2.add(d2, rA2), this.m_ax);\n          this.m_sBx = Vec2.crossVec2Vec2(rB2, this.m_ax);\n          var invMass = mA + mB + iA * this.m_sAx * this.m_sAx + iB * this.m_sBx * this.m_sBx;\n          if (invMass > 0) {\n            this.m_springMass = 1 / invMass;\n            var C = Vec2.dot(d2, this.m_ax);\n            var omega = 2 * math_PI * this.m_frequencyHz;\n            var damp = 2 * this.m_springMass * this.m_dampingRatio * omega;\n            var k = this.m_springMass * omega * omega;\n            var h = step.dt;\n            this.m_gamma = h * (damp + h * k);\n            if (this.m_gamma > 0) {\n              this.m_gamma = 1 / this.m_gamma;\n            }\n            this.m_bias = C * h * k * this.m_gamma;\n            this.m_springMass = invMass + this.m_gamma;\n            if (this.m_springMass > 0) {\n              this.m_springMass = 1 / this.m_springMass;\n            }\n          }\n        } else {\n          this.m_springImpulse = 0;\n        }\n        if (this.m_enableMotor) {\n          this.m_motorMass = iA + iB;\n          if (this.m_motorMass > 0) {\n            this.m_motorMass = 1 / this.m_motorMass;\n          }\n        } else {\n          this.m_motorMass = 0;\n          this.m_motorImpulse = 0;\n        }\n        if (step.warmStarting) {\n          this.m_impulse *= step.dtRatio;\n          this.m_springImpulse *= step.dtRatio;\n          this.m_motorImpulse *= step.dtRatio;\n          var P3 = Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax);\n          var LA = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse;\n          var LB = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse;\n          vA2.subMul(this.m_invMassA, P3);\n          wA -= this.m_invIA * LA;\n          vB2.addMul(this.m_invMassB, P3);\n          wB += this.m_invIB * LB;\n        } else {\n          this.m_impulse = 0;\n          this.m_springImpulse = 0;\n          this.m_motorImpulse = 0;\n        }\n        this.m_bodyA.c_velocity.v.setVec2(vA2);\n        this.m_bodyA.c_velocity.w = wA;\n        this.m_bodyB.c_velocity.v.setVec2(vB2);\n        this.m_bodyB.c_velocity.w = wB;\n      };\n      WheelJoint2.prototype.solveVelocityConstraints = function(step) {\n        var mA = this.m_invMassA;\n        var mB = this.m_invMassB;\n        var iA = this.m_invIA;\n        var iB = this.m_invIB;\n        var vA2 = this.m_bodyA.c_velocity.v;\n        var wA = this.m_bodyA.c_velocity.w;\n        var vB2 = this.m_bodyB.c_velocity.v;\n        var wB = this.m_bodyB.c_velocity.w;\n        {\n          var Cdot = Vec2.dot(this.m_ax, vB2) - Vec2.dot(this.m_ax, vA2) + this.m_sBx * wB - this.m_sAx * wA;\n          var impulse = -this.m_springMass * (Cdot + this.m_bias + this.m_gamma * this.m_springImpulse);\n          this.m_springImpulse += impulse;\n          var P3 = Vec2.mulNumVec2(impulse, this.m_ax);\n          var LA = impulse * this.m_sAx;\n          var LB = impulse * this.m_sBx;\n          vA2.subMul(mA, P3);\n          wA -= iA * LA;\n          vB2.addMul(mB, P3);\n          wB += iB * LB;\n        }\n        {\n          var Cdot = wB - wA - this.m_motorSpeed;\n          var impulse = -this.m_motorMass * Cdot;\n          var oldImpulse = this.m_motorImpulse;\n          var maxImpulse = step.dt * this.m_maxMotorTorque;\n          this.m_motorImpulse = clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);\n          impulse = this.m_motorImpulse - oldImpulse;\n          wA -= iA * impulse;\n          wB += iB * impulse;\n        }\n        {\n          var Cdot = Vec2.dot(this.m_ay, vB2) - Vec2.dot(this.m_ay, vA2) + this.m_sBy * wB - this.m_sAy * wA;\n          var impulse = -this.m_mass * Cdot;\n          this.m_impulse += impulse;\n          var P3 = Vec2.mulNumVec2(impulse, this.m_ay);\n          var LA = impulse * this.m_sAy;\n          var LB = impulse * this.m_sBy;\n          vA2.subMul(mA, P3);\n          wA -= iA * LA;\n          vB2.addMul(mB, P3);\n          wB += iB * LB;\n        }\n        this.m_bodyA.c_velocity.v.setVec2(vA2);\n        this.m_bodyA.c_velocity.w = wA;\n        this.m_bodyB.c_velocity.v.setVec2(vB2);\n        this.m_bodyB.c_velocity.w = wB;\n      };\n      WheelJoint2.prototype.solvePositionConstraints = function(step) {\n        var cA2 = this.m_bodyA.c_position.c;\n        var aA = this.m_bodyA.c_position.a;\n        var cB2 = this.m_bodyB.c_position.c;\n        var aB = this.m_bodyB.c_position.a;\n        var qA = Rot.neo(aA);\n        var qB = Rot.neo(aB);\n        var rA2 = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n        var rB2 = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n        var d2 = Vec2.zero();\n        d2.addCombine(1, cB2, 1, rB2);\n        d2.subCombine(1, cA2, 1, rA2);\n        var ay = Rot.mulVec2(qA, this.m_localYAxisA);\n        var sAy = Vec2.crossVec2Vec2(Vec2.add(d2, rA2), ay);\n        var sBy = Vec2.crossVec2Vec2(rB2, ay);\n        var C = Vec2.dot(d2, ay);\n        var k = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy;\n        var impulse = k != 0 ? -C / k : 0;\n        var P3 = Vec2.mulNumVec2(impulse, ay);\n        var LA = impulse * sAy;\n        var LB = impulse * sBy;\n        cA2.subMul(this.m_invMassA, P3);\n        aA -= this.m_invIA * LA;\n        cB2.addMul(this.m_invMassB, P3);\n        aB += this.m_invIB * LB;\n        this.m_bodyA.c_position.c.setVec2(cA2);\n        this.m_bodyA.c_position.a = aA;\n        this.m_bodyB.c_position.c.setVec2(cB2);\n        this.m_bodyB.c_position.a = aB;\n        return math_abs(C) <= SettingsInternal.linearSlop;\n      };\n      WheelJoint2.TYPE = \"wheel-joint\";\n      return WheelJoint2;\n    }(Joint)\n  );\n  var _a;\n  var SID = 0;\n  var SERIALIZE_REF_TYPES = {\n    \"World\": World,\n    \"Body\": Body,\n    \"Joint\": Joint,\n    \"Fixture\": Fixture,\n    \"Shape\": Shape\n  };\n  var DESERIALIZE_BY_REF_TYPE = {\n    \"Vec2\": Vec2,\n    \"Vec3\": Vec3,\n    \"World\": World,\n    \"Body\": Body,\n    \"Joint\": Joint,\n    \"Fixture\": Fixture,\n    \"Shape\": Shape\n  };\n  var DESERIALIZE_BY_TYPE_FIELD = (_a = {}, _a[Body.STATIC] = Body, _a[Body.DYNAMIC] = Body, _a[Body.KINEMATIC] = Body, _a[ChainShape.TYPE] = ChainShape, // [BoxShape.TYPE]: BoxShape,\n  _a[PolygonShape.TYPE] = PolygonShape, _a[EdgeShape.TYPE] = EdgeShape, _a[CircleShape.TYPE] = CircleShape, _a[DistanceJoint.TYPE] = DistanceJoint, _a[FrictionJoint.TYPE] = FrictionJoint, _a[GearJoint.TYPE] = GearJoint, _a[MotorJoint.TYPE] = MotorJoint, _a[MouseJoint.TYPE] = MouseJoint, _a[PrismaticJoint.TYPE] = PrismaticJoint, _a[PulleyJoint.TYPE] = PulleyJoint, _a[RevoluteJoint.TYPE] = RevoluteJoint, _a[RopeJoint.TYPE] = RopeJoint, _a[WeldJoint.TYPE] = WeldJoint, _a[WheelJoint.TYPE] = WheelJoint, _a);\n  var DEFAULT_OPTIONS = {\n    rootClass: World,\n    preSerialize: function(obj) {\n      return obj;\n    },\n    postSerialize: function(data, obj) {\n      return data;\n    },\n    preDeserialize: function(data) {\n      return data;\n    },\n    postDeserialize: function(obj, data) {\n      return obj;\n    }\n  };\n  var Serializer = (\n    /** @class */\n    /* @__PURE__ */ function() {\n      function Serializer2(options2) {\n        var _this = this;\n        this.toJson = function(root) {\n          var preSerialize = _this.options.preSerialize;\n          var postSerialize = _this.options.postSerialize;\n          var json = [];\n          var refQueue = [root];\n          var refMemoById = {};\n          function addToRefQueue(value, typeName) {\n            value.__sid = value.__sid || ++SID;\n            if (!refMemoById[value.__sid]) {\n              refQueue.push(value);\n              var index = json.length + refQueue.length;\n              var ref = {\n                refIndex: index,\n                refType: typeName\n              };\n              refMemoById[value.__sid] = ref;\n            }\n            return refMemoById[value.__sid];\n          }\n          function serializeWithHooks(obj2) {\n            obj2 = preSerialize(obj2);\n            var data = obj2._serialize();\n            data = postSerialize(data, obj2);\n            return data;\n          }\n          function traverse(value, noRefType) {\n            if (noRefType === void 0) {\n              noRefType = false;\n            }\n            if (typeof value !== \"object\" || value === null) {\n              return value;\n            }\n            if (typeof value._serialize === \"function\") {\n              if (!noRefType) {\n                for (var typeName in SERIALIZE_REF_TYPES) {\n                  if (value instanceof SERIALIZE_REF_TYPES[typeName]) {\n                    return addToRefQueue(value, typeName);\n                  }\n                }\n              }\n              value = serializeWithHooks(value);\n            }\n            if (Array.isArray(value)) {\n              var newValue = [];\n              for (var key = 0; key < value.length; key++) {\n                newValue[key] = traverse(value[key]);\n              }\n              value = newValue;\n            } else {\n              var newValue = {};\n              for (var key in value) {\n                if (value.hasOwnProperty(key)) {\n                  newValue[key] = traverse(value[key]);\n                }\n              }\n              value = newValue;\n            }\n            return value;\n          }\n          while (refQueue.length) {\n            var obj = refQueue.shift();\n            var str = traverse(obj, true);\n            json.push(str);\n          }\n          return json;\n        };\n        this.fromJson = function(json) {\n          var preDeserialize = _this.options.preDeserialize;\n          var postDeserialize = _this.options.postDeserialize;\n          var rootClass = _this.options.rootClass;\n          var deserializedRefMemoByIndex = {};\n          function deserializeWithHooks(classHint, data, context) {\n            if (!classHint || !classHint._deserialize) {\n              classHint = DESERIALIZE_BY_TYPE_FIELD[data.type];\n            }\n            var deserializer = classHint && classHint._deserialize;\n            if (!deserializer) {\n              return;\n            }\n            data = preDeserialize(data);\n            var classDeserializeFn = classHint._deserialize;\n            var obj = classDeserializeFn(data, context, deserializeChild);\n            obj = postDeserialize(obj, data);\n            return obj;\n          }\n          function deserializeChild(classHint, dataOrRef, context) {\n            var isRefObject = dataOrRef.refIndex && dataOrRef.refType;\n            if (!isRefObject) {\n              return deserializeWithHooks(classHint, dataOrRef, context);\n            }\n            var ref = dataOrRef;\n            if (DESERIALIZE_BY_REF_TYPE[ref.refType]) {\n              classHint = DESERIALIZE_BY_REF_TYPE[ref.refType];\n            }\n            var refIndex = ref.refIndex;\n            if (!deserializedRefMemoByIndex[refIndex]) {\n              var data = json[refIndex];\n              var obj = deserializeWithHooks(classHint, data, context);\n              deserializedRefMemoByIndex[refIndex] = obj;\n            }\n            return deserializedRefMemoByIndex[refIndex];\n          }\n          var root = deserializeWithHooks(rootClass, json[0], null);\n          return root;\n        };\n        this.options = __assign(__assign({}, DEFAULT_OPTIONS), options2);\n      }\n      return Serializer2;\n    }()\n  );\n  var worldSerializer = new Serializer({\n    rootClass: World\n  });\n  Serializer.fromJson = worldSerializer.fromJson;\n  Serializer.toJson = worldSerializer.toJson;\n  var Testbed = (\n    /** @class */\n    function() {\n      function Testbed2() {\n        this.width = 80;\n        this.height = 60;\n        this.x = 0;\n        this.y = -10;\n        this.scaleY = -1;\n        this.hz = 60;\n        this.speed = 1;\n        this.background = \"#222222\";\n        this.activeKeys = {};\n        this.step = function(dt, t) {\n          return;\n        };\n        this.keydown = function(keyCode, label) {\n          return;\n        };\n        this.keyup = function(keyCode, label) {\n          return;\n        };\n      }\n      Testbed2.mount = function(options2) {\n        throw new Error(\"Not implemented\");\n      };\n      Testbed2.start = function(world) {\n        var testbed2 = Testbed2.mount();\n        testbed2.start(world);\n        return testbed2;\n      };\n      Testbed2.prototype.color = function(r, g, b2) {\n        r = r * 256 | 0;\n        g = g * 256 | 0;\n        b2 = b2 * 256 | 0;\n        return \"rgb(\" + r + \", \" + g + \", \" + b2 + \")\";\n      };\n      return Testbed2;\n    }()\n  );\n  function testbed(a2, b2) {\n    var callback;\n    var options2;\n    if (typeof a2 === \"function\") {\n      callback = a2;\n      options2 = b2;\n    } else if (typeof b2 === \"function\") {\n      callback = b2;\n      options2 = a2;\n    } else {\n      options2 = a2 !== null && a2 !== void 0 ? a2 : b2;\n    }\n    var testbed2 = Testbed.mount(options2);\n    if (callback) {\n      var world = callback(testbed2) || testbed2.world;\n      testbed2.start(world);\n    } else {\n      return testbed2;\n    }\n  }\n  var BoxShape = (\n    /** @class */\n    function(_super) {\n      __extends(BoxShape2, _super);\n      function BoxShape2(halfWidth, halfHeight, center2, angle) {\n        var _this = this;\n        if (!(_this instanceof BoxShape2)) {\n          return new BoxShape2(halfWidth, halfHeight, center2, angle);\n        }\n        _this = _super.call(this) || this;\n        _this._setAsBox(halfWidth, halfHeight, center2, angle);\n        return _this;\n      }\n      BoxShape2.TYPE = \"polygon\";\n      return BoxShape2;\n    }(PolygonShape)\n  );\n  var Box = BoxShape;\n  Contact.addType(CircleShape.TYPE, CircleShape.TYPE, CircleCircleContact);\n  function CircleCircleContact(manifold, xfA2, fixtureA, indexA, xfB2, fixtureB, indexB) {\n    CollideCircles(manifold, fixtureA.getShape(), xfA2, fixtureB.getShape(), xfB2);\n  }\n  var pA = vec2(0, 0);\n  var pB = vec2(0, 0);\n  var CollideCircles = function(manifold, circleA, xfA2, circleB, xfB2) {\n    manifold.pointCount = 0;\n    transformVec2(pA, xfA2, circleA.m_p);\n    transformVec2(pB, xfB2, circleB.m_p);\n    var distSqr = distSqrVec2(pB, pA);\n    var rA2 = circleA.m_radius;\n    var rB2 = circleB.m_radius;\n    var radius = rA2 + rB2;\n    if (distSqr > radius * radius) {\n      return;\n    }\n    manifold.type = exports2.ManifoldType.e_circles;\n    copyVec2(manifold.localPoint, circleA.m_p);\n    zeroVec2(manifold.localNormal);\n    manifold.pointCount = 1;\n    copyVec2(manifold.points[0].localPoint, circleB.m_p);\n    manifold.points[0].id.setFeatures(0, exports2.ContactFeatureType.e_vertex, 0, exports2.ContactFeatureType.e_vertex);\n  };\n  Contact.addType(EdgeShape.TYPE, CircleShape.TYPE, EdgeCircleContact);\n  Contact.addType(ChainShape.TYPE, CircleShape.TYPE, ChainCircleContact);\n  function EdgeCircleContact(manifold, xfA2, fixtureA, indexA, xfB2, fixtureB, indexB) {\n    var shapeA = fixtureA.getShape();\n    var shapeB = fixtureB.getShape();\n    CollideEdgeCircle(manifold, shapeA, xfA2, shapeB, xfB2);\n  }\n  function ChainCircleContact(manifold, xfA2, fixtureA, indexA, xfB2, fixtureB, indexB) {\n    var chain = fixtureA.getShape();\n    var edge = new EdgeShape();\n    chain.getChildEdge(edge, indexA);\n    var shapeA = edge;\n    var shapeB = fixtureB.getShape();\n    CollideEdgeCircle(manifold, shapeA, xfA2, shapeB, xfB2);\n  }\n  var e = vec2(0, 0);\n  var e1 = vec2(0, 0);\n  var e2 = vec2(0, 0);\n  var Q = vec2(0, 0);\n  var P = vec2(0, 0);\n  var n$2 = vec2(0, 0);\n  var CollideEdgeCircle = function(manifold, edgeA, xfA2, circleB, xfB2) {\n    manifold.pointCount = 0;\n    retransformVec2(Q, xfB2, xfA2, circleB.m_p);\n    var A = edgeA.m_vertex1;\n    var B = edgeA.m_vertex2;\n    subVec2(e, B, A);\n    var u = dotVec2(e, B) - dotVec2(e, Q);\n    var v3 = dotVec2(e, Q) - dotVec2(e, A);\n    var radius = edgeA.m_radius + circleB.m_radius;\n    if (v3 <= 0) {\n      copyVec2(P, A);\n      var dd_1 = distSqrVec2(Q, A);\n      if (dd_1 > radius * radius) {\n        return;\n      }\n      if (edgeA.m_hasVertex0) {\n        var A1 = edgeA.m_vertex0;\n        var B1 = A;\n        subVec2(e1, B1, A1);\n        var u1 = dotVec2(e1, B1) - dotVec2(e1, Q);\n        if (u1 > 0) {\n          return;\n        }\n      }\n      manifold.type = exports2.ManifoldType.e_circles;\n      zeroVec2(manifold.localNormal);\n      copyVec2(manifold.localPoint, P);\n      manifold.pointCount = 1;\n      copyVec2(manifold.points[0].localPoint, circleB.m_p);\n      manifold.points[0].id.setFeatures(0, exports2.ContactFeatureType.e_vertex, 0, exports2.ContactFeatureType.e_vertex);\n      return;\n    }\n    if (u <= 0) {\n      copyVec2(P, B);\n      var dd_2 = distSqrVec2(Q, P);\n      if (dd_2 > radius * radius) {\n        return;\n      }\n      if (edgeA.m_hasVertex3) {\n        var B2 = edgeA.m_vertex3;\n        var A2 = B;\n        subVec2(e2, B2, A2);\n        var v22 = dotVec2(e2, Q) - dotVec2(e2, A2);\n        if (v22 > 0) {\n          return;\n        }\n      }\n      manifold.type = exports2.ManifoldType.e_circles;\n      zeroVec2(manifold.localNormal);\n      copyVec2(manifold.localPoint, P);\n      manifold.pointCount = 1;\n      copyVec2(manifold.points[0].localPoint, circleB.m_p);\n      manifold.points[0].id.setFeatures(1, exports2.ContactFeatureType.e_vertex, 0, exports2.ContactFeatureType.e_vertex);\n      return;\n    }\n    var den = lengthSqrVec2(e);\n    combine2Vec2(P, u / den, A, v3 / den, B);\n    var dd = distSqrVec2(Q, P);\n    if (dd > radius * radius) {\n      return;\n    }\n    crossNumVec2(n$2, 1, e);\n    if (dotVec2(n$2, Q) - dotVec2(n$2, A) < 0) {\n      negVec2(n$2);\n    }\n    normalizeVec2(n$2);\n    manifold.type = exports2.ManifoldType.e_faceA;\n    copyVec2(manifold.localNormal, n$2);\n    copyVec2(manifold.localPoint, A);\n    manifold.pointCount = 1;\n    copyVec2(manifold.points[0].localPoint, circleB.m_p);\n    manifold.points[0].id.setFeatures(0, exports2.ContactFeatureType.e_face, 0, exports2.ContactFeatureType.e_vertex);\n  };\n  var incidentEdge = [new ClipVertex(), new ClipVertex()];\n  var clipPoints1$1 = [new ClipVertex(), new ClipVertex()];\n  var clipPoints2$1 = [new ClipVertex(), new ClipVertex()];\n  var clipSegmentToLineNormal = vec2(0, 0);\n  var v1 = vec2(0, 0);\n  var n$1 = vec2(0, 0);\n  var xf$1 = transform(0, 0, 0);\n  var v11 = vec2(0, 0);\n  var v12 = vec2(0, 0);\n  var localTangent = vec2(0, 0);\n  var localNormal = vec2(0, 0);\n  var planePoint = vec2(0, 0);\n  var tangent = vec2(0, 0);\n  var normal$1 = vec2(0, 0);\n  var normal1$1 = vec2(0, 0);\n  Contact.addType(PolygonShape.TYPE, PolygonShape.TYPE, PolygonContact);\n  function PolygonContact(manifold, xfA2, fixtureA, indexA, xfB2, fixtureB, indexB) {\n    CollidePolygons(manifold, fixtureA.getShape(), xfA2, fixtureB.getShape(), xfB2);\n  }\n  function findMaxSeparation(poly1, xf1, poly2, xf2, output2) {\n    var count1 = poly1.m_count;\n    var count2 = poly2.m_count;\n    var n1s = poly1.m_normals;\n    var v1s = poly1.m_vertices;\n    var v2s = poly2.m_vertices;\n    detransformTransform(xf$1, xf2, xf1);\n    var bestIndex = 0;\n    var maxSeparation2 = -Infinity;\n    for (var i = 0; i < count1; ++i) {\n      rotVec2(n$1, xf$1.q, n1s[i]);\n      transformVec2(v1, xf$1, v1s[i]);\n      var si = Infinity;\n      for (var j = 0; j < count2; ++j) {\n        var sij = dotVec2(n$1, v2s[j]) - dotVec2(n$1, v1);\n        if (sij < si) {\n          si = sij;\n        }\n      }\n      if (si > maxSeparation2) {\n        maxSeparation2 = si;\n        bestIndex = i;\n      }\n    }\n    output2.maxSeparation = maxSeparation2;\n    output2.bestIndex = bestIndex;\n  }\n  function findIncidentEdge(clipVertex, poly1, xf1, edge12, poly2, xf2) {\n    var normals1 = poly1.m_normals;\n    var count2 = poly2.m_count;\n    var vertices2 = poly2.m_vertices;\n    var normals2 = poly2.m_normals;\n    rerotVec2(normal1$1, xf2.q, xf1.q, normals1[edge12]);\n    var index = 0;\n    var minDot = Infinity;\n    for (var i = 0; i < count2; ++i) {\n      var dot = dotVec2(normal1$1, normals2[i]);\n      if (dot < minDot) {\n        minDot = dot;\n        index = i;\n      }\n    }\n    var i1 = index;\n    var i2 = i1 + 1 < count2 ? i1 + 1 : 0;\n    transformVec2(clipVertex[0].v, xf2, vertices2[i1]);\n    clipVertex[0].id.setFeatures(edge12, exports2.ContactFeatureType.e_face, i1, exports2.ContactFeatureType.e_vertex);\n    transformVec2(clipVertex[1].v, xf2, vertices2[i2]);\n    clipVertex[1].id.setFeatures(edge12, exports2.ContactFeatureType.e_face, i2, exports2.ContactFeatureType.e_vertex);\n  }\n  var maxSeparation = {\n    maxSeparation: 0,\n    bestIndex: 0\n  };\n  var CollidePolygons = function(manifold, polyA, xfA2, polyB, xfB2) {\n    manifold.pointCount = 0;\n    var totalRadius = polyA.m_radius + polyB.m_radius;\n    findMaxSeparation(polyA, xfA2, polyB, xfB2, maxSeparation);\n    var edgeA = maxSeparation.bestIndex;\n    var separationA = maxSeparation.maxSeparation;\n    if (separationA > totalRadius)\n      return;\n    findMaxSeparation(polyB, xfB2, polyA, xfA2, maxSeparation);\n    var edgeB = maxSeparation.bestIndex;\n    var separationB = maxSeparation.maxSeparation;\n    if (separationB > totalRadius)\n      return;\n    var poly1;\n    var poly2;\n    var xf1;\n    var xf2;\n    var edge12;\n    var flip;\n    var k_tol = 0.1 * SettingsInternal.linearSlop;\n    if (separationB > separationA + k_tol) {\n      poly1 = polyB;\n      poly2 = polyA;\n      xf1 = xfB2;\n      xf2 = xfA2;\n      edge12 = edgeB;\n      manifold.type = exports2.ManifoldType.e_faceB;\n      flip = true;\n    } else {\n      poly1 = polyA;\n      poly2 = polyB;\n      xf1 = xfA2;\n      xf2 = xfB2;\n      edge12 = edgeA;\n      manifold.type = exports2.ManifoldType.e_faceA;\n      flip = false;\n    }\n    incidentEdge[0].recycle();\n    incidentEdge[1].recycle();\n    findIncidentEdge(incidentEdge, poly1, xf1, edge12, poly2, xf2);\n    var count1 = poly1.m_count;\n    var vertices1 = poly1.m_vertices;\n    var iv1 = edge12;\n    var iv2 = edge12 + 1 < count1 ? edge12 + 1 : 0;\n    copyVec2(v11, vertices1[iv1]);\n    copyVec2(v12, vertices1[iv2]);\n    subVec2(localTangent, v12, v11);\n    normalizeVec2(localTangent);\n    crossVec2Num(localNormal, localTangent, 1);\n    combine2Vec2(planePoint, 0.5, v11, 0.5, v12);\n    rotVec2(tangent, xf1.q, localTangent);\n    crossVec2Num(normal$1, tangent, 1);\n    transformVec2(v11, xf1, v11);\n    transformVec2(v12, xf1, v12);\n    var frontOffset = dotVec2(normal$1, v11);\n    var sideOffset1 = -dotVec2(tangent, v11) + totalRadius;\n    var sideOffset2 = dotVec2(tangent, v12) + totalRadius;\n    clipPoints1$1[0].recycle();\n    clipPoints1$1[1].recycle();\n    clipPoints2$1[0].recycle();\n    clipPoints2$1[1].recycle();\n    setVec2(clipSegmentToLineNormal, -tangent.x, -tangent.y);\n    var np1 = clipSegmentToLine(clipPoints1$1, incidentEdge, clipSegmentToLineNormal, sideOffset1, iv1);\n    if (np1 < 2) {\n      return;\n    }\n    setVec2(clipSegmentToLineNormal, tangent.x, tangent.y);\n    var np2 = clipSegmentToLine(clipPoints2$1, clipPoints1$1, clipSegmentToLineNormal, sideOffset2, iv2);\n    if (np2 < 2) {\n      return;\n    }\n    copyVec2(manifold.localNormal, localNormal);\n    copyVec2(manifold.localPoint, planePoint);\n    var pointCount = 0;\n    for (var i = 0; i < clipPoints2$1.length; ++i) {\n      var separation = dotVec2(normal$1, clipPoints2$1[i].v) - frontOffset;\n      if (separation <= totalRadius) {\n        var cp = manifold.points[pointCount];\n        detransformVec2(cp.localPoint, xf2, clipPoints2$1[i].v);\n        cp.id.set(clipPoints2$1[i].id);\n        if (flip) {\n          cp.id.swapFeatures();\n        }\n        ++pointCount;\n      }\n    }\n    manifold.pointCount = pointCount;\n  };\n  Contact.addType(PolygonShape.TYPE, CircleShape.TYPE, PolygonCircleContact);\n  function PolygonCircleContact(manifold, xfA2, fixtureA, indexA, xfB2, fixtureB, indexB) {\n    CollidePolygonCircle(manifold, fixtureA.getShape(), xfA2, fixtureB.getShape(), xfB2);\n  }\n  var cLocal = vec2(0, 0);\n  var faceCenter = vec2(0, 0);\n  var CollidePolygonCircle = function(manifold, polygonA, xfA2, circleB, xfB2) {\n    manifold.pointCount = 0;\n    retransformVec2(cLocal, xfB2, xfA2, circleB.m_p);\n    var normalIndex = 0;\n    var separation = -Infinity;\n    var radius = polygonA.m_radius + circleB.m_radius;\n    var vertexCount = polygonA.m_count;\n    var vertices = polygonA.m_vertices;\n    var normals = polygonA.m_normals;\n    for (var i = 0; i < vertexCount; ++i) {\n      var s2 = dotVec2(normals[i], cLocal) - dotVec2(normals[i], vertices[i]);\n      if (s2 > radius) {\n        return;\n      }\n      if (s2 > separation) {\n        separation = s2;\n        normalIndex = i;\n      }\n    }\n    var vertIndex1 = normalIndex;\n    var vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;\n    var v13 = vertices[vertIndex1];\n    var v22 = vertices[vertIndex2];\n    if (separation < EPSILON) {\n      manifold.pointCount = 1;\n      manifold.type = exports2.ManifoldType.e_faceA;\n      copyVec2(manifold.localNormal, normals[normalIndex]);\n      combine2Vec2(manifold.localPoint, 0.5, v13, 0.5, v22);\n      copyVec2(manifold.points[0].localPoint, circleB.m_p);\n      manifold.points[0].id.setFeatures(0, exports2.ContactFeatureType.e_vertex, 0, exports2.ContactFeatureType.e_vertex);\n      return;\n    }\n    var u1 = dotVec2(cLocal, v22) - dotVec2(cLocal, v13) - dotVec2(v13, v22) + dotVec2(v13, v13);\n    var u2 = dotVec2(cLocal, v13) - dotVec2(cLocal, v22) - dotVec2(v22, v13) + dotVec2(v22, v22);\n    if (u1 <= 0) {\n      if (distSqrVec2(cLocal, v13) > radius * radius) {\n        return;\n      }\n      manifold.pointCount = 1;\n      manifold.type = exports2.ManifoldType.e_faceA;\n      subVec2(manifold.localNormal, cLocal, v13);\n      normalizeVec2(manifold.localNormal);\n      copyVec2(manifold.localPoint, v13);\n      copyVec2(manifold.points[0].localPoint, circleB.m_p);\n      manifold.points[0].id.setFeatures(0, exports2.ContactFeatureType.e_vertex, 0, exports2.ContactFeatureType.e_vertex);\n    } else if (u2 <= 0) {\n      if (distSqrVec2(cLocal, v22) > radius * radius) {\n        return;\n      }\n      manifold.pointCount = 1;\n      manifold.type = exports2.ManifoldType.e_faceA;\n      subVec2(manifold.localNormal, cLocal, v22);\n      normalizeVec2(manifold.localNormal);\n      copyVec2(manifold.localPoint, v22);\n      copyVec2(manifold.points[0].localPoint, circleB.m_p);\n      manifold.points[0].id.setFeatures(0, exports2.ContactFeatureType.e_vertex, 0, exports2.ContactFeatureType.e_vertex);\n    } else {\n      combine2Vec2(faceCenter, 0.5, v13, 0.5, v22);\n      var separation_1 = dotVec2(cLocal, normals[vertIndex1]) - dotVec2(faceCenter, normals[vertIndex1]);\n      if (separation_1 > radius) {\n        return;\n      }\n      manifold.pointCount = 1;\n      manifold.type = exports2.ManifoldType.e_faceA;\n      copyVec2(manifold.localNormal, normals[vertIndex1]);\n      copyVec2(manifold.localPoint, faceCenter);\n      copyVec2(manifold.points[0].localPoint, circleB.m_p);\n      manifold.points[0].id.setFeatures(0, exports2.ContactFeatureType.e_vertex, 0, exports2.ContactFeatureType.e_vertex);\n    }\n  };\n  var math_min = Math.min;\n  Contact.addType(EdgeShape.TYPE, PolygonShape.TYPE, EdgePolygonContact);\n  Contact.addType(ChainShape.TYPE, PolygonShape.TYPE, ChainPolygonContact);\n  function EdgePolygonContact(manifold, xfA2, fA, indexA, xfB2, fB, indexB) {\n    CollideEdgePolygon(manifold, fA.getShape(), xfA2, fB.getShape(), xfB2);\n  }\n  var edge_reuse = new EdgeShape();\n  function ChainPolygonContact(manifold, xfA2, fA, indexA, xfB2, fB, indexB) {\n    var chain = fA.getShape();\n    chain.getChildEdge(edge_reuse, indexA);\n    CollideEdgePolygon(manifold, edge_reuse, xfA2, fB.getShape(), xfB2);\n  }\n  var EPAxisType;\n  (function(EPAxisType2) {\n    EPAxisType2[EPAxisType2[\"e_unknown\"] = -1] = \"e_unknown\";\n    EPAxisType2[EPAxisType2[\"e_edgeA\"] = 1] = \"e_edgeA\";\n    EPAxisType2[EPAxisType2[\"e_edgeB\"] = 2] = \"e_edgeB\";\n  })(EPAxisType || (EPAxisType = {}));\n  var VertexType;\n  (function(VertexType2) {\n    VertexType2[VertexType2[\"e_isolated\"] = 0] = \"e_isolated\";\n    VertexType2[VertexType2[\"e_concave\"] = 1] = \"e_concave\";\n    VertexType2[VertexType2[\"e_convex\"] = 2] = \"e_convex\";\n  })(VertexType || (VertexType = {}));\n  var EPAxis = (\n    /** @class */\n    /* @__PURE__ */ function() {\n      function EPAxis2() {\n      }\n      return EPAxis2;\n    }()\n  );\n  var TempPolygon = (\n    /** @class */\n    /* @__PURE__ */ function() {\n      function TempPolygon2() {\n        this.vertices = [];\n        this.normals = [];\n        this.count = 0;\n        for (var i = 0; i < SettingsInternal.maxPolygonVertices; i++) {\n          this.vertices.push(vec2(0, 0));\n          this.normals.push(vec2(0, 0));\n        }\n      }\n      return TempPolygon2;\n    }()\n  );\n  var ReferenceFace = (\n    /** @class */\n    function() {\n      function ReferenceFace2() {\n        this.v1 = vec2(0, 0);\n        this.v2 = vec2(0, 0);\n        this.normal = vec2(0, 0);\n        this.sideNormal1 = vec2(0, 0);\n        this.sideNormal2 = vec2(0, 0);\n      }\n      ReferenceFace2.prototype.recycle = function() {\n        zeroVec2(this.v1);\n        zeroVec2(this.v2);\n        zeroVec2(this.normal);\n        zeroVec2(this.sideNormal1);\n        zeroVec2(this.sideNormal2);\n      };\n      return ReferenceFace2;\n    }()\n  );\n  var clipPoints1 = [new ClipVertex(), new ClipVertex()];\n  var clipPoints2 = [new ClipVertex(), new ClipVertex()];\n  var ie = [new ClipVertex(), new ClipVertex()];\n  var edgeAxis = new EPAxis();\n  var polygonAxis = new EPAxis();\n  var polygonBA = new TempPolygon();\n  var rf = new ReferenceFace();\n  var centroidB = vec2(0, 0);\n  var edge0 = vec2(0, 0);\n  var edge1 = vec2(0, 0);\n  var edge2 = vec2(0, 0);\n  var xf = transform(0, 0, 0);\n  var normal = vec2(0, 0);\n  var normal0 = vec2(0, 0);\n  var normal1 = vec2(0, 0);\n  var normal2 = vec2(0, 0);\n  var lowerLimit = vec2(0, 0);\n  var upperLimit = vec2(0, 0);\n  var perp = vec2(0, 0);\n  var n = vec2(0, 0);\n  var CollideEdgePolygon = function(manifold, edgeA, xfA2, polygonB, xfB2) {\n    detransformTransform(xf, xfA2, xfB2);\n    transformVec2(centroidB, xf, polygonB.m_centroid);\n    var v0 = edgeA.m_vertex0;\n    var v13 = edgeA.m_vertex1;\n    var v22 = edgeA.m_vertex2;\n    var v3 = edgeA.m_vertex3;\n    var hasVertex0 = edgeA.m_hasVertex0;\n    var hasVertex3 = edgeA.m_hasVertex3;\n    subVec2(edge1, v22, v13);\n    normalizeVec2(edge1);\n    setVec2(normal1, edge1.y, -edge1.x);\n    var offset1 = dotVec2(normal1, centroidB) - dotVec2(normal1, v13);\n    var offset0 = 0;\n    var offset2 = 0;\n    var convex1 = false;\n    var convex2 = false;\n    zeroVec2(normal0);\n    zeroVec2(normal2);\n    if (hasVertex0) {\n      subVec2(edge0, v13, v0);\n      normalizeVec2(edge0);\n      setVec2(normal0, edge0.y, -edge0.x);\n      convex1 = crossVec2Vec2(edge0, edge1) >= 0;\n      offset0 = Vec2.dot(normal0, centroidB) - Vec2.dot(normal0, v0);\n    }\n    if (hasVertex3) {\n      subVec2(edge2, v3, v22);\n      normalizeVec2(edge2);\n      setVec2(normal2, edge2.y, -edge2.x);\n      convex2 = Vec2.crossVec2Vec2(edge1, edge2) > 0;\n      offset2 = Vec2.dot(normal2, centroidB) - Vec2.dot(normal2, v22);\n    }\n    var front;\n    zeroVec2(normal);\n    zeroVec2(lowerLimit);\n    zeroVec2(upperLimit);\n    if (hasVertex0 && hasVertex3) {\n      if (convex1 && convex2) {\n        front = offset0 >= 0 || offset1 >= 0 || offset2 >= 0;\n        if (front) {\n          copyVec2(normal, normal1);\n          copyVec2(lowerLimit, normal0);\n          copyVec2(upperLimit, normal2);\n        } else {\n          scaleVec2(normal, -1, normal1);\n          scaleVec2(lowerLimit, -1, normal1);\n          scaleVec2(upperLimit, -1, normal1);\n        }\n      } else if (convex1) {\n        front = offset0 >= 0 || offset1 >= 0 && offset2 >= 0;\n        if (front) {\n          copyVec2(normal, normal1);\n          copyVec2(lowerLimit, normal0);\n          copyVec2(upperLimit, normal1);\n        } else {\n          scaleVec2(normal, -1, normal1);\n          scaleVec2(lowerLimit, -1, normal2);\n          scaleVec2(upperLimit, -1, normal1);\n        }\n      } else if (convex2) {\n        front = offset2 >= 0 || offset0 >= 0 && offset1 >= 0;\n        if (front) {\n          copyVec2(normal, normal1);\n          copyVec2(lowerLimit, normal1);\n          copyVec2(upperLimit, normal2);\n        } else {\n          scaleVec2(normal, -1, normal1);\n          scaleVec2(lowerLimit, -1, normal1);\n          scaleVec2(upperLimit, -1, normal0);\n        }\n      } else {\n        front = offset0 >= 0 && offset1 >= 0 && offset2 >= 0;\n        if (front) {\n          copyVec2(normal, normal1);\n          copyVec2(lowerLimit, normal1);\n          copyVec2(upperLimit, normal1);\n        } else {\n          scaleVec2(normal, -1, normal1);\n          scaleVec2(lowerLimit, -1, normal2);\n          scaleVec2(upperLimit, -1, normal0);\n        }\n      }\n    } else if (hasVertex0) {\n      if (convex1) {\n        front = offset0 >= 0 || offset1 >= 0;\n        if (front) {\n          copyVec2(normal, normal1);\n          copyVec2(lowerLimit, normal0);\n          scaleVec2(upperLimit, -1, normal1);\n        } else {\n          scaleVec2(normal, -1, normal1);\n          copyVec2(lowerLimit, normal1);\n          scaleVec2(upperLimit, -1, normal1);\n        }\n      } else {\n        front = offset0 >= 0 && offset1 >= 0;\n        if (front) {\n          copyVec2(normal, normal1);\n          copyVec2(lowerLimit, normal1);\n          scaleVec2(upperLimit, -1, normal1);\n        } else {\n          scaleVec2(normal, -1, normal1);\n          copyVec2(lowerLimit, normal1);\n          scaleVec2(upperLimit, -1, normal0);\n        }\n      }\n    } else if (hasVertex3) {\n      if (convex2) {\n        front = offset1 >= 0 || offset2 >= 0;\n        if (front) {\n          copyVec2(normal, normal1);\n          scaleVec2(lowerLimit, -1, normal1);\n          copyVec2(upperLimit, normal2);\n        } else {\n          scaleVec2(normal, -1, normal1);\n          scaleVec2(lowerLimit, -1, normal1);\n          copyVec2(upperLimit, normal1);\n        }\n      } else {\n        front = offset1 >= 0 && offset2 >= 0;\n        if (front) {\n          copyVec2(normal, normal1);\n          scaleVec2(lowerLimit, -1, normal1);\n          copyVec2(upperLimit, normal1);\n        } else {\n          scaleVec2(normal, -1, normal1);\n          scaleVec2(lowerLimit, -1, normal2);\n          copyVec2(upperLimit, normal1);\n        }\n      }\n    } else {\n      front = offset1 >= 0;\n      if (front) {\n        copyVec2(normal, normal1);\n        scaleVec2(lowerLimit, -1, normal1);\n        scaleVec2(upperLimit, -1, normal1);\n      } else {\n        scaleVec2(normal, -1, normal1);\n        copyVec2(lowerLimit, normal1);\n        copyVec2(upperLimit, normal1);\n      }\n    }\n    polygonBA.count = polygonB.m_count;\n    for (var i = 0; i < polygonB.m_count; ++i) {\n      transformVec2(polygonBA.vertices[i], xf, polygonB.m_vertices[i]);\n      rotVec2(polygonBA.normals[i], xf.q, polygonB.m_normals[i]);\n    }\n    var radius = polygonB.m_radius + edgeA.m_radius;\n    manifold.pointCount = 0;\n    {\n      edgeAxis.type = EPAxisType.e_edgeA;\n      edgeAxis.index = front ? 0 : 1;\n      edgeAxis.separation = Infinity;\n      for (var i = 0; i < polygonBA.count; ++i) {\n        var v4 = polygonBA.vertices[i];\n        var s2 = dotVec2(normal, v4) - dotVec2(normal, v13);\n        if (s2 < edgeAxis.separation) {\n          edgeAxis.separation = s2;\n        }\n      }\n    }\n    if (edgeAxis.type == EPAxisType.e_unknown) {\n      return;\n    }\n    if (edgeAxis.separation > radius) {\n      return;\n    }\n    {\n      polygonAxis.type = EPAxisType.e_unknown;\n      polygonAxis.index = -1;\n      polygonAxis.separation = -Infinity;\n      setVec2(perp, -normal.y, normal.x);\n      for (var i = 0; i < polygonBA.count; ++i) {\n        scaleVec2(n, -1, polygonBA.normals[i]);\n        var s1 = dotVec2(n, polygonBA.vertices[i]) - dotVec2(n, v13);\n        var s22 = dotVec2(n, polygonBA.vertices[i]) - dotVec2(n, v22);\n        var s2 = math_min(s1, s22);\n        if (s2 > radius) {\n          polygonAxis.type = EPAxisType.e_edgeB;\n          polygonAxis.index = i;\n          polygonAxis.separation = s2;\n          break;\n        }\n        if (dotVec2(n, perp) >= 0) {\n          if (dotVec2(n, normal) - dotVec2(upperLimit, normal) < -SettingsInternal.angularSlop) {\n            continue;\n          }\n        } else {\n          if (dotVec2(n, normal) - dotVec2(lowerLimit, normal) < -SettingsInternal.angularSlop) {\n            continue;\n          }\n        }\n        if (s2 > polygonAxis.separation) {\n          polygonAxis.type = EPAxisType.e_edgeB;\n          polygonAxis.index = i;\n          polygonAxis.separation = s2;\n        }\n      }\n    }\n    if (polygonAxis.type != EPAxisType.e_unknown && polygonAxis.separation > radius) {\n      return;\n    }\n    var k_relativeTol = 0.98;\n    var k_absoluteTol = 1e-3;\n    var primaryAxis;\n    if (polygonAxis.type == EPAxisType.e_unknown) {\n      primaryAxis = edgeAxis;\n    } else if (polygonAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol) {\n      primaryAxis = polygonAxis;\n    } else {\n      primaryAxis = edgeAxis;\n    }\n    ie[0].recycle();\n    ie[1].recycle();\n    if (primaryAxis.type == EPAxisType.e_edgeA) {\n      manifold.type = exports2.ManifoldType.e_faceA;\n      var bestIndex = 0;\n      var bestValue = dotVec2(normal, polygonBA.normals[0]);\n      for (var i = 1; i < polygonBA.count; ++i) {\n        var value = dotVec2(normal, polygonBA.normals[i]);\n        if (value < bestValue) {\n          bestValue = value;\n          bestIndex = i;\n        }\n      }\n      var i1 = bestIndex;\n      var i2 = i1 + 1 < polygonBA.count ? i1 + 1 : 0;\n      copyVec2(ie[0].v, polygonBA.vertices[i1]);\n      ie[0].id.setFeatures(0, exports2.ContactFeatureType.e_face, i1, exports2.ContactFeatureType.e_vertex);\n      copyVec2(ie[1].v, polygonBA.vertices[i2]);\n      ie[1].id.setFeatures(0, exports2.ContactFeatureType.e_face, i2, exports2.ContactFeatureType.e_vertex);\n      if (front) {\n        rf.i1 = 0;\n        rf.i2 = 1;\n        copyVec2(rf.v1, v13);\n        copyVec2(rf.v2, v22);\n        copyVec2(rf.normal, normal1);\n      } else {\n        rf.i1 = 1;\n        rf.i2 = 0;\n        copyVec2(rf.v1, v22);\n        copyVec2(rf.v2, v13);\n        scaleVec2(rf.normal, -1, normal1);\n      }\n    } else {\n      manifold.type = exports2.ManifoldType.e_faceB;\n      copyVec2(ie[0].v, v13);\n      ie[0].id.setFeatures(0, exports2.ContactFeatureType.e_vertex, primaryAxis.index, exports2.ContactFeatureType.e_face);\n      copyVec2(ie[1].v, v22);\n      ie[1].id.setFeatures(0, exports2.ContactFeatureType.e_vertex, primaryAxis.index, exports2.ContactFeatureType.e_face);\n      rf.i1 = primaryAxis.index;\n      rf.i2 = rf.i1 + 1 < polygonBA.count ? rf.i1 + 1 : 0;\n      copyVec2(rf.v1, polygonBA.vertices[rf.i1]);\n      copyVec2(rf.v2, polygonBA.vertices[rf.i2]);\n      copyVec2(rf.normal, polygonBA.normals[rf.i1]);\n    }\n    setVec2(rf.sideNormal1, rf.normal.y, -rf.normal.x);\n    setVec2(rf.sideNormal2, -rf.sideNormal1.x, -rf.sideNormal1.y);\n    rf.sideOffset1 = dotVec2(rf.sideNormal1, rf.v1);\n    rf.sideOffset2 = dotVec2(rf.sideNormal2, rf.v2);\n    clipPoints1[0].recycle();\n    clipPoints1[1].recycle();\n    clipPoints2[0].recycle();\n    clipPoints2[1].recycle();\n    var np1 = clipSegmentToLine(clipPoints1, ie, rf.sideNormal1, rf.sideOffset1, rf.i1);\n    if (np1 < SettingsInternal.maxManifoldPoints) {\n      return;\n    }\n    var np2 = clipSegmentToLine(clipPoints2, clipPoints1, rf.sideNormal2, rf.sideOffset2, rf.i2);\n    if (np2 < SettingsInternal.maxManifoldPoints) {\n      return;\n    }\n    if (primaryAxis.type == EPAxisType.e_edgeA) {\n      copyVec2(manifold.localNormal, rf.normal);\n      copyVec2(manifold.localPoint, rf.v1);\n    } else {\n      copyVec2(manifold.localNormal, polygonB.m_normals[rf.i1]);\n      copyVec2(manifold.localPoint, polygonB.m_vertices[rf.i1]);\n    }\n    var pointCount = 0;\n    for (var i = 0; i < SettingsInternal.maxManifoldPoints; ++i) {\n      var separation = dotVec2(rf.normal, clipPoints2[i].v) - dotVec2(rf.normal, rf.v1);\n      if (separation <= radius) {\n        var cp = manifold.points[pointCount];\n        if (primaryAxis.type == EPAxisType.e_edgeA) {\n          detransformVec2(cp.localPoint, xf, clipPoints2[i].v);\n          cp.id.set(clipPoints2[i].id);\n        } else {\n          copyVec2(cp.localPoint, clipPoints2[i].v);\n          cp.id.set(clipPoints2[i].id);\n          cp.id.swapFeatures();\n        }\n        ++pointCount;\n      }\n    }\n    manifold.pointCount = pointCount;\n  };\n  var internal = {\n    CollidePolygons,\n    Settings,\n    Sweep,\n    Manifold,\n    Distance,\n    TimeOfImpact,\n    DynamicTree,\n    stats\n  };\n  var DataDriver = (\n    /** @class */\n    function() {\n      function DataDriver2(key, listener) {\n        this._refMap = {};\n        this._map = {};\n        this._xmap = {};\n        this._data = [];\n        this._entered = [];\n        this._exited = [];\n        this._key = key;\n        this._listener = listener;\n      }\n      DataDriver2.prototype.update = function(data) {\n        if (!Array.isArray(data))\n          throw \"Invalid data: \" + data;\n        this._entered.length = 0;\n        this._exited.length = 0;\n        this._data.length = data.length;\n        for (var i = 0; i < data.length; i++) {\n          if (typeof data[i] !== \"object\" || data[i] === null)\n            continue;\n          var d2 = data[i];\n          var id = this._key(d2);\n          if (!this._map[id]) {\n            this._entered.push(d2);\n          } else {\n            delete this._map[id];\n          }\n          this._data[i] = d2;\n          this._xmap[id] = d2;\n        }\n        for (var id in this._map) {\n          this._exited.push(this._map[id]);\n          delete this._map[id];\n        }\n        var temp3 = this._map;\n        this._map = this._xmap;\n        this._xmap = temp3;\n        for (var i = 0; i < this._exited.length; i++) {\n          var d2 = this._exited[i];\n          var key = this._key(d2);\n          var ref = this._refMap[key];\n          this._listener.exit(d2, ref);\n          delete this._refMap[key];\n        }\n        for (var i = 0; i < this._entered.length; i++) {\n          var d2 = this._entered[i];\n          var key = this._key(d2);\n          var ref = this._listener.enter(d2);\n          if (ref) {\n            this._refMap[key] = ref;\n          }\n        }\n        for (var i = 0; i < this._data.length; i++) {\n          if (typeof data[i] !== \"object\" || data[i] === null)\n            continue;\n          var d2 = this._data[i];\n          var key = this._key(d2);\n          var ref = this._refMap[key];\n          this._listener.update(d2, ref);\n        }\n        this._entered.length = 0;\n        this._exited.length = 0;\n        this._data.length = 0;\n      };\n      DataDriver2.prototype.ref = function(d2) {\n        return this._refMap[this._key(d2)];\n      };\n      return DataDriver2;\n    }()\n  );\n  const planck = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n    __proto__: null,\n    AABB,\n    Body,\n    Box,\n    BoxShape,\n    BroadPhase,\n    Chain,\n    ChainShape,\n    Circle,\n    CircleShape,\n    ClipVertex,\n    CollideCircles,\n    CollideEdgeCircle,\n    CollideEdgePolygon,\n    CollidePolygonCircle,\n    CollidePolygons,\n    Contact,\n    ContactEdge,\n    get ContactFeatureType() {\n      return exports2.ContactFeatureType;\n    },\n    ContactID,\n    ContactImpulse,\n    DataDriver,\n    Distance,\n    DistanceInput,\n    DistanceJoint,\n    DistanceOutput,\n    DistanceProxy,\n    DynamicTree,\n    Edge,\n    EdgeShape,\n    Fixture,\n    FixtureProxy,\n    FrictionJoint,\n    GearJoint,\n    Joint,\n    JointEdge,\n    Manifold,\n    ManifoldPoint,\n    get ManifoldType() {\n      return exports2.ManifoldType;\n    },\n    Mat22,\n    Mat33,\n    Math: math,\n    MotorJoint,\n    MouseJoint,\n    get PointState() {\n      return exports2.PointState;\n    },\n    Polygon,\n    PolygonShape,\n    PrismaticJoint,\n    PulleyJoint,\n    RevoluteJoint,\n    RopeJoint,\n    Rot,\n    Serializer,\n    Settings,\n    SettingsInternal,\n    Shape,\n    ShapeCast,\n    ShapeCastInput,\n    ShapeCastOutput,\n    SimplexCache,\n    Solver,\n    Sweep,\n    TOIInput,\n    TOIOutput,\n    get TOIOutputState() {\n      return exports2.TOIOutputState;\n    },\n    Testbed,\n    TimeOfImpact,\n    TimeStep,\n    Transform,\n    TreeNode,\n    Vec2,\n    Vec3,\n    VelocityConstraintPoint,\n    WeldJoint,\n    WheelJoint,\n    World,\n    WorldManifold,\n    clipSegmentToLine,\n    getPointStates,\n    internal,\n    mixFriction,\n    mixRestitution,\n    stats,\n    testOverlap,\n    testbed\n  }, Symbol.toStringTag, { value: \"Module\" }));\n  exports2.AABB = AABB;\n  exports2.Body = Body;\n  exports2.Box = Box;\n  exports2.BoxShape = BoxShape;\n  exports2.BroadPhase = BroadPhase;\n  exports2.Chain = Chain;\n  exports2.ChainShape = ChainShape;\n  exports2.Circle = Circle;\n  exports2.CircleShape = CircleShape;\n  exports2.ClipVertex = ClipVertex;\n  exports2.CollideCircles = CollideCircles;\n  exports2.CollideEdgeCircle = CollideEdgeCircle;\n  exports2.CollideEdgePolygon = CollideEdgePolygon;\n  exports2.CollidePolygonCircle = CollidePolygonCircle;\n  exports2.CollidePolygons = CollidePolygons;\n  exports2.Contact = Contact;\n  exports2.ContactEdge = ContactEdge;\n  exports2.ContactID = ContactID;\n  exports2.ContactImpulse = ContactImpulse;\n  exports2.DataDriver = DataDriver;\n  exports2.Distance = Distance;\n  exports2.DistanceInput = DistanceInput;\n  exports2.DistanceJoint = DistanceJoint;\n  exports2.DistanceOutput = DistanceOutput;\n  exports2.DistanceProxy = DistanceProxy;\n  exports2.DynamicTree = DynamicTree;\n  exports2.Edge = Edge;\n  exports2.EdgeShape = EdgeShape;\n  exports2.Fixture = Fixture;\n  exports2.FixtureProxy = FixtureProxy;\n  exports2.FrictionJoint = FrictionJoint;\n  exports2.GearJoint = GearJoint;\n  exports2.Joint = Joint;\n  exports2.JointEdge = JointEdge;\n  exports2.Manifold = Manifold;\n  exports2.ManifoldPoint = ManifoldPoint;\n  exports2.Mat22 = Mat22;\n  exports2.Mat33 = Mat33;\n  exports2.Math = math;\n  exports2.MotorJoint = MotorJoint;\n  exports2.MouseJoint = MouseJoint;\n  exports2.Polygon = Polygon;\n  exports2.PolygonShape = PolygonShape;\n  exports2.PrismaticJoint = PrismaticJoint;\n  exports2.PulleyJoint = PulleyJoint;\n  exports2.RevoluteJoint = RevoluteJoint;\n  exports2.RopeJoint = RopeJoint;\n  exports2.Rot = Rot;\n  exports2.Serializer = Serializer;\n  exports2.Settings = Settings;\n  exports2.SettingsInternal = SettingsInternal;\n  exports2.Shape = Shape;\n  exports2.ShapeCast = ShapeCast;\n  exports2.ShapeCastInput = ShapeCastInput;\n  exports2.ShapeCastOutput = ShapeCastOutput;\n  exports2.SimplexCache = SimplexCache;\n  exports2.Solver = Solver;\n  exports2.Sweep = Sweep;\n  exports2.TOIInput = TOIInput;\n  exports2.TOIOutput = TOIOutput;\n  exports2.Testbed = Testbed;\n  exports2.TimeOfImpact = TimeOfImpact;\n  exports2.TimeStep = TimeStep;\n  exports2.Transform = Transform;\n  exports2.TreeNode = TreeNode;\n  exports2.Vec2 = Vec2;\n  exports2.Vec3 = Vec3;\n  exports2.VelocityConstraintPoint = VelocityConstraintPoint;\n  exports2.WeldJoint = WeldJoint;\n  exports2.WheelJoint = WheelJoint;\n  exports2.World = World;\n  exports2.WorldManifold = WorldManifold;\n  exports2.clipSegmentToLine = clipSegmentToLine;\n  exports2.default = planck;\n  exports2.getPointStates = getPointStates;\n  exports2.internal = internal;\n  exports2.mixFriction = mixFriction;\n  exports2.mixRestitution = mixRestitution;\n  exports2.stats = stats;\n  exports2.testOverlap = testOverlap;\n  exports2.testbed = testbed;\n  Object.defineProperties(exports2, { __esModule: { value: true }, [Symbol.toStringTag]: { value: \"Module\" } });\n});\n//# sourceMappingURL=planck.js.map\n\n\n//# sourceURL=webpack://2d-car-test/./node_modules/planck/dist/planck.js?");

/***/ }),

/***/ "./src/common/animation/animationFrameRequester.ts":
/*!*********************************************************!*\
  !*** ./src/common/animation/animationFrameRequester.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AnimationFrameRequester = void 0;\nclass AnimationFrameRequester {\n    constructor() { }\n    request(callback) {\n        this.cancel();\n        this.handle = window.requestAnimationFrame(time => {\n            this.handle = undefined;\n            callback(time);\n        });\n    }\n    cancel() {\n        if (this.handle != null) {\n            window.cancelAnimationFrame(this.handle);\n            this.handle = undefined;\n        }\n    }\n}\nexports.AnimationFrameRequester = AnimationFrameRequester;\n\n\n//# sourceURL=webpack://2d-car-test/./src/common/animation/animationFrameRequester.ts?");

/***/ }),

/***/ "./src/common/animation/ticker.ts":
/*!****************************************!*\
  !*** ./src/common/animation/ticker.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Ticker = void 0;\nconst animationFrameRequester_1 = __webpack_require__(/*! ./animationFrameRequester */ \"./src/common/animation/animationFrameRequester.ts\");\nclass Ticker {\n    constructor(onFrame) {\n        this.onFrame = onFrame;\n        this.req = new animationFrameRequester_1.AnimationFrameRequester();\n    }\n    start() {\n        this.stop();\n        let lastTimeMS = undefined;\n        const frame = (timeMS) => {\n            if (lastTimeMS != null) {\n                let deltaSec = (timeMS - lastTimeMS) / 1000;\n                this.onFrame(deltaSec);\n            }\n            lastTimeMS = timeMS;\n            this.req.request(frame);\n        };\n        this.req.request(frame);\n    }\n    stop() {\n        this.req.cancel();\n    }\n}\nexports.Ticker = Ticker;\n\n\n//# sourceURL=webpack://2d-car-test/./src/common/animation/ticker.ts?");

/***/ }),

/***/ "./src/common/car/car.ts":
/*!*******************************!*\
  !*** ./src/common/car/car.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Car = void 0;\nconst planck_1 = __webpack_require__(/*! planck */ \"./node_modules/planck/dist/planck.js\");\nconst tire_1 = __webpack_require__(/*! ./tire */ \"./src/common/car/tire.ts\");\nconst mathUtils_1 = __webpack_require__(/*! ../utils/mathUtils */ \"./src/common/utils/mathUtils.ts\");\nconst env_1 = __webpack_require__(/*! ../env */ \"./src/common/env.ts\");\nclass Car {\n    constructor(world, controlState) {\n        this.controlState = controlState;\n        this.tires = [];\n        this.checkPointHistory = [];\n        this.lapTimes = [];\n        this.body = world.createDynamicBody({\n            position: new planck_1.Vec2(0, 0),\n            linearDamping: 0,\n            angularDamping: 0, // \n        });\n        const maxForwardSpeed = 10;\n        const maxBackwardSpeed = -0.5;\n        const frontTireForwardDriveForce = 0.00;\n        const frontTireBackwardDriveForce = 0.00;\n        //const frontTireMaxLateralImpulse = 40.5 * 300; // \n        const backTireForwardDriveForce = 0.02;\n        const backTireBackwardDriveForce = 0.01;\n        //const backTireMaxLateralImpulse = 40 * 300;\n        const r = 2;\n        const shape = new planck_1.PolygonShape([\n            new planck_1.Vec2(-4.5, -8 + 0.5), // \n            new planck_1.Vec2(-4.5, 16 - 8 - r - 0.5),\n            new planck_1.Vec2(-4.5 + r, 16 - 8 - 0.5),\n            new planck_1.Vec2(+4.5 - r, 16 - 8 - 0.5),\n            new planck_1.Vec2(+4.5, 16 - r - 8 - 0.5),\n            new planck_1.Vec2(+4.5, -8 + 0.5),\n        ].map(s => s.mul(env_1.pixelToSim)));\n        this.body.createFixture({\n            shape: shape,\n            //  \n            density: 1.5,\n            // \n            friction: 0.0,\n            restitution: 0.8,\n            filterCategoryBits: 1 /* FilterCategory.Car */,\n            filterMaskBits: 2 /* FilterCategory.Wall */ | 4 /* FilterCategory.Sensor */,\n            userData: this,\n        });\n        const appendTire = (x, y, forwardDriveForce, backwardDriveForce /*, maxLateralImpulse: number*/) => {\n            const tire = new tire_1.Tire(world, maxForwardSpeed, maxBackwardSpeed, forwardDriveForce, backwardDriveForce /*, maxLateralImpulse*/); // dummy state\n            this.tires.push(tire);\n            tire.body.setUserData(this);\n            const def = new planck_1.RevoluteJoint({\n                bodyA: this.body,\n                enableLimit: true,\n                lowerAngle: 0,\n                upperAngle: 0,\n                bodyB: tire.body,\n                localAnchorA: new planck_1.Vec2(x, y).mul(env_1.pixelToSim),\n                localAnchorB: new planck_1.Vec2(0, 0),\n            });\n            const joint = world.createJoint(def);\n            tire.joint = joint;\n            return joint;\n        };\n        this.flJoint = appendTire(-5.5, 11.5 + 1 - 8, frontTireForwardDriveForce, frontTireBackwardDriveForce);\n        this.frJoint = appendTire(+5.5, 11.5 + 1 - 8, frontTireForwardDriveForce, frontTireBackwardDriveForce);\n        appendTire(-5.5, 4.5 - 1 - 8, backTireForwardDriveForce, backTireBackwardDriveForce);\n        appendTire(+5.5, 4.5 - 1 - 8, backTireForwardDriveForce, backTireBackwardDriveForce);\n    }\n    get startSec() { return this._startSec; }\n    get lastLapTime() {\n        if (this.lapTimes.length == 0) {\n            return undefined;\n        }\n        return this.lapTimes[this.lapTimes.length - 1];\n    }\n    get bestLapTime() { return this._bestLapTime; }\n    get getTireAngle() { return this.flJoint.getLowerLimit(); }\n    update() {\n        this.tires.forEach(t => t.updateFriction());\n        this.tires.forEach(t => t.updateDrive(this.controlState));\n        // \n        // \n        //control steering\n        const lockAngle = 45 * mathUtils_1.degToRad;\n        const desiredAngle = -this.controlState.steeringRatio * lockAngle;\n        this.flJoint.setLimits(desiredAngle, desiredAngle);\n        this.frJoint.setLimits(desiredAngle, desiredAngle);\n    }\n    rayCast(maxDis, rotationOffsetRad) {\n        const unit = this.body.getWorldVector((0, mathUtils_1.rotateVec2)(new planck_1.Vec2(0, 1), rotationOffsetRad));\n        const rayStart = this.body.getPosition();\n        const rayEnd = planck_1.Vec2.add(rayStart, planck_1.Vec2.mul(unit, maxDis));\n        let result = undefined;\n        this.body.getWorld().rayCast(rayStart, rayEnd, (fixture, point, normal, fraction) => {\n            if ((fixture.getFilterCategoryBits() & 2 /* FilterCategory.Wall */) == 0) {\n                return 1;\n            }\n            result = fraction * maxDis;\n            return 0;\n        });\n        return result;\n    }\n    /**  */\n    reset(pos, angleRad) {\n        this.body.setTransform(pos, angleRad);\n        this.body.setLinearVelocity(planck_1.Vec2.zero());\n        this.body.setAngularVelocity(0);\n        this.tires.forEach(t => {\n            const joint = t.joint;\n            const localAnchorA = joint.getLocalAnchorA();\n            const tirePos = (0, mathUtils_1.rotateVec2)(localAnchorA, angleRad).add(pos);\n            t.body.setTransform(tirePos, angleRad);\n            t.body.setLinearVelocity(planck_1.Vec2.zero());\n            t.body.setAngularVelocity(0);\n        });\n    }\n    onCheckPoint(idx, totalSec, checkPointCount) {\n        if (idx == 0) {\n            if (this.checkPointHistory.length == checkPointCount && this._startSec != null) {\n                if (this.checkPointHistory.every((i, idx) => i == idx)) {\n                    const lapTime = totalSec - this._startSec;\n                    if (this._bestLapTime == null || this._bestLapTime > lapTime) {\n                        this._bestLapTime = lapTime;\n                    }\n                    this.lapTimes.push(lapTime);\n                }\n            }\n            this.checkPointHistory = [0];\n            this._startSec = totalSec;\n        }\n        else {\n            if (this.checkPointHistory[this.checkPointHistory.length - 1] == idx) {\n                this.checkPointHistory.pop();\n            }\n            else {\n                this.checkPointHistory.push(idx);\n            }\n        }\n    }\n}\nexports.Car = Car;\n\n\n//# sourceURL=webpack://2d-car-test/./src/common/car/car.ts?");

/***/ }),

/***/ "./src/common/car/carView.ts":
/*!***********************************!*\
  !*** ./src/common/car/carView.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CarView = void 0;\nconst component_1 = __webpack_require__(/*! ../components/component */ \"./src/common/components/component.ts\");\nconst env_1 = __webpack_require__(/*! ../env */ \"./src/common/env.ts\");\nconst vec2_1 = __webpack_require__(/*! ../geometries/vec2 */ \"./src/common/geometries/vec2.ts\");\nconst spriteSheet_1 = __webpack_require__(/*! ../spriteSheet */ \"./src/common/spriteSheet.ts\");\nconst mathUtils_1 = __webpack_require__(/*! ../utils/mathUtils */ \"./src/common/utils/mathUtils.ts\");\nclass TireView extends component_1.Component {\n    constructor(offset) {\n        super();\n        this.offset = offset;\n        this.element = $(`<div class=\"tire\">`);\n    }\n}\nclass CarView extends component_1.Component {\n    constructor() {\n        super();\n        this.element = $(`<div class=\"car\">`);\n        const initTire = (x, y) => {\n            const tire = new TireView(new vec2_1.Vec2(x, y));\n            this.element.append(tire.element.css({\n                left: x,\n                top: y,\n            }));\n            return tire;\n        };\n        this.flTire = initTire(0, 3);\n        this.frTire = initTire(11, 3);\n        this.rlTire = initTire(0, 10);\n        this.rrTire = initTire(11, 10);\n        this.element.append($(spriteSheet_1.spriteSheet.crop(spriteSheet_1.spriteInfos.car).canvas).addClass(\"body\"));\n    }\n    update(car, courseMatrix) {\n        // \n        const mat = new DOMMatrix();\n        mat.multiplySelf(courseMatrix);\n        const pos = car.body.getPosition();\n        mat.translateSelf(pos.x, pos.y);\n        mat.scaleSelf(env_1.pixelToSim, env_1.pixelToSim, 1);\n        mat.rotateSelf(0, 0, car.body.getAngle() * mathUtils_1.radToDeg);\n        mat.scaleSelf(1, -1, 1); // \n        mat.translateSelf(-13 / 2, -16 / 2, 0);\n        this.element[0].style.transform = mat.toString();\n        // \n        const angle = car.getTireAngle * mathUtils_1.radToDeg;\n        this.flTire.element[0].style.transform = this.frTire.element[0].style.transform = `rotate(${-angle}deg)`;\n    }\n}\nexports.CarView = CarView;\n\n\n//# sourceURL=webpack://2d-car-test/./src/common/car/carView.ts?");

/***/ }),

/***/ "./src/common/car/controlState.ts":
/*!****************************************!*\
  !*** ./src/common/car/controlState.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ControlState = void 0;\nclass ControlState {\n    constructor() {\n        this.accel = false;\n        this.back = false;\n        this.brake = false;\n        this.steeringRatio = 0;\n    }\n}\nexports.ControlState = ControlState;\n\n\n//# sourceURL=webpack://2d-car-test/./src/common/car/controlState.ts?");

/***/ }),

/***/ "./src/common/car/tire.ts":
/*!********************************!*\
  !*** ./src/common/car/tire.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Tire = void 0;\nconst planck_1 = __webpack_require__(/*! planck */ \"./node_modules/planck/dist/planck.js\");\nconst env_1 = __webpack_require__(/*! ../env */ \"./src/common/env.ts\");\n/**\n * \n * https://www.iforce2d.net/b2dtut/top-down-car\n * \n */\nclass Tire {\n    /**\n     *\n     * @param world\n     * @param driveForce \n     * @param maxLateralImpulse \n     */\n    constructor(world, maxForwardSpeed, maxBackwardSpeed, forwardDriveForce, backwardDriveForce) {\n        this.maxForwardSpeed = maxForwardSpeed;\n        this.maxBackwardSpeed = maxBackwardSpeed;\n        this.forwardDriveForce = forwardDriveForce;\n        this.backwardDriveForce = backwardDriveForce;\n        this.body = world.createDynamicBody({\n            position: new planck_1.Vec2(0, 0),\n            //angle: Math.PI / 5,\n            linearDamping: 3,\n            angularDamping: 0,\n        });\n        this.body.createFixture({\n            // \n            shape: new planck_1.Box(2 / 2 * env_1.pixelToSim, 3 / 2 * env_1.pixelToSim),\n            //  \n            density: 1.0,\n            // \n            friction: 0.0,\n            // \n            restitution: 0.8,\n            filterCategoryBits: 1 /* FilterCategory.Car */,\n            filterMaskBits: 2 /* FilterCategory.Wall */ | 4 /* FilterCategory.Sensor */,\n        });\n    }\n    /**  */\n    get lateralVelocity() {\n        const currentRightNormal = this.body.getWorldVector(new planck_1.Vec2(1, 0));\n        const velocity = planck_1.Vec2.dot(currentRightNormal, this.body.getLinearVelocity());\n        return planck_1.Vec2.mul(velocity, currentRightNormal);\n    }\n    /**  */\n    get forwardVelocity() {\n        const currentForwardNormal = this.body.getWorldVector(new planck_1.Vec2(0, 1));\n        const velocity = planck_1.Vec2.dot(currentForwardNormal, this.body.getLinearVelocity());\n        return planck_1.Vec2.mul(velocity, currentForwardNormal);\n    }\n    /**  */\n    updateFriction() {\n        {\n            const velocity = this.body.getLinearVelocity();\n            const speed = velocity.length();\n            const direction = planck_1.Vec2.normalize(velocity); // \n            const forward = this.body.getWorldVector(new planck_1.Vec2(0, 1)); // \n            //  forward speed \n            const correctedSpeed = planck_1.Vec2.dot(forward, direction) < 0 ? -speed : speed;\n            // \n            this.body.setLinearVelocity(forward.mul(correctedSpeed));\n        }\n        // \n        //let impulse = this.lateralVelocity.neg().mul(this.body.getMass());\n        // \n        //if (impulse.length() > this.maxLateralImpulse) {\n        //impulse = Vec2.mul(this.maxLateralImpulse / impulse.length(), impulse); // maxLateralImpulse\n        //}\n        //this.body.applyLinearImpulse(impulse, this.body.getWorldCenter());\n        // \n        //this.body.applyAngularImpulse(1 * this.body.getInertia() * -this.body.getAngularVelocity());\n        // \n        /*const currentForwardNormal = this.forwardVelocity;\n        const currentForwardSpeed = currentForwardNormal.normalize();\n        const dragForceMagnitude = -0.02 * currentForwardSpeed;\n        this.body.applyForce(Vec2.mul(currentForwardNormal, dragForceMagnitude), this.body.getWorldCenter());*/\n    }\n    /**  */\n    updateDrive(controlState) {\n        // \n        if (controlState.brake) {\n            const currentForwardNormal = this.forwardVelocity;\n            const currentForwardSpeed = currentForwardNormal.normalize();\n            const dragForceMagnitude = -0.015 * currentForwardSpeed;\n            this.body.applyForce(planck_1.Vec2.mul(currentForwardNormal, dragForceMagnitude), this.body.getWorldCenter());\n        }\n        //find desired speed\n        let desiredSpeed = 0;\n        if (controlState.accel) {\n            desiredSpeed = this.maxForwardSpeed;\n        }\n        else if (controlState.back) {\n            desiredSpeed = this.maxBackwardSpeed;\n        }\n        //find current speed in forward direction\n        const currentForwardNormal = this.body.getWorldVector(new planck_1.Vec2(0, 1));\n        const currentSpeed = planck_1.Vec2.dot(this.forwardVelocity, currentForwardNormal);\n        //apply necessary force\n        let force = 0;\n        if (desiredSpeed > currentSpeed) {\n            force = this.forwardDriveForce;\n        }\n        else if (desiredSpeed < 0 && desiredSpeed < currentSpeed) {\n            force = -this.backwardDriveForce;\n        }\n        else {\n            return;\n        }\n        this.body.applyForce(planck_1.Vec2.mul(force, currentForwardNormal), this.body.getWorldCenter());\n    }\n}\nexports.Tire = Tire;\n\n\n//# sourceURL=webpack://2d-car-test/./src/common/car/tire.ts?");

/***/ }),

/***/ "./src/common/components/component.ts":
/*!********************************************!*\
  !*** ./src/common/components/component.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Component = void 0;\nclass Component {\n    constructor() {\n        this.element = $();\n    }\n}\nexports.Component = Component;\n\n\n//# sourceURL=webpack://2d-car-test/./src/common/components/component.ts?");

/***/ }),

/***/ "./src/common/courses/checkPoint.ts":
/*!******************************************!*\
  !*** ./src/common/courses/checkPoint.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CheckPoint = void 0;\nconst planck_1 = __webpack_require__(/*! planck */ \"./node_modules/planck/dist/planck.js\");\nclass CheckPoint {\n    constructor(world, checkPoint, index) {\n        this.index = index;\n        const body = world.createBody({});\n        body.createFixture({\n            shape: new planck_1.Edge(checkPoint[0], checkPoint[1]),\n            isSensor: true,\n            filterCategoryBits: 4 /* FilterCategory.Sensor */,\n            userData: this,\n        });\n    }\n}\nexports.CheckPoint = CheckPoint;\n\n\n//# sourceURL=webpack://2d-car-test/./src/common/courses/checkPoint.ts?");

/***/ }),

/***/ "./src/common/courses/course.ts":
/*!**************************************!*\
  !*** ./src/common/courses/course.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TestCourse = exports.Course = void 0;\nconst planck_1 = __webpack_require__(/*! planck */ \"./node_modules/planck/dist/planck.js\");\nconst env_1 = __webpack_require__(/*! ../env */ \"./src/common/env.ts\");\nconst checkPoint_1 = __webpack_require__(/*! ./checkPoint */ \"./src/common/courses/checkPoint.ts\");\nclass Course {\n    constructor(world, info) {\n        this.info = info;\n        info.outerWalls.forEach(chainPath => {\n            // Y\n            const chain = new planck_1.Chain(chainPath.map(p => this.convertPosXY(p[0], p[1])));\n            const boundaryChain = world.createBody();\n            boundaryChain.createFixture(chain, {\n                friction: 1.0,\n                filterCategoryBits: 2 /* FilterCategory.Wall */,\n            });\n        });\n        this.checkPoints.forEach((cp, idx) => {\n            new checkPoint_1.CheckPoint(world, cp, idx);\n        });\n    }\n    get size() { return this.info.size.clone().mul(env_1.pixelToSim); }\n    get startPos() { return this.convertPosVec2(this.info.startPos); }\n    get outerWalls() { return this.info.outerWalls.map(poly => poly.map(p => this.convertPosXY(p[0], p[1]))); }\n    get checkPoints() { return this.info.checkPoints.map(cp => [this.convertPosVec2(cp[0]), this.convertPosVec2(cp[1])]); }\n    ;\n    get checkPointCount() { return this.info.checkPoints.length; }\n    convertPosXY(x, y) {\n        return new planck_1.Vec2(x, this.info.size.y - y).mul(env_1.pixelToSim);\n    }\n    convertPosVec2(v) {\n        return new planck_1.Vec2(v.x, this.info.size.y - v.y).mul(env_1.pixelToSim);\n    }\n}\nexports.Course = Course;\nclass TestCourse extends Course {\n    constructor(world) {\n        super(world, {\n            size: new planck_1.Vec2(800, 480),\n            outerWalls: [\n                [[472, 32], [486, 35], [495, 35], [519, 40], [528, 40], [547, 44], [554, 47], [558, 47], [568, 51], [572, 51], [592, 59], [638, 84], [674, 110], [691, 127], [713, 157], [726, 184], [734, 209], [735, 214], [735, 282], [733, 288], [732, 301], [730, 305], [729, 324], [725, 347], [723, 351], [722, 361], [713, 389], [693, 425], [675, 445], [654, 461], [638, 468], [629, 470], [590, 470], [589, 469], [580, 469], [574, 467], [556, 465], [529, 456], [504, 444], [482, 426], [454, 390], [443, 369], [434, 347], [431, 343], [406, 329], [400, 324], [370, 308], [342, 308], [326, 313], [205, 313], [186, 309], [175, 309], [169, 307], [151, 305], [124, 296], [82, 267], [66, 245], [54, 219], [51, 208], [51, 174], [55, 153], [62, 138], [66, 125], [77, 104], [95, 85], [110, 73], [136, 59], [151, 54], [155, 54], [177, 48], [194, 48], [209, 44], [217, 44], [226, 41], [269, 39], [280, 36], [327, 35], [342, 32], [396, 32], [397, 31], [472, 32]],\n                [[395, 123], [354, 123], [342, 126], [293, 127], [284, 130], [240, 132], [230, 135], [222, 135], [209, 139], [192, 139], [178, 142], [169, 145], [152, 157], [142, 186], [142, 192], [145, 198], [152, 206], [156, 209], [170, 215], [181, 216], [187, 218], [198, 218], [217, 222], [312, 222], [330, 217], [385, 217], [405, 223], [442, 242], [463, 256], [479, 264], [494, 275], [510, 294], [520, 313], [531, 340], [552, 366], [575, 375], [587, 376], [593, 378], [601, 378], [602, 379], [615, 375], [621, 367], [629, 351], [630, 343], [633, 336], [634, 327], [637, 318], [638, 304], [639, 303], [639, 291], [644, 268], [644, 229], [635, 207], [626, 192], [616, 181], [587, 161], [552, 142], [535, 136], [531, 136], [515, 131], [507, 131], [494, 128], [484, 128], [459, 123], [396, 122], [395, 123]]\n            ],\n            startPos: new planck_1.Vec2(446, 78),\n            checkPoints: [\n                [new planck_1.Vec2(405, 25), new planck_1.Vec2(405, 127)],\n                [new planck_1.Vec2(249, 211), new planck_1.Vec2(249, 324)],\n                [new planck_1.Vec2(633, 245), new planck_1.Vec2(748, 245)],\n            ],\n        });\n    }\n}\nexports.TestCourse = TestCourse;\n\n\n//# sourceURL=webpack://2d-car-test/./src/common/courses/course.ts?");

/***/ }),

/***/ "./src/common/courses/courseView.ts":
/*!******************************************!*\
  !*** ./src/common/courses/courseView.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CourseView = void 0;\nconst planck_1 = __webpack_require__(/*! planck */ \"./node_modules/planck/dist/planck.js\");\nconst component_1 = __webpack_require__(/*! ../components/component */ \"./src/common/components/component.ts\");\nconst tinyCanvas_1 = __webpack_require__(/*! ../utils/tinyCanvas */ \"./src/common/utils/tinyCanvas.ts\");\nconst env_1 = __webpack_require__(/*! ../env */ \"./src/common/env.ts\");\nconst spriteSheet_1 = __webpack_require__(/*! ../spriteSheet */ \"./src/common/spriteSheet.ts\");\nclass CourseView extends component_1.Component {\n    constructor() {\n        super();\n        this.canvas = new tinyCanvas_1.TinyCanvas();\n        this._matrix = new DOMMatrix();\n        this._lastScreenSize = planck_1.Vec2.zero();\n        this.element = this.canvas.element.addClass(\"course\");\n    }\n    /**  */\n    get matrix() { return this._matrix; }\n    render(course, screenSize) {\n        if (planck_1.Vec2.areEqual(screenSize, this._lastScreenSize)) {\n            return;\n        }\n        this._lastScreenSize = screenSize;\n        const courseSize = course.size;\n        const scale = Math.min(screenSize.x / courseSize.x, screenSize.y / courseSize.y);\n        const scaledSize = planck_1.Vec2.mul(courseSize, scale);\n        const offset = planck_1.Vec2.mul(0.5, planck_1.Vec2.sub(screenSize, scaledSize));\n        //console.log(scaledSize, offset);\n        // \n        const mat = new DOMMatrix();\n        mat.translateSelf(offset.x, offset.y, 0);\n        mat.scaleSelf(scale, scale, 1, 0, 0, 0);\n        mat.translateSelf(0, courseSize.y, 0);\n        mat.scaleSelf(1, -1, 1, 0, 0, 0);\n        this._matrix = mat;\n        const pixelScale = env_1.pixelToSim * mat.a;\n        this.canvas.size = screenSize;\n        const ctx = this.canvas.ctx;\n        ctx.imageSmoothingEnabled = false;\n        ctx.setLineDash([]);\n        ctx.lineJoin = \"round\";\n        const path = new Path2D();\n        course.outerWalls.forEach(wall => wall.forEach((pt, idx) => idx == 0 ? path.moveTo(pt.x, pt.y) : path.lineTo(pt.x, pt.y)));\n        path.closePath();\n        // \n        {\n            ctx.resetTransform();\n            ctx.scale(pixelScale, pixelScale);\n            const pattern = ctx.createPattern(spriteSheet_1.spriteSheet.crop(spriteSheet_1.spriteInfos.grass).canvas, \"repeat\");\n            ctx.fillStyle = pattern;\n            ctx.fillRect(0, 0, this.canvas.canvas.width / pixelScale + 10, this.canvas.canvas.height / pixelScale + 10);\n        }\n        this.canvas.ctx.setTransform(mat);\n        // \n        {\n            ctx.save();\n            ctx.clip(path);\n            ctx.resetTransform();\n            ctx.scale(pixelScale, pixelScale);\n            const pattern = ctx.createPattern(spriteSheet_1.spriteSheet.crop(spriteSheet_1.spriteInfos.asphalt).canvas, \"repeat\");\n            ctx.fillStyle = pattern;\n            ctx.fillRect(0, 0, this.canvas.canvas.width / pixelScale + 10, this.canvas.canvas.height / pixelScale + 10);\n            ctx.restore();\n        }\n        // \n        {\n            const checkPoints = course.checkPoints;\n            if (checkPoints.length > 0) {\n                ctx.save();\n                ctx.clip(path);\n                const blockSize = 0.04;\n                const drawLine = (xOffset) => {\n                    ctx.beginPath();\n                    ctx.moveTo(checkPoints[0][0].x + xOffset, checkPoints[0][0].y);\n                    ctx.lineTo(checkPoints[0][1].x + xOffset, checkPoints[0][1].y);\n                    ctx.stroke();\n                };\n                ctx.strokeStyle = \"black\";\n                ctx.lineWidth = blockSize * 4;\n                drawLine(0);\n                ctx.strokeStyle = \"white\";\n                ctx.lineWidth = blockSize;\n                ctx.setLineDash([blockSize, blockSize]);\n                drawLine(-blockSize * 1.5);\n                drawLine(+blockSize * 0.5);\n                ctx.lineDashOffset = blockSize;\n                drawLine(-blockSize * 0.5);\n                drawLine(+blockSize * 1.5);\n                ctx.restore();\n            }\n        }\n        // \n        {\n            ctx.save();\n            ctx.clip(path);\n            ctx.lineWidth = 0.08;\n            ctx.strokeStyle = \"white\";\n            ctx.stroke(path);\n            ctx.setLineDash([0.08, 0.08]);\n            ctx.strokeStyle = \"red\";\n            ctx.lineWidth = 0.06;\n            ctx.stroke(path);\n            ctx.restore();\n        }\n        ctx.setLineDash([]);\n        ctx.lineWidth = 0.02;\n        ctx.strokeStyle = \"rgb(50, 50, 50)\";\n        ctx.stroke(path);\n    }\n}\nexports.CourseView = CourseView;\n\n\n//# sourceURL=webpack://2d-car-test/./src/common/courses/courseView.ts?");

/***/ }),

/***/ "./src/common/drivers/robotDriver.ts":
/*!*******************************************!*\
  !*** ./src/common/drivers/robotDriver.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RobotDriver = void 0;\nconst controlState_1 = __webpack_require__(/*! ../car/controlState */ \"./src/common/car/controlState.ts\");\nconst mathUtils_1 = __webpack_require__(/*! ../utils/mathUtils */ \"./src/common/utils/mathUtils.ts\");\nclass GeneRange {\n    constructor(min, max) {\n        this.min = min;\n        this.max = max;\n    }\n    clamp(value, minOverride) {\n        return (0, mathUtils_1.clamp)(value, minOverride !== null && minOverride !== void 0 ? minOverride : this.min, this.max);\n    }\n}\nconst rayCastDistanceRange = new GeneRange(0.001, 10);\nconst rayCastSpeedRatioRange = new GeneRange(0.001, 10);\nconst steeringRatioRange = new GeneRange(0.001, 1);\nconst rayCastDirectionOffsetRadRange = new GeneRange(0.001, 60 * mathUtils_1.degToRad);\nclass RobotDriver {\n    constructor(gene) {\n        this.controlState = new controlState_1.ControlState();\n        const rayCastMinDistance = rayCastDistanceRange.clamp(gene.rayCastMinDistance);\n        const steeringMinRatio = steeringRatioRange.clamp(gene.steeringMinRatio);\n        this.gene = {\n            rayCastMinDistance,\n            rayCastMaxDistance: rayCastDistanceRange.clamp(gene.rayCastMaxDistance, rayCastMinDistance),\n            rayCastSpeedRatio: rayCastSpeedRatioRange.clamp(gene.rayCastSpeedRatio),\n            steeringMinRatio,\n            steeringMaxRatio: steeringRatioRange.clamp(gene.steeringMaxRatio, steeringMinRatio),\n            rayCastDirectionOffsetRad: rayCastDirectionOffsetRadRange.clamp(gene.rayCastDirectionOffsetRad),\n        };\n    }\n    compute(car) {\n        this.controlState.accel = true;\n    }\n}\nexports.RobotDriver = RobotDriver;\n\n\n//# sourceURL=webpack://2d-car-test/./src/common/drivers/robotDriver.ts?");

/***/ }),

/***/ "./src/common/env.ts":
/*!***************************!*\
  !*** ./src/common/env.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pixelToSim = void 0;\nexports.pixelToSim = 0.01;\n\n\n//# sourceURL=webpack://2d-car-test/./src/common/env.ts?");

/***/ }),

/***/ "./src/common/gameWorld.ts":
/*!*********************************!*\
  !*** ./src/common/gameWorld.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GameWorld = void 0;\nconst planck_1 = __webpack_require__(/*! planck */ \"./node_modules/planck/dist/planck.js\");\nconst car_1 = __webpack_require__(/*! ./car/car */ \"./src/common/car/car.ts\");\nconst checkPoint_1 = __webpack_require__(/*! ./courses/checkPoint */ \"./src/common/courses/checkPoint.ts\");\nconst course_1 = __webpack_require__(/*! ./courses/course */ \"./src/common/courses/course.ts\");\nclass GameWorld {\n    constructor() {\n        this.world = new planck_1.World({ gravity: new planck_1.Vec2(0, 0) });\n        this._totalSec = 0;\n        this.course = new course_1.TestCourse(this.world); // ID\n        this.world.on(\"begin-contact\", e => {\n            const aUserData = e.getFixtureA().getUserData();\n            const bUserData = e.getFixtureB().getUserData();\n            if (aUserData instanceof car_1.Car) {\n                if (bUserData instanceof checkPoint_1.CheckPoint) {\n                    aUserData.onCheckPoint(bUserData.index, this._totalSec, this.course.checkPointCount);\n                }\n            }\n            else if (bUserData instanceof car_1.Car) {\n                if (aUserData instanceof checkPoint_1.CheckPoint) {\n                    bUserData.onCheckPoint(aUserData.index, this._totalSec, this.course.checkPointCount);\n                }\n            }\n        });\n    }\n    get totalSec() { return this._totalSec; }\n    step(deltaSec) {\n        this._totalSec += deltaSec;\n        this.world.step(deltaSec);\n    }\n}\nexports.GameWorld = GameWorld;\n\n\n//# sourceURL=webpack://2d-car-test/./src/common/gameWorld.ts?");

/***/ }),

/***/ "./src/common/geometries/rect.ts":
/*!***************************************!*\
  !*** ./src/common/geometries/rect.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Rect = void 0;\nconst vec2_1 = __webpack_require__(/*! ./vec2 */ \"./src/common/geometries/vec2.ts\");\nclass Rect {\n    constructor(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    get left() { return this.x; }\n    get top() { return this.y; }\n    get right() { return this.x + this.width; }\n    get bottom() { return this.y + this.height; }\n    get center() { return new vec2_1.Vec2((this.left + this.right) / 2, (this.top + this.bottom) / 2); }\n    get size() { return new vec2_1.Vec2(this.width, this.height); }\n    get isEmpty() { return this.width <= 0 || this.height <= 0; }\n    offset(offset) {\n        return new Rect(this.x + offset.x, this.y + offset.y, this.width, this.height);\n    }\n    scale(s) {\n        return new Rect(this.x * s, this.y * s, this.width * s, this.height * s);\n    }\n    deflate(params) {\n        var _a, _b, _c, _d, _e;\n        const def = (_a = params.all) !== null && _a !== void 0 ? _a : 0;\n        return Rect.fromLeftTopRightBottom(this.left + ((_b = params.left) !== null && _b !== void 0 ? _b : def), this.top + ((_c = params.top) !== null && _c !== void 0 ? _c : def), this.right - ((_d = params.right) !== null && _d !== void 0 ? _d : def), this.bottom - ((_e = params.bottom) !== null && _e !== void 0 ? _e : def));\n    }\n    objectPosition(objectSize) {\n        return new Rect((this.width - objectSize.x) / 2, (this.top + this.bottom - objectSize.y) / 2, objectSize.x, objectSize.y);\n    }\n    objectFitContain(objectSize) {\n        if (this.isEmpty) {\n            return Rect.zero;\n        }\n        const scale = Math.min(this.width / objectSize.x, this.height / objectSize.y);\n        const scaledSize = objectSize.scale(scale);\n        return this.objectPosition(scaledSize);\n    }\n    /**\n     * \n     * @param other \n     * @returns 0\n     */\n    intersect(other) {\n        const left = Math.max(this.left, other.left);\n        const top = Math.max(this.top, other.top);\n        const right = Math.min(this.right, other.right);\n        const bottom = Math.min(this.bottom, other.bottom);\n        const width = Math.max(0, right - left);\n        const height = Math.max(0, bottom - top);\n        return new Rect(left, top, width, height);\n    }\n    /**\n     * \n     * @param other \n     * @returns 2\n     */\n    union(other) {\n        // \n        if (this.isEmpty) {\n            return other;\n        }\n        if (other.isEmpty) {\n            return this;\n        }\n        const left = Math.min(this.left, other.left);\n        const top = Math.min(this.top, other.top);\n        const right = Math.max(this.right, other.right);\n        const bottom = Math.max(this.bottom, other.bottom);\n        const width = right - left;\n        const height = bottom - top;\n        return new Rect(left, top, width, height);\n    }\n    toString() { return `{ x: ${this.x}, y: ${this.y}, width: ${this.width}, height: ${this.height}}`; }\n    static fromSize(size) {\n        return new Rect(0, 0, size.x, size.y);\n    }\n    static fromLeftTopRightBottom(left, top, right, bottom) {\n        return new Rect(left, top, right - left, bottom - top);\n    }\n    static fromOuterBounds(e) {\n        var _a, _b;\n        return new Rect(0, 0, (_a = e.outerWidth()) !== null && _a !== void 0 ? _a : 0, (_b = e.outerHeight()) !== null && _b !== void 0 ? _b : 0);\n    }\n}\nexports.Rect = Rect;\n/**  */\nRect.zero = new Rect(0, 0, 0, 0);\n\n\n//# sourceURL=webpack://2d-car-test/./src/common/geometries/rect.ts?");

/***/ }),

/***/ "./src/common/geometries/vec2.ts":
/*!***************************************!*\
  !*** ./src/common/geometries/vec2.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Vec2 = void 0;\nclass Vec2 {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    scale(s) { return new Vec2(this.x * s, this.y * s); }\n}\nexports.Vec2 = Vec2;\n\n\n//# sourceURL=webpack://2d-car-test/./src/common/geometries/vec2.ts?");

/***/ }),

/***/ "./src/common/spriteSheet.ts":
/*!***********************************!*\
  !*** ./src/common/spriteSheet.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.spriteSheet = exports.spriteInfos = void 0;\nconst rect_1 = __webpack_require__(/*! ./geometries/rect */ \"./src/common/geometries/rect.ts\");\nconst vec2_1 = __webpack_require__(/*! ./geometries/vec2 */ \"./src/common/geometries/vec2.ts\");\nconst imagePreloader_1 = __webpack_require__(/*! ./utils/imagePreloader */ \"./src/common/utils/imagePreloader.ts\");\nconst tinyCanvas_1 = __webpack_require__(/*! ./utils/tinyCanvas */ \"./src/common/utils/tinyCanvas.ts\");\nexports.spriteInfos = {\n    car: new rect_1.Rect(2, 2, 13, 16),\n    asphalt: new rect_1.Rect(18, 2, 23, 23),\n    grass: new rect_1.Rect(44, 2, 23, 23),\n};\nclass SpriteSheet {\n    constructor() {\n        this.canvas = new tinyCanvas_1.TinyCanvas();\n    }\n    load() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const img = new imagePreloader_1.ImagePreloader(\"./sprite_sheet.png?rev=0\");\n            yield img.load();\n            this.canvas.size = new vec2_1.Vec2(img.img[0].naturalWidth, img.img[0].naturalHeight);\n            this.canvas.clear();\n            this.canvas.ctx.drawImage(img.img[0], 0, 0);\n        });\n    }\n    crop(rc) {\n        const newCanvas = new tinyCanvas_1.TinyCanvas();\n        newCanvas.size = rc.size;\n        newCanvas.clear();\n        newCanvas.ctx.drawImage(this.canvas.canvas, rc.left, rc.top, rc.width, rc.height, 0, 0, rc.width, rc.height);\n        return newCanvas;\n    }\n}\nexports.spriteSheet = new SpriteSheet();\n\n\n//# sourceURL=webpack://2d-car-test/./src/common/spriteSheet.ts?");

/***/ }),

/***/ "./src/common/utils/imagePreloader.ts":
/*!********************************************!*\
  !*** ./src/common/utils/imagePreloader.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ImagePreloader = void 0;\nfunction blobToBase64(blob) {\n    return new Promise((resolve, _) => {\n        const reader = new FileReader();\n        reader.onloadend = () => resolve(reader.result);\n        reader.readAsDataURL(blob);\n    });\n}\nfunction urlToBase64(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const res = yield fetch(url);\n        if (!res.ok) {\n            throw \"error\";\n        }\n        const blob = yield res.blob();\n        return yield blobToBase64(blob);\n    });\n}\nclass ImagePreloader {\n    constructor(url) {\n        this.url = url;\n    }\n    load() {\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            const err = () => reject(`${this.url}`);\n            try {\n                const img = document.createElement(\"img\");\n                img.onload = () => {\n                    img.width = img.naturalWidth;\n                    img.height = img.naturalHeight;\n                    this._img = $(img);\n                    resolve();\n                };\n                img.onerror = () => err();\n                img.src = yield urlToBase64(this.url);\n            }\n            catch (e) {\n                err();\n            }\n        }));\n    }\n    /**  */\n    get img() {\n        if (this._img == null) {\n            throw \"\";\n        }\n        return this._img;\n    }\n}\nexports.ImagePreloader = ImagePreloader;\n\n\n//# sourceURL=webpack://2d-car-test/./src/common/utils/imagePreloader.ts?");

/***/ }),

/***/ "./src/common/utils/mathUtils.ts":
/*!***************************************!*\
  !*** ./src/common/utils/mathUtils.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.radToDeg = exports.degToRad = void 0;\nexports.clamp = clamp;\nexports.rotateVec2 = rotateVec2;\nconst planck_1 = __webpack_require__(/*! planck */ \"./node_modules/planck/dist/planck.js\");\nexports.degToRad = Math.PI / 180;\nexports.radToDeg = 180 / Math.PI;\nfunction clamp(value, min, max) {\n    return Math.max(min, Math.min(value, max));\n}\nfunction rotateVec2(vec, angleRad) {\n    return new planck_1.Vec2(vec.x * Math.cos(angleRad) - vec.y * Math.sin(angleRad), vec.x * Math.sin(angleRad) + vec.y * Math.cos(angleRad));\n}\n\n\n//# sourceURL=webpack://2d-car-test/./src/common/utils/mathUtils.ts?");

/***/ }),

/***/ "./src/common/utils/tinyCanvas.ts":
/*!****************************************!*\
  !*** ./src/common/utils/tinyCanvas.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TinyCanvas = void 0;\nconst component_1 = __webpack_require__(/*! ../components/component */ \"./src/common/components/component.ts\");\nclass TinyCanvas extends component_1.Component {\n    constructor() {\n        super();\n        this.element = $(\"<canvas>\");\n        this.canvas = this.element[0];\n        this.ctx = this.canvas.getContext(\"2d\");\n    }\n    set size(s) {\n        this.canvas.width = s.x;\n        this.canvas.height = s.y;\n        // DPI\n        this.element.css({\n            width: s.x,\n            height: s.y,\n        });\n    }\n    clear() {\n        const oldMat = this.ctx.getTransform();\n        this.ctx.resetTransform();\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this.ctx.setTransform(oldMat);\n    }\n}\nexports.TinyCanvas = TinyCanvas;\n\n\n//# sourceURL=webpack://2d-car-test/./src/common/utils/tinyCanvas.ts?");

/***/ }),

/***/ "./src/index/index.ts":
/*!****************************!*\
  !*** ./src/index/index.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Development Build: npx webpack -w\n * Development Server: npx live-server docs\n * Development Server(HTTPS): npx live-server docs --https=ssl/https.js\n * Release Build: npx webpack --mode=production\n * URL: http://localhost:8080/\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst sceneController_1 = __webpack_require__(/*! ./scenes/sceneController */ \"./src/index/scenes/sceneController.ts\");\nconst spriteSheet_1 = __webpack_require__(/*! ../common/spriteSheet */ \"./src/common/spriteSheet.ts\");\nconst geneticGameScene_1 = __webpack_require__(/*! ./scenes/genetic_game/geneticGameScene */ \"./src/index/scenes/genetic_game/geneticGameScene.ts\");\n$(() => new PageController().start());\nclass PageController {\n    constructor() {\n        this.sceneController = new sceneController_1.SceneController();\n    }\n    start() {\n        return __awaiter(this, void 0, void 0, function* () {\n            $(document.body).append(this.sceneController.element);\n            yield spriteSheet_1.spriteSheet.load();\n            this.sceneController.changeScene(new geneticGameScene_1.GeneticGameScene(this.sceneController));\n        });\n    }\n}\n\n\n//# sourceURL=webpack://2d-car-test/./src/index/index.ts?");

/***/ }),

/***/ "./src/index/scenes/genetic_game/geneticGameScene.ts":
/*!***********************************************************!*\
  !*** ./src/index/scenes/genetic_game/geneticGameScene.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GeneticGameScene = void 0;\nconst ticker_1 = __webpack_require__(/*! ../../../common/animation/ticker */ \"./src/common/animation/ticker.ts\");\nconst car_1 = __webpack_require__(/*! ../../../common/car/car */ \"./src/common/car/car.ts\");\nconst carView_1 = __webpack_require__(/*! ../../../common/car/carView */ \"./src/common/car/carView.ts\");\nconst courseView_1 = __webpack_require__(/*! ../../../common/courses/courseView */ \"./src/common/courses/courseView.ts\");\nconst robotDriver_1 = __webpack_require__(/*! ../../../common/drivers/robotDriver */ \"./src/common/drivers/robotDriver.ts\");\nconst gameWorld_1 = __webpack_require__(/*! ../../../common/gameWorld */ \"./src/common/gameWorld.ts\");\nconst mathUtils_1 = __webpack_require__(/*! ../../../common/utils/mathUtils */ \"./src/common/utils/mathUtils.ts\");\nconst scene_1 = __webpack_require__(/*! ../scene */ \"./src/index/scenes/scene.ts\");\nclass GeneticGameScene extends scene_1.Scene {\n    //private readonly textEl = $(`<div class=\"lap-info\">`);\n    constructor(sceneController) {\n        super(sceneController, \"genetic-game-scene\");\n        this.gameWorld = new gameWorld_1.GameWorld();\n        this.courseView = new courseView_1.CourseView();\n        //private readonly humanDriver = new HumanDriver();\n        this.robotDriver = new robotDriver_1.RobotDriver({\n            rayCastMinDistance: 0.1,\n            rayCastMaxDistance: 0.3,\n            rayCastSpeedRatio: 1,\n            steeringMinRatio: 0,\n            steeringMaxRatio: 1,\n            rayCastDirectionOffsetRad: 30 * mathUtils_1.degToRad,\n        });\n        this.car = new car_1.Car(this.gameWorld.world, this.robotDriver.controlState);\n        this.carView = new carView_1.CarView();\n        this.ticker = new ticker_1.Ticker(frameStep => this.onTicker(frameStep));\n        this.element.append(this.courseView.element, this.carView.element);\n        this.car.reset(this.gameWorld.course.startPos, Math.PI / 2);\n        this.layout();\n    }\n    onStartScene() {\n        this.ticker.start();\n    }\n    onEndScene() {\n        this.ticker.stop();\n    }\n    onResize() {\n        this.layout();\n    }\n    onKeyDown(e) {\n        //this.humanDriver.onKeyDown(e);\n    }\n    onKeyUp(e) {\n        //this.humanDriver.onKeyUp(e);\n    }\n    layout() {\n        const screenSize = this.sceneController.screenSize;\n        this.courseView.render(this.gameWorld.course, screenSize);\n        this.updateCarView();\n    }\n    updateCarView() {\n        this.carView.update(this.car, this.courseView.matrix);\n    }\n    onTicker(deltaSec) {\n        this.robotDriver.compute(this.car);\n        this.car.update();\n        this.gameWorld.step(deltaSec);\n        this.updateCarView();\n        //this.updateTextInfo();\n    }\n}\nexports.GeneticGameScene = GeneticGameScene;\n\n\n//# sourceURL=webpack://2d-car-test/./src/index/scenes/genetic_game/geneticGameScene.ts?");

/***/ }),

/***/ "./src/index/scenes/scene.ts":
/*!***********************************!*\
  !*** ./src/index/scenes/scene.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Scene = void 0;\nconst component_1 = __webpack_require__(/*! ../../common/components/component */ \"./src/common/components/component.ts\");\nclass Scene extends component_1.Component {\n    constructor(sceneController, addClass) {\n        super();\n        this.sceneController = sceneController;\n        this.element = $(`<div class=\"scene\">`).addClass(addClass);\n    }\n    /**  */\n    onStartScene() {\n    }\n    /**  */\n    onEndScene() {\n    }\n    /**  */\n    onResize() {\n    }\n    onKeyDown(e) { }\n    onKeyUp(e) { }\n}\nexports.Scene = Scene;\n\n\n//# sourceURL=webpack://2d-car-test/./src/index/scenes/scene.ts?");

/***/ }),

/***/ "./src/index/scenes/sceneController.ts":
/*!*********************************************!*\
  !*** ./src/index/scenes/sceneController.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * ## View\n * - SceneController\n *   - scene\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SceneController = void 0;\nconst planck_1 = __webpack_require__(/*! planck */ \"./node_modules/planck/dist/planck.js\");\nconst component_1 = __webpack_require__(/*! ../../common/components/component */ \"./src/common/components/component.ts\");\nclass SceneController extends component_1.Component {\n    constructor() {\n        super();\n        this.element = $(`<div class=\"scene-ctrl\">`);\n        const observer = new ResizeObserver(() => { var _a; return (_a = this._curScene) === null || _a === void 0 ? void 0 : _a.onResize(); });\n        observer.observe(this.element[0]);\n        window.addEventListener(\"keydown\", e => {\n            var _a;\n            if (e.target instanceof HTMLButtonElement && (e.key == \"Enter\" || e.key == \" \")) {\n                e.preventDefault();\n            }\n            (_a = this._curScene) === null || _a === void 0 ? void 0 : _a.onKeyDown(e);\n        }, true);\n        window.addEventListener(\"keyup\", e => {\n            var _a;\n            (_a = this._curScene) === null || _a === void 0 ? void 0 : _a.onKeyUp(e);\n        }, true);\n    }\n    get screenSize() { return new planck_1.Vec2(this.element.outerWidth(), this.element.outerHeight()); }\n    /**  */\n    changeScene(newScene) {\n        var _a;\n        //console.log(\"changeScene:\", newScene);\n        (_a = this._curScene) === null || _a === void 0 ? void 0 : _a.onEndScene();\n        this.element.empty().append(newScene.element);\n        this._curScene = newScene;\n        newScene.onStartScene();\n    }\n}\nexports.SceneController = SceneController;\n\n\n//# sourceURL=webpack://2d-car-test/./src/index/scenes/sceneController.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index/index.ts");
/******/ 	
/******/ })()
;